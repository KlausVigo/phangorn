[{"path":[]},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://klausvigo.github.io/phangorn/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to phangorn","title":"Contributing to phangorn","text":"First , thanks considering contributing phangorn! 👍 ’s people like make rewarding us - project maintainers - work phangorn. 😊 phangorn open source project, maintained people care. directly funded .","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"how-you-can-contribute","dir":"","previous_headings":"","what":"How you can contribute","title":"Contributing to phangorn","text":"several ways can contribute project. want know contribute open source projects like one, see Open Source Guide.","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"share-the-love-️","dir":"","previous_headings":"How you can contribute","what":"Share the love ❤️","title":"Contributing to phangorn","text":"Think phangorn useful? Let others discover , telling person, via Twitter blog post. Using phangorn paper writing? Consider citing .","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"ask-a-question-️","dir":"","previous_headings":"How you can contribute","what":"Ask a question ⁉️","title":"Contributing to phangorn","text":"Using phangorn got stuck? Browse documentation see can find solution. Still stuck? Post question issue GitHub. offer user support, ’ll try best address , questions often lead better documentation discovery bugs. Want ask question private? Contact package maintainer [email][mailto:email].","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"propose-an-idea-","dir":"","previous_headings":"How you can contribute","what":"Propose an idea 💡","title":"Contributing to phangorn","text":"idea new phangorn feature? Take look documentation issue list see isn’t included suggested yet. , suggest idea issue GitHub. can’t promise implement idea, helps : Explain detail work. Keep scope narrow possible. See want contribute code idea well.","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"report-a-bug-","dir":"","previous_headings":"How you can contribute","what":"Report a bug 🐛","title":"Contributing to phangorn","text":"Using phangorn discovered bug? ’s annoying! Don’t let others experience report issue GitHub can fix . good bug report makes easier us , please include: operating system name version (e.g. Mac OS 10.13.6). details local setup might helpful troubleshooting. Detailed steps reproduce bug.","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"improve-the-documentation-","dir":"","previous_headings":"How you can contribute","what":"Improve the documentation 📖","title":"Contributing to phangorn","text":"Noticed typo website? Think function use better example? Good documentation makes difference, help improve welcome!","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"the-website","dir":"","previous_headings":"How you can contribute > Improve the documentation 📖","what":"The website","title":"Contributing to phangorn","text":"website generated pkgdown. means don’t write html: content pulled together documentation code, vignettes, Markdown files, package DESCRIPTION _pkgdown.yml settings. know way around pkgdown, can propose file change improve documentation. , report issue can point right direction.","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"function-documentation","dir":"","previous_headings":"How you can contribute > Improve the documentation 📖","what":"Function documentation","title":"Contributing to phangorn","text":"Functions described comments near code translated documentation using roxygen2. want improve function description: Go R/ directory code repository. Look file name function. Propose file change update function documentation roxygen comments (starting #').","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"contribute-code-","dir":"","previous_headings":"How you can contribute","what":"Contribute code 📝","title":"Contributing to phangorn","text":"package stable state development, active subsequent development primarily response user feedback. Care fix bugs implement new functionality phangorn? Awesome! 👏 look issue list leave comment things want work . See also development guidelines .","code":""},{"path":"https://klausvigo.github.io/phangorn/CONTRIBUTING.html","id":"development-guidelines","dir":"","previous_headings":"","what":"Development guidelines","title":"Contributing to phangorn","text":"try follow GitHub flow development. Fork repo clone computer. learn process, see guide. forked cloned project since worked , pull changes original repo clone using git pull upstream main. Open RStudio project file (.Rproj). Write code. Test code (bonus points adding unit tests). Document code (see function documentation ). Check code devtools::check() aim 0 errors warnings. Commit push changes. Submit pull request.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Markov models and transition rate matrices","text":"document illustrates phangorn (Schliep 2011) specialized features useful maybe well-known just (yet) described elsewhere. mainly interesting someone wants explore different models set simulation studies. show construct data objects different character states nucleotides amino acids set different models estimate transition rate. vignettes Estimating phylogenetic trees phangorn Phylogenetic trees morphological data describe detail estimate phylogenies nucleotides, amino acids morphological data.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"user-defined-data-formats","dir":"Articles","previous_headings":"","what":"User defined data formats","title":"Markov models and transition rate matrices","text":"better understand define data type useful know bit internal representation phyDat objects. internal representation phyDat object similar factor objects. example show several possibilities define nucleotide data gaps defined fifth state. Ignoring gaps coding ambiguous sites - done programs, also phangorn default - may misleading (see (Warnow 2012)). number gaps low randomly distributed, coding gaps separate state may important. Let’s assume given matrix row contains character vector taxonomic unit: Normally transform matrix phyDat object gaps handled ambiguous character (like “?”). Now define “USER” defined object supply vector levels character states new data – case four nucleotide states gap. Additionally can define ambiguous states can states. yet wanted, two sites alignment - contain ambiguous characters “r” “y” - got deleted. define ambiguous characters like “r” “y” explicitly supply contrast matrix similar contrasts factors. defined “n” state can nucleotide, gap. “?” can state including gap. data can used functions available phangorn compute distance matrices perform parsimony maximum likelihood analysis.","code":"library(phangorn) ## Loading required package: ape data <- matrix(c(\"r\",\"a\",\"y\",\"g\",\"g\",\"a\",\"c\",\"-\",\"c\",\"t\",\"c\",\"g\",     \"a\",\"a\",\"t\",\"g\",\"g\",\"a\",\"t\",\"-\",\"c\",\"t\",\"c\",\"a\",     \"a\",\"a\",\"t\",\"-\",\"g\",\"a\",\"c\",\"c\",\"c\",\"t\",\"?\",\"g\"),     dimnames = list(c(\"t1\", \"t2\", \"t3\"),NULL), nrow=3, byrow=TRUE) data ##    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] ## t1 \"r\"  \"a\"  \"y\"  \"g\"  \"g\"  \"a\"  \"c\"  \"-\"  \"c\"  \"t\"   \"c\"   \"g\"   ## t2 \"a\"  \"a\"  \"t\"  \"g\"  \"g\"  \"a\"  \"t\"  \"-\"  \"c\"  \"t\"   \"c\"   \"a\"   ## t3 \"a\"  \"a\"  \"t\"  \"-\"  \"g\"  \"a\"  \"c\"  \"c\"  \"c\"  \"t\"   \"?\"   \"g\" gapsdata1 <- phyDat(data) gapsdata1 ## 3 sequences with 12 character and 11 different site patterns. ## The states are a c g t gapsdata2 <- phyDat(data, type=\"USER\", levels=c(\"a\",\"c\",\"g\",\"t\",\"-\"),     ambiguity = c(\"?\", \"n\")) ## Warning in phyDat.default(data, levels = levels, return.index = return.index, : ## Found unknown characters (not supplied in levels). Deleted sites with unknown ## states. gapsdata2 ## 3 sequences with 10 character and 9 different site patterns. ## The states are a c g t - contrast <- matrix(data = c(1,0,0,0,0,     0,1,0,0,0,     0,0,1,0,0,     0,0,0,1,0,     1,0,1,0,0,     0,1,0,1,0,     0,0,0,0,1,     1,1,1,1,0,     1,1,1,1,1),     ncol = 5, byrow = TRUE) dimnames(contrast) <- list(c(\"a\",\"c\",\"g\",\"t\",\"r\",\"y\",\"-\",\"n\",\"?\"),     c(\"a\", \"c\", \"g\", \"t\", \"-\")) contrast ##   a c g t - ## a 1 0 0 0 0 ## c 0 1 0 0 0 ## g 0 0 1 0 0 ## t 0 0 0 1 0 ## r 1 0 1 0 0 ## y 0 1 0 1 0 ## - 0 0 0 0 1 ## n 1 1 1 1 0 ## ? 1 1 1 1 1 gapsdata3 <- phyDat(data, type=\"USER\", contrast=contrast) gapsdata3 ## 3 sequences with 12 character and 11 different site patterns. ## The states are a c g t -"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"markov-models-of-character-evolution","dir":"Articles","previous_headings":"","what":"Markov models of character evolution","title":"Markov models and transition rate matrices","text":"model nucleotide substitutions across edges tree T can assign transition matrix. case nucleotides, four character states, 4 ×\\times 4 transition matrix , , 12 free parameters. Time-reversible Markov models used describe characters change time, use fewer parameters. Time-reversible means models need directed time, Markov property states models depend current state. models used analyses phylogenies using maximum likelihood MCMC, computing pairwise distances, well simulating sequence evolution. now describe General Time-Reversible (GTR) model (Tavaré 1986). parameters GTR model equilibrium frequencies π=(πA,πC,πG,πT)\\pi = (\\pi_A ,\\pi_C ,\\pi_G ,\\pi_T) rate matrix QQ form Q=(*απCβπGγπTαπA*δπGϵπTβπAδπC*ηπTγπAϵπCηπG*)(1)\\begin{equation} Q = \\begin{pmatrix} \\ast  & \\alpha\\pi_C & \\beta\\pi_G & \\gamma\\pi_T \\\\ \\alpha\\pi_A & \\ast & \\delta\\pi_G & \\epsilon\\pi_T \\\\ \\beta\\pi_A & \\delta\\pi_C & \\ast & \\eta\\pi_T \\\\ \\gamma\\pi_A &  \\epsilon\\pi_C & \\eta\\pi_G & \\ast \\\\ \\end{pmatrix} (1) \\end{equation} need assign 6 parameters α,…,η\\alpha, \\dots, \\eta. elements diagonal chosen rows sum zero. Jukes-Cantor (JC) (Jukes Cantor 1969) model can derived special case GTR model, equal equilibrium frequencies πA=πC=πG=πT=0.25\\pi_A = \\pi_C = \\pi_G = \\pi_T = 0.25 equal rates set α=β=γ=δ=η\\alpha = \\beta = \\gamma = \\delta = \\eta. Table 2 lists built-nucleotide models phangorn. transition probabilities, describe probabilities change character ii jj time tt, given corresponding entries matrix exponential P(t)=(pij(t))=eQt,∑jpij=1 P(t) = (p_{ij}(t)) = e^{Qt}, \\qquad \\sum_j p_{ij}=1  P(t)P(t) transition matrix spanning period time tt.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"estimation-of-non-standard-transition-rate-matrices","dir":"Articles","previous_headings":"","what":"Estimation of non-standard transition rate matrices","title":"Markov models and transition rate matrices","text":"section User defined data formats described set user defined data formats. Now describe estimate transition matrices pml. nucleotide data common models can called directly optim.pml function (e.g. “JC69”, “HKY”, “GTR” name ). Table 2 lists available nucleotide models, can estimated directly optim.pml. amino acids several transition matrices available (“WAG”, “JTT”, “LG”, “Dayhoff”, “cpREV”, “mtmam”, “mtArt”, “MtZoa”, “mtREV24”, “VT”,“RtREV”, “HIVw”, “HIVb”, “FLU”, “Blosum62”, “Dayhoff_DCMut” “JTT-DCMut”) can estimated optim.pml. example Mathews, Clements, Beilstein (2010) used function estimate phytochrome amino acid transition matrix. now show estimate rate matrix different transition (α\\alpha) transversion ratio (β\\beta) fixed rate gap state (γ\\gamma) - kind Kimura two-parameter model (K81) nucleotide data gaps fifth state (see table 1). Tab 1. Rate matrix 3 parameters optimize. want fit non-standard transition rate matrix, tell optim.pml transitions Q get rate. parameter vector subs accepts vector consecutive integers least one element zero (get reference rate 1). Negative values indicate direct transition possible rate set zero. conventions models estimated: model supplied base frequencies bf rate matrix Q optimized according model (nucleotides) adequate rate matrix frequencies chosen (amino acids). optQ=TRUE neither model subs supplied symmetric (optBf=FALSE) reversible model (optBf=TRUE, .e. GTR nucleotides) estimated. can slow many character states, e.g. amino acids. Table 2 shows parameters optimized number parameters estimate. elements vector subs correspond α,…,η\\alpha, \\dots, \\eta equation (1) Tab 2. DNA models available phangorn.","code":"library(ape) tree <- unroot(rtree(3)) fit <- pml(tree, gapsdata3) fit <- optim.pml(fit, optQ=TRUE, subs=c(1,0,1,2,1,0,2,1,2,2),     control=pml.control(trace=0)) fit ## model: Mk  ## loglikelihood: -33.01  ## unconstrained loglikelihood: -28.43  ##  ## Rate matrix: ##           a         c         g         t      - ## a 0.000e+00 2.584e-06 1.000e+00 2.584e-06 0.6912 ## c 2.584e-06 0.000e+00 2.584e-06 1.000e+00 0.6912 ## g 1.000e+00 2.584e-06 0.000e+00 2.584e-06 0.6912 ## t 2.584e-06 1.000e+00 2.584e-06 0.000e+00 0.6912 ## - 6.912e-01 6.912e-01 6.912e-01 6.912e-01 0.0000 ##  ## Base frequencies:   ##   a   c   g   t   -  ## 0.2 0.2 0.2 0.2 0.2"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"predefined-models-for-user-defined-data","dir":"Articles","previous_headings":"Estimation of non-standard transition rate matrices","what":"Predefined models for user defined data","title":"Markov models and transition rate matrices","text":"far 4 models just generalization nucleotide models allowing different number states. many cases equal rates (ER) model appropriate. Tab 2: Build models available USER defined data. additional model ORDERED, assumes ordered characters allows switch neighboring states. Table 3 show corresponding rate matrix. Tab 3: Rate matrix “ORDERED” model 5 states.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"codon-substitution-models","dir":"Articles","previous_headings":"","what":"Codon substitution models","title":"Markov models and transition rate matrices","text":"special case transition rates codon models. phangorn now offers possibility estimate dN/dSd_N/d_S ratio (sometimes called ka/ks), overview see (Yang 2014). functions extend option estimate dN/dSd_N/d_S ratio pairwise sequence comparison available function kaks seqinr. transition rate codon ii jj defined follows: $$\\begin{eqnarray} q_{ij}=\\left\\{     \\begin{array}{l@{\\quad}l}          0 & \\textrm{j differ one position} \\\\          \\pi_j & \\textrm{synonymous transversion} \\\\          \\pi_j\\kappa & \\textrm{synonymous transition} \\\\          \\pi_j\\omega & \\textrm{non-synonymous transversion} \\\\          \\pi_j\\omega\\kappa & \\textrm{non-synonymous transition}     \\end{array}     \\right. \\nonumber \\end{eqnarray}$$ ω\\omega dN/dSd_N/d_S ratio, κ\\kappa transition transversion ratio πj\\pi_j equilibrium frequency codon jj. ω∼1\\omega\\sim1 amino acid change neutral, ω<1\\omega < 1 purifying selection ω>1\\omega > 1 positive selection. use data set follow loosely example Bielawski Yang (2005). first read alignment phylogenetic tree 45 sequences nef gene Human HIV-2 Genome using read.phyDat function. tree data set can estimate currently 3 different site models: M0 model constant ω\\omega, ω\\omega estimates average sites alignment. M0 allow distinct ω\\omega identifies classes, therefore retrieve information regarding positive selection. M1a nearly neutral model estimates two different ω\\omega value classes (ω=1\\omega=1 & ω<1\\omega<1). M2a positive selection model estimates three different classes ω\\omega (negative selection ω<1\\omega<1, neutral selection ω=1\\omega=1, positive selection ω>1\\omega>1). One can use likelihood ratio test compare M1a M2a positive selection. Currently choice site models limited three models mentioned branch models implemented far. can identify sites positive selection using Na\"ive empirical Bayes (NEB) method Yang Nielsen (1998): P(ω|xh)=P(Xh|ωi)piP(Xh)=P(Xh|ωi)pi∑jP(Xh|ωj)pj P(\\omega|x_h) = \\frac{P(X_h|\\omega_i)p_i}{P(X_h)} = \\frac{P(X_h|\\omega_i)p_i}{\\sum_j P(X_h|\\omega_j)p_j}   lot implementations differ way codon frequencies derived. M0 model can also estimated using pml optim.pml functions. several ways estimate codon frequencies πj\\pi_j. simplest model assume equal frequencies (=1/61). second use empirical codon frequencies, either computed using baseFreq using argument bf=\"empirical\" pml. usually really good codons rare high variance. One can estimate frequencies nucleotide frequencies F1x4 model. Last least frequencies can derived base frequencies codon position, F3x4 model set argument bf=\"F3x4\". F3x4 model can optimize codon frequencies setting option optBf=TRUE optim.pml.","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") hiv_2_nef <- read.phyDat(file.path(fdir, \"seqfile.txt\"), format=\"sequential\") tree <- read.tree(file.path(fdir, \"tree.txt\")) cdn <- codonTest(tree, hiv_2_nef) cdn ##   model Frequencies  estimate logLik  df   AIC   BIC  dnds_0 dnds_1 dnds_2 ## 1    M0        F3x4 empirical  -9773  98 19741 20087 0.50486     NA     NA ## 2   M1a        F3x4 empirical  -9313  99 18824 19168 0.06281      1     NA ## 3   M2a        F3x4 empirical  -9244 101 18689 19040 0.05551      1  2.469 ##      p_0    p_1    p_2  tstv ## 1 1.0000     NA     NA 4.418 ## 2 0.5563 0.4437     NA 4.364 ## 3 0.5227 0.3617 0.1156 4.849 plot(cdn, \"M1a\") plot(cdn, \"M2a\") treeM0 <- cdn$estimates[[\"M0\"]]$tree # tree with edge lengths M0 <- pml(treeM0, dna2codon(hiv_2_nef), bf=\"F3x4\") M0 <- optim.pml(M0, model=\"codon1\", control=pml.control(trace=0)) M0 ## model: codon1  ## loglikelihood: -9773  ## unconstrained loglikelihood: -1372  ## dn/ds: 0.5049  ## ts/tv: 4.418  ## Freq: F3x4 M0_opt <- optim.pml(M0, model=\"codon1\", optBf=TRUE, control=pml.control(trace=0)) M0_opt ## model: codon1  ## loglikelihood: -9668  ## unconstrained loglikelihood: -1372  ## dn/ds: 0.51  ## ts/tv: 4.581  ## Freq: F3x4"},{"path":"https://klausvigo.github.io/phangorn/articles/AdvancedFeatures.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Markov models and transition rate matrices","text":"","code":"## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.12.1.3 ape_5.8-1         ##  ## loaded via a namespace (and not attached): ##  [1] nlme_3.1-168      cli_3.6.5         knitr_1.50        rlang_1.1.6       ##  [5] xfun_0.52         generics_0.1.4    textshaping_1.0.1 jsonlite_2.0.0    ##  [9] backports_1.5.0   htmltools_0.5.8.1 ragg_1.4.0        sass_0.4.10       ## [13] rmarkdown_2.29    quadprog_1.5-8    grid_4.5.1        evaluate_1.0.4    ## [17] jquerylib_0.1.4   fastmap_1.2.0     yaml_2.3.10       lifecycle_1.0.4   ## [21] compiler_4.5.1    codetools_0.2-20  igraph_2.1.4      fs_1.6.6          ## [25] pkgconfig_2.0.3   Rcpp_1.0.14       htmlwidgets_1.6.4 systemfonts_1.2.3 ## [29] lattice_0.22-7    digest_0.6.37     R6_2.6.1          parallel_4.5.1    ## [33] magrittr_2.0.3    checkmate_2.3.2   Matrix_1.7-3      bslib_0.9.0       ## [37] tools_4.5.1       pkgdown_2.1.3     cachem_1.1.0      desc_1.4.3"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ancestral Sequence Reconstruction","text":"notes describe ancestral sequence reconstruction using phangorn package (Schliep 2011). phangorn provides several methods estimate ancestral character states either Maximum Parsimony (MP) Maximum Likelihood (ML). background methods see e.g. (Felsenstein 2004) (Yang 2006).","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"parsimony-reconstructions","dir":"Articles","previous_headings":"","what":"Parsimony reconstructions","title":"Ancestral Sequence Reconstruction","text":"reconstruct ancestral sequences first load data reconstruct tree: parsimony analysis edge length represent observed number changes. Reconstructing ancestral states therefore defines also edge lengths tree. However can exist several equally parsimonious reconstructions states can ambiguous therefore edge length can differ. phangorn ancestral reconstructions parsimony used based fitch algorithm (version 3.0) needed bifurcating trees. However trees can get pruned afterwards using function multi2di ape. Recently replaced acctran routine method based sankoff algorithm adopting algorithm joint reconstruction (Pupko et al. 2000) breaking ties random. additional benefit allows us infer phylogenies multifurcations. “MPR” reconstructs ancestral states (internal) node tree rooted node. However nodes independent . one chooses one state specific node, can restrict choice neighboring nodes (figures 2 3). also option “POSTORDER” one pass algorithm, useful teaching purposes. function acctran (accelerated transformation) assigns edge length internal nodes tree (Swofford Maddison 1987). plotSeqLogo function wrapper around ggseqlogo function ggseqlogo package (Wagih 2024) provides simple way show proportions nucleotides ancestral states (see figure 1). Fig 1. Ancestral reconstruction node. Fig 2. Ancestral reconstruction using MPR.","code":"library(phangorn) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\") tree <- pratchet(primates, trace=0) |> acctran(primates) |> makeNodeLabel() parsimony(tree, primates) ## [1] 746 anc.pars <- anc_pars(tree, primates) plotSeqLogo(anc.pars, node=getRoot(tree), 1, 20) plotAnc(anc.pars, 17) title(\"MPR\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"likelihood-reconstructions","dir":"Articles","previous_headings":"","what":"Likelihood reconstructions","title":"Ancestral Sequence Reconstruction","text":"phangorn also offers possibility estimate ancestral states using ML. advantages ML parsimony reconstruction accounts different edge lengths. Currently marginal construction (see (Yang 2006; Koshi Goldstein 1996)) joint reconstruction (Pupko et al. 2000) implemented. Joint reconstructions available models without rate variation (e.g. gamma models) invariant sites. can assign ancestral states according highest likelihood (“ml”): P(xr=)=L(xr=)∑k∈{,C,G,T}L(xr=k) P(x_r = ) =  \\frac{L(x_r=)}{\\sum_{k \\\\{,C,G,T\\}}L(x_r=k)}  highest posterior probability (“bayes”) criterion: P(xr=)=πAL(xr=)∑k∈{,C,G,T}πkL(xr=k), P(x_r=) =  \\frac{\\pi_A L(x_r=)}{\\sum_{k \\\\{,C,G,T\\}}\\pi_k L(x_r=k)},  L(xr)L(x_r) joint probability states tips state root xrx_r πi\\pi_i estimated base frequencies state ii. methods agree states (base frequencies) equal probabilities. differences two approaches specific site (17) represented following figures. Fig 4. Ancestral reconstruction using maximum likelihood.","code":"fit <- pml(tree, primates) fit <- optim.pml(fit, model=\"F81\", control = pml.control(trace=0)) anc.ml <- anc_pml(fit) plotAnc(anc.ml, 17) title(\"ML\") #plotAnc(anc.bayes, 17) #title(\"Bayes\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"fitting-for-discrete-comparative-data","dir":"Articles","previous_headings":"","what":"Fitting for discrete comparative data","title":"Ancestral Sequence Reconstruction","text":"Often already phylogeny want estimate ancestral reconstruction tree. common problem phylogentic comparative methods can use function ace ape (Paradis Schliep 2019), fitDiscrete geiger (Pennell et al. 2014) fitMK phytools (Revell 2012) package. want show fit models using optim.pml. First load tree create data. set pml object optimize model. Instead optimizing edge length optimize rate. can also fit symmetric (model=“SYM”) ordered metristic model (model=“ORDERED”). can compare estimate one ace ape. log-likelihood values differ slightly phangorn values get multiplied state frequencies. Thus add log(1/3) three states ace estimate two estimates almost identical.  complicated models can applied using defining rate matrix shown vignette Markov models transition rate matrices. “ARD” model currently available phangorn fits reversible models.","code":"data(\"bird.orders\") x <- c(rep(0, 5), rep(1, 18)) x[c(20,22,23)] <- 2 x <- factor(x) names(x) <- bird.orders$tip.label dat <- phyDat(x, \"USER\", levels=c(0,1,2)) fit <- pml(bird.orders, dat) fit_ER <- optim.pml(fit, optEdge = FALSE, optRate=TRUE,                      control = pml.control(trace=0)) fit_ER ## model: Mk  ## loglikelihood: -16.47  ## unconstrained loglikelihood: 0  ##  ## Rate matrix: ##   0 1 2 ## 0 0 1 1 ## 1 1 0 1 ## 2 1 1 0 ##  ## Base frequencies:   ##      0      1      2  ## 0.3333 0.3333 0.3333  ##  ## Rate: 0.007846 fit_SYM <- optim.pml(fit, optEdge = FALSE, optRate=TRUE, model=\"SYM\",                      control = pml.control(trace=0)) fit_SYM ## model: SYM  ## loglikelihood: -15.31  ## unconstrained loglikelihood: 0  ##  ## Rate matrix: ##           0      1         2 ## 0 0.000e+00 0.2747 1.604e-06 ## 1 2.747e-01 0.0000 1.000e+00 ## 2 1.604e-06 1.0000 0.000e+00 ##  ## Base frequencies:   ##      0      1      2  ## 0.3333 0.3333 0.3333  ##  ## Rate: 0.00678 fit_ace <- ace(x, bird.orders, model=\"SYM\", type = \"d\") ## Warning in sqrt(diag(solve(h))): NaNs produced fit_SYM$logLik ## [1] -15.31 fit_ace$loglik+log(1/3) ## [1] -15.31 all.equal(fit_SYM$logLik, fit_ace$loglik+log(1/3)) ## [1] \"Mean relative difference: 1.229e-07\" anc_SYM <- anc_pml(fit_SYM) plotAnc(anc_SYM)"},{"path":"https://klausvigo.github.io/phangorn/articles/Ancestral.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Ancestral Sequence Reconstruction","text":"","code":"## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.12.1.3 ape_5.8-1         ##  ## loaded via a namespace (and not attached): ##  [1] Matrix_1.7-3       gtable_0.3.6       jsonlite_2.0.0     dplyr_1.1.4        ##  [5] compiler_4.5.1     tidyselect_1.2.1   Rcpp_1.0.14        parallel_4.5.1     ##  [9] jquerylib_0.1.4    scales_1.4.0       systemfonts_1.2.3  textshaping_1.0.1  ## [13] yaml_2.3.10        fastmap_1.2.0      lattice_0.22-7     ggplot2_3.5.2      ## [17] R6_2.6.1           labeling_0.4.3     generics_0.1.4     igraph_2.1.4       ## [21] knitr_1.50         htmlwidgets_1.6.4  backports_1.5.0    tibble_3.3.0       ## [25] checkmate_2.3.2    desc_1.4.3         pillar_1.10.2      RColorBrewer_1.1-3 ## [29] bslib_0.9.0        rlang_1.1.6        fastmatch_1.1-6    cachem_1.1.0       ## [33] xfun_0.52          fs_1.6.6           quadprog_1.5-8     sass_0.4.10        ## [37] cli_3.6.5          withr_3.0.2        pkgdown_2.1.3      magrittr_2.0.3     ## [41] digest_0.6.37      grid_4.5.1         lifecycle_1.0.4    nlme_3.1-168       ## [45] vctrs_0.6.5        evaluate_1.0.4     glue_1.8.0         farver_2.1.2       ## [49] codetools_0.2-20   ragg_1.4.0         ggseqlogo_0.2      rmarkdown_2.29     ## [53] tools_4.5.1        pkgconfig_2.0.3    htmltools_0.5.8.1"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"installing-r","dir":"Articles","previous_headings":"","what":"Installing R","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Download R Select nearest mirror location https://cran.r-project.org/mirrors.html Select operating system download relevant installation file. Install R following instructions.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"installing-the-phangorn-library","dir":"Articles","previous_headings":"","what":"Installing the phangorn library","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Open R run two lines code command line. (need select region download library)","code":"install.packages(\"phangorn\", dependencies=TRUE) # install latest development version needs devtools install.packages(\"devtools\", dependencies=TRUE) library(devtools) install_github(\"KlausVigo/phangorn\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"","code":"library(phangorn)    # load the phangorn library ## Loading required package: ape"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"set-the-working-directory","dir":"Articles","previous_headings":"","what":"Set the working directory","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"often major stumbling block new R users. need specify folder structure wish work. .e, files stored wish input? done using setwd() function, e.g. setwd(\"C:/TreesNetworks/Example Files\"). now set folder phangorn package, contains files want load example.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"read-in-the-example-file-datasets","dir":"Articles","previous_headings":"","what":"Read in the example file datasets:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"example files based woodmouse dataset available ape library. Ultimately, dataset study: Michaux, J. R., Magnanou, E., Paradis, E., Nieberding, C. Libois, R. (2003) Mitochondrial phylogeography Woodmouse (Apodemus sylvaticus) Western Palearctic region. Molecular Ecology, 12, 685-697.) example files read R.","code":"## automatically set the correct working directory for the examples below # setwd(system.file(\"extdata/trees\", package = \"phangorn\")) # for this vignette we create a path to the files we want to load  fdir <- system.file(\"extdata/trees\", package = \"phangorn\") ## in your case it may look something like this... # setwd(\"C:/TreesNetworks/Example Files\")  ##DNA Matrix, maybe not needed  woodmouse <- read.phyDat(file.path(fdir, \"woodmouse.fasta\"),format=\"fasta\")  ## RAxML best-known tree with bipartition support (from previous analysis) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bipartitions.woodmouse\")) ## RAxML bootstrap trees (from previous analysis) raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.woodmouse\")) ## MrBayes consensus tree (50% majority rule) (from previous analysis) mrbayes.tree <- read.nexus(file.path(fdir,\"woodmouse.mrbayes.nex.con\")) ## MrBayes sample runs 1 and 2 (from previous analysis) run1 <- read.nexus(file.path(fdir,\"woodmouse.mrbayes.nex.run1.t\")) run2 <- read.nexus(file.path(fdir,\"woodmouse.mrbayes.nex.run2.t\")) ## How many trees are in the MrBayes tree sample? run1 ## 1001 phylogenetic trees run2 ## 1001 phylogenetic trees ## Combining the two runs and removing 25% burn-in mrbayes.trees <- c(run1[251:1001],run2[251:1001]) ## NeigbourNet Nexus file generated by SplitsTree (from previous analysis) Nnet <- read.nexus.networx(file.path(fdir,\"woodmouse.nxs\"))"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"viewing-the-data","dir":"Articles","previous_headings":"","what":"Viewing the data","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"","code":"par(mfrow=c(1,2), mar=c(1,1,1,1)) # Setting plot parameters ### Plotting trees with support values: ##  RAxML plot(raxml.tree) nodelabels(raxml.tree$node.label, adj = c(1, 0), frame = \"none\") ##  MrBayes plot(mrbayes.tree) nodelabels(mrbayes.tree$node.label, adj = c(1, 0), frame = \"none\") par(mfrow=c(1,1)) # Setting plot parameters # NeighborNet plot(Nnet,\"2D\") ## alternatively, # plot(Nnet,\"2D\")"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"a","dir":"Articles","previous_headings":"","what":"1A:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Identification edge bundles (black) neighbor-net (NN) network correspond branches (labelled 1-12) tree (maximum likelihood tree, case).","code":"# create a vector of labels for the network corresponding to edges in the tree edge.lab <- createLabel(Nnet, raxml.tree, raxml.tree$edge[,2], \"edge\") # could be also 1:27 instead of raxml.tree$edge[,2]  # Show the correspondingly labelled tree and network in R par(mfrow=c(1,2))   plot(raxml.tree, \"u\", rotate.tree = 180, cex=.7)  edgelabels(raxml.tree$edge[,2],col=\"blue\", frame=\"none\", cex=.7)  # find edges that are in the network but not in the tree edge.col <- rep(\"black\", nrow(Nnet$edge)) edge.col[ is.na(edge.lab) ] <- \"red\" # or a simpler alternative... edge.col <- createLabel(Nnet, raxml.tree, \"black\", nomatch=\"red\")  x <- plot(Nnet, edge.label = edge.lab, show.edge.label = T, \"2D\",            edge.color = edge.col, col.edge.label = \"blue\", cex=.7) # the above plot function returns an invisible networx object and this object  # also contains the colors for the edges."},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"b","dir":"Articles","previous_headings":"","what":"1B:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Bootstrap support branches (branch labels) ML tree mapped corresponding edge bundles NN network. edges network found ML tree branches highlighted red.  can write SplitsTree viewing…","code":"# the scaler argument multiplies the confidence values. This is useful to switch # confidences values between total, percentage or ratios.    x <- addConfidences(Nnet,raxml.tree, scaler = .01) # find splits that are in the network but not in the tree split.col <- rep(\"black\", length(x$splits)) split.col[ !matchSplits(as.splits(x), as.splits(raxml.tree)) ] <- \"red\"  # simpler alternative... split.col2 <- createLabel(x, raxml.tree, label=\"black\", \"split\", nomatch=\"red\")  # Plotting in R out.x <- plot(x,\"2D\",show.edge.label=TRUE, split.color=split.col,                col.edge.label = \"blue\") # write.nexus.networx(out.x,\"woodmouse.tree.support.nxs\") ## or we can also export the splits alone (for usage in software other than SplitsTree) # write.nexus.splits(as.splits(out.x),\"woodmouse.splits.support.nxs\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"c","dir":"Articles","previous_headings":"","what":"1C:","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"Frequencies bipartitions found bootstrap pseudoreplicates mapped corresponding edge bundles NN network using threshold 10% (.e. edge labelled occurs least 100 1000 ML-BS pseudoreplicates). Edge bundles found ML tree labelled using grey edges.","code":"y <- addConfidences(Nnet, as.splits(raxml.bootstrap)) edge.col <- createLabel(y, raxml.tree, label=\"black\", \"edge\", nomatch=\"grey\")  y <- plot(y,\"2D\",show.edge.label=TRUE, edge.color=edge.col) ## Write to SplitsTree for viewing # write.nexus.networx(y,\"NN.with.bs.support.nxs\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"extras","dir":"Articles","previous_headings":"","what":"Extras…","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"can also compare neighborNet consensusNet (Holland BR, Huber KT, Moulton V, Lockhart PJ,2004, Using consensus networks visualize contradictory evidence species phylogeny. Molecular Biology Evolution, 21, 1459-1461). Furthermore, can extract support values consensus network, place NeighborNet (similar process explained 1C ).","code":"cnet <- consensusNet(raxml.bootstrap,prob=0.10) edge.col <- createLabel(cnet, Nnet, label=\"black\", \"edge\", nomatch=\"grey\") cnet <- plot(cnet, \"2D\", show.edge.label = TRUE, edge.color=edge.col) edge.col <- createLabel(Nnet, cnet, label=\"black\", \"edge\", nomatch=\"grey\") z <- plot(Nnet, \"2D\", show.edge.label = TRUE, edge.color=edge.col) obj <- addConfidences(Nnet,cnet) plot(obj,\"2D\",show.edge.label=T, edge.color=edge.col, col.edge.label = \"blue\") ## Write to SplitsTree for viewing # write.nexus.networx(obj,\"Nnet.with.ML.Cnet.Bootstrap.nxs\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"section","dir":"Articles","previous_headings":"","what":"Intertwining phylogenetic trees and networks: R Example Script","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"four possible data patterns phylogenetic reconstruction: (1) patterns well supported network appear bootstrapped trees; (2) patterns well supported (part ) data/network appear optimized trees, .e. incompatible tree; (3) patterns weakly supported network appear optimized trees anyway, .e. compatible tree. demonstrate patterns showing relationships splits weights, NeighborNet splits graph, bootstrap bipartitions support bootstrap percentages plotted optimized tree dataset Wang, Braun, Kimball (2012). (advanced user figure…)","code":"Nnet <- read.nexus.networx(file.path(fdir,\"RAxML_distances.Wang.nxs\")) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bestTree.Wang.out\")) |> unroot() raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.Wang.out\"))  bs_splits <- as.splits(raxml.bootstrap) tree_splits <- as.splits(raxml.tree) |> unique() |> removeTrivialSplits() # we overwrite bootstrap values and set the weights  # to 1e-6 (almost zero), as we plot them on a log scale later on attr(bs_splits, \"weights\")[] <- 1e-6 # combine the splits from the bootstrap and neighbor net # and delete duplicates and add the confidence values # we get rid of trivial splits all_splits <- c(Nnet$splits, bs_splits) |> unique() |> removeTrivialSplits() |>    addConfidences(bs_splits, scaler=100)  # For easier plotting we create a matrix with the confidences and  # weights as columns tab <- data.frame(SplitWeight = attr(all_splits, \"weights\"),                    Bootstrap=attr(all_splits, \"confidences\"), Tree=FALSE) # we add a logical variable pto indicate which splits are in the RAxML tree tab$Tree[matchSplits(tree_splits, all_splits, FALSE)] <- TRUE  tab[is.na(tab[,\"Bootstrap\"]),\"Bootstrap\"] <- 0 tab[,\"Bootstrap\"] <- round(tab[,\"Bootstrap\"]) rownames(tab) <- apply(as.matrix(all_splits, zero.print = \".\", one.print = \"|\"),                         1, paste0, collapse=\"\") tab[1:10,] ##                              SplitWeight Bootstrap  Tree ## ..||........................   0.0171433       100  TRUE ## ..||||......................   0.0013902        14 FALSE ## ..||||......|||||...........   0.0001589         0 FALSE ## ||.........................|   0.0027691         1 FALSE ## ||..........................   0.0840367       100  TRUE ## ...|||......................   0.0001773         0 FALSE ## ...|||........|.|...........   0.0003663         0 FALSE ## |.|.........................   0.0060907         0 FALSE ## ....||......................   0.0385909       100  TRUE ## ||||........................   0.0018195        34  TRUE col <- rep(\"blue\", nrow(tab)) col[tab[,\"Bootstrap\"]==0] <- \"green\" col[tab[,\"SplitWeight\"]==1e-6] <- \"red\"  pch <- rep(19, nrow(tab)) pch[tab$Tree] <- 17  par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE) plot(tab[,\"SplitWeight\"], tab[,\"Bootstrap\"], log=\"x\", col=col, pch=pch,        xlab=\"Split weight (log scale)\", ylab=\"Bootstrap (%)\") legend(\"topright\", inset=c(-0.35,0), c(\"Pattern 1\", \"Pattern 2\", \"Pattern 3\",                         \"Pattern in the\\nbest tree\"), pch=c(19,19,19,17),                         col=c(\"blue\", \"green\", \"red\", \"black\"), bty=\"n\")"},{"path":"https://klausvigo.github.io/phangorn/articles/IntertwiningTreesAndNetworks.html","id":"figure-4","dir":"Articles","previous_headings":"","what":"Figure 4","title":"Intertwining phylogenetic trees and networks: R Example Script","text":"several option plotting co-phylogeny. following use cophylo function phytools package. Unfortunately function (yet) offer add confidences splits, can easily basic plot functions.  can compare consensus network different bootstrap values different genes.","code":"YCh <- read.tree(file.path(fdir, \"RAxML_bestTree.YCh\"))  mtG <- read.tree(file.path(fdir, \"RAxML_bestTree.mtG\"))  ncAI <- read.tree(file.path(fdir, \"RAxML_bestTree.AIs\"))  all_data <- read.tree(file.path(fdir, \"RAxML_bestTree.3moles\"))  YCh_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.YCh\"))  mtG_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.mtG\"))  ncAI_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.AIs\"))  all_data_boot <- read.tree(file.path(fdir, \"RAxML_bootstrap.3moles\")) library(phytools) par(mfrow=c(2,1)) obj <- cophylo(YCh, mtG)  plot(obj, mar=c(.1,.1,2,.1),scale.bar=c(.005,.05), ylim=c(-.2,1))   title(\"A. YCh                                    B. mtG\") obj <-  cophylo(ncAI, all_data) plot(obj, mar=c(.1,.1,2,.1),scale.bar=c(.005,.05), ylim=c(-.2,1)) title(\"C. ncAI                              D. All data\") par(mfrow=c(2,2), mar = c(2,2,4,2)) YCh <- plotBS(midpoint(YCh), YCh_boot, \"phylogram\", p=0, main = \"YCh\") mtG <- plotBS(midpoint(mtG), mtG_boot, \"phylogram\", p=0, main = \"mtG\") ncAI <- plotBS(midpoint(ncAI), ncAI_boot, \"phylogram\", p=0, main = \"ncAI\") all_data <- plotBS(midpoint(all_data), all_data_boot, \"phylogram\", p=0,                     main = \"All data\") par(mfrow=c(1,1)) cn <- consensusNet(c(YCh, mtG, ncAI)) cn <- addConfidences(cn, YCh_boot) |> addConfidences(mtG_boot, add=TRUE) |>    addConfidences(ncAI_boot, add=TRUE) |> addConfidences(all_data_boot, add=TRUE) plot(cn, \"2D\", show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/MLbyHand.html","id":"maximum-likelihood-by-hand","dir":"Articles","previous_headings":"","what":"Maximum likelihood by hand","title":"Maximum likelihood by hand","text":"function pml_bb phangorn (Schliep 2011) lot steps become easier shorter. want control used parameters, also possible use older functions, e.g. optim_pml. data vignette Estimating phylogenetic trees phangorn: starting tree, calculate neighbor joining tree: function pml returns object class pml. object contains data, tree many different parameters model like likelihood. many generic functions class pml available, allow handling objects. object fit just estimated likelihood tree got supplied, branch length optimized Jukes-Cantor (Jukes Cantor 1969) model yet, can done function optim.pml. default values pml estimate Jukes-Cantor model. means equal base frequencies transition rates equal. generic function update allows change parameters manually. usually want . However might want supply different tree change number rate categories. line changed model (discrete) rate across site model 4 rate categories (using default shape parameter 1), 0.2 invariant sites supply empirical base frequencies. change model GTR + Γ(4)\\Gamma(4) + model optimize parameters. control parameters thresholds fitting process can changed. want just suppress output fitting process. larger trees NNI rearrangements often get stuck local maximum. added two stochastic algorithms improve topology search. first (set rearrangement=\"stochastic\") performs stochastic rearrangements similar (Nguyen et al. 2015), makes random NNI permutation tree, gets optimized escape local optima. second option (rearrangement=\"ratchet\") perform likelihood ratchet (Vos 2003). algorithms may find better trees also take time.","code":"library(ape) library(phangorn) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\") dm <- dist.ml(primates) treeNJ  <- NJ(dm) fit <- pml(treeNJ, data=primates) fit ## model: JC  ## loglikelihood: -3075  ## unconstrained loglikelihood: -1230  ##  ## Rate matrix: ##   a c g t ## a 0 1 1 1 ## c 1 0 1 1 ## g 1 1 0 1 ## t 1 1 1 0 ##  ## Base frequencies:   ##    a    c    g    t  ## 0.25 0.25 0.25 0.25 methods(class=\"pml\") ##  [1] AICc   anova  BIC    glance logLik plot   print  simSeq update vcov   ## see '?methods' for accessing help and source code fitJC  <- optim.pml(fit, rearrangement=\"NNI\") ## optimize edge weights:  -3075 --> -3068  ## optimize edge weights:  -3068 --> -3068  ## optimize topology:  -3068 --> -3068  NNI moves:  1  ## optimize edge weights:  -3068 --> -3068  ## optimize topology:  -3068 --> -3068  NNI moves:  0 logLik(fitJC) ## 'log Lik.' -3068 (df=25) fitF81 <- update(fitJC, k=4, inv=0.2, bf=baseFreq(primates)) fitF81 ## model: F81+G(4)+I  ## loglikelihood: -3037  ## unconstrained loglikelihood: -1230  ## Proportion of invariant sites: 0.2  ## Model of rate heterogeneity: Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 1  ##     Rate Proportion ## 1 0.0000        0.2 ## 2 0.1712        0.2 ## 3 0.5959        0.2 ## 4 1.2500        0.2 ## 5 2.9829        0.2 ##  ## Rate matrix: ##   a c g t ## a 0 1 1 1 ## c 1 0 1 1 ## g 1 1 0 1 ## t 1 1 1 0 ##  ## Base frequencies:   ##       a       c       g       t  ## 0.37481 0.40160 0.03911 0.18448 fitGTR <- optim.pml(fitF81, model=\"GTR\", optInv=TRUE, optGamma=TRUE,     rearrangement = \"NNI\", control = pml.control(trace = 0)) fitGTR ## model: GTR+G(4)+I  ## loglikelihood: -2611  ## unconstrained loglikelihood: -1230  ## Proportion of invariant sites: 0.006978  ## Model of rate heterogeneity: Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 3.081  ##     Rate Proportion ## 1 0.0000   0.006978 ## 2 0.3982   0.248256 ## 3 0.7411   0.248256 ## 4 1.0905   0.248256 ## 5 1.7982   0.248256 ##  ## Rate matrix: ##         a         c         g      t ## a  0.0000  0.947235 63.592883  0.807 ## c  0.9472  0.000000  0.003986 24.635 ## g 63.5929  0.003986  0.000000  1.000 ## t  0.8070 24.634579  1.000000  0.000 ##  ## Base frequencies:   ##       a       c       g       t  ## 0.37481 0.40160 0.03911 0.18448 fitGTR <- optim.pml(fitGTR, model=\"GTR\", optInv=TRUE, optGamma=TRUE,     rearrangement = \"stochastic\", control = pml.control(trace = 0)) fitGTR ## model: GTR+G(4)+I  ## loglikelihood: -2608  ## unconstrained loglikelihood: -1230  ## Proportion of invariant sites: 0.007365  ## Model of rate heterogeneity: Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 2.912  ##     Rate Proportion ## 1 0.0000   0.007365 ## 2 0.3852   0.248159 ## 3 0.7320   0.248159 ## 4 1.0901   0.248159 ## 5 1.8224   0.248159 ##  ## Rate matrix: ##         a         c         g       t ## a  0.0000  0.680633 69.341299  0.5591 ## c  0.6806  0.000000  0.003307 24.4306 ## g 69.3413  0.003307  0.000000  1.0000 ## t  0.5591 24.430638  1.000000  0.0000 ##  ## Base frequencies:   ##       a       c       g       t  ## 0.37481 0.40160 0.03911 0.18448"},{"path":"https://klausvigo.github.io/phangorn/articles/MLbyHand.html","id":"model-comparison","dir":"Articles","previous_headings":"Maximum likelihood by hand","what":"Model comparison","title":"Maximum likelihood by hand","text":"can compare nested models JC GTR + Γ(4)\\Gamma(4) + model using likelihood ratio statistic Shimodaira-Hasegawa test AIC","code":"anova(fitJC, fitGTR) ## Likelihood Ratio Test Table ##   Log lik. Df Df change Diff log lik. Pr(>|Chi|)     ## 1    -3068 25                                        ## 2    -2608 35        10           920     <2e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 SH.test(fitGTR, fitJC) ##      Trees  ln L Diff ln L p-value ## [1,]     1 -2608       0.0  0.5061 ## [2,]     2 -3068     460.2  0.0000 AIC(fitJC) ## [1] 6187 AIC(fitGTR) ## [1] 5286 AICc(fitGTR) ## [1] 5299 BIC(fitGTR) ## [1] 5407"},{"path":"https://klausvigo.github.io/phangorn/articles/MLbyHand.html","id":"bootstrap","dir":"Articles","previous_headings":"Maximum likelihood by hand","what":"Bootstrap","title":"Maximum likelihood by hand","text":"last may want apply standard bootstrap test well edges tree supported. already shown vignette Estimating phylogenetic trees phangorn. Now can plot tree bootstrap support values edges also look consensusNet identify potential conflict. Tree bootstrap support. Unrooted tree (midpoint rooted) bootstrap support values. ConsensusNet bootstrap sample.","code":"bs <- bootstrap.pml(fitJC, bs=100, optNni=TRUE,     control = pml.control(trace = 0)) plotBS(midpoint(fitJC$tree), bs, p = 50, type=\"p\") cnet <- consensusNet(bs, p=0.2) plot(cnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/MLbyHand.html","id":"generating-trees","dir":"Articles","previous_headings":"","what":"Generating trees","title":"Maximum likelihood by hand","text":"phangorn several functions generate tree topologies, may interesting simulation studies. allTrees computes possible bifurcating tree topologies either rooted unrooted 10 taxa. One keep mind number trees growing exponentially, use howmanytrees ape reminder.  nni returns list trees one nearest neighbor interchange away. rNNI rSPR generate trees defined number NNI (nearest neighbor interchange) SPR (subtree pruning regrafting) away.","code":"trees <- allTrees(5) par(mfrow=c(3,5), mar=rep(0,4)) for(i in 1:15)plot(trees[[i]], cex=1, type=\"u\") nni(trees[[1]]) ## 4 phylogenetic trees"},{"path":"https://klausvigo.github.io/phangorn/articles/MLbyHand.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Maximum likelihood by hand","text":"","code":"## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.12.1.3 ape_5.8-1         ##  ## loaded via a namespace (and not attached): ##  [1] nlme_3.1-168      cli_3.6.5         knitr_1.50        rlang_1.1.6       ##  [5] xfun_0.52         generics_0.1.4    textshaping_1.0.1 jsonlite_2.0.0    ##  [9] backports_1.5.0   htmltools_0.5.8.1 ragg_1.4.0        sass_0.4.10       ## [13] rmarkdown_2.29    quadprog_1.5-8    grid_4.5.1        evaluate_1.0.4    ## [17] jquerylib_0.1.4   fastmap_1.2.0     yaml_2.3.10       lifecycle_1.0.4   ## [21] compiler_4.5.1    codetools_0.2-20  igraph_2.1.4      fs_1.6.6          ## [25] pkgconfig_2.0.3   Rcpp_1.0.14       htmlwidgets_1.6.4 systemfonts_1.2.3 ## [29] lattice_0.22-7    digest_0.6.37     R6_2.6.1          parallel_4.5.1    ## [33] magrittr_2.0.3    checkmate_2.3.2   Matrix_1.7-3      bslib_0.9.0       ## [37] tools_4.5.1       pkgdown_2.1.3     cachem_1.1.0      desc_1.4.3"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"load-packages","dir":"Articles","previous_headings":"","what":"Load packages","title":"Phylogenetic trees from morphological data","text":"start loading phangorn package setting random seed:","code":"library(phangorn) ## Loading required package: ape set.seed(9)"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Phylogenetic trees from morphological data","text":"dataset ’re using contains morphological data 12 mite species, 79 encoded characters (Schäffer et al. 2010). reading .csv file, row.names = 1 uses first column (species) row names. get phyDat object, convert dataframe matrix .matrix. data can written nexus file: Reading nexus file even easier reading csv file: reading nexus file, states 0:9, data states 0:7. one possibility change contrast matrix: Now data, can start analyses.","code":"fdir <- system.file(\"extdata\", package = \"phangorn\") mm <- read.csv(file.path(fdir, \"mites.csv\"), row.names = 1) mm_pd <- phyDat(as.matrix(mm), type = \"USER\", levels = 0:7) write.phyDat(mm_pd, file.path(fdir, \"mites.nex\"), format = \"nexus\") mm_pd <- read.phyDat(file.path(fdir, \"mites.nex\"), format = \"nexus\", type = \"STANDARD\") contrast <- matrix(data = c(1,0,0,0,0,0,0,0,0,     0,1,0,0,0,0,0,0,0,     0,0,1,0,0,0,0,0,0,     0,0,0,1,0,0,0,0,0,     0,0,0,0,1,0,0,0,0,     0,0,0,0,0,1,0,0,0,     0,0,0,0,0,0,1,0,0,     0,0,0,0,0,0,0,1,0,     0,0,0,0,0,0,0,0,1,     1,1,1,1,1,1,1,1,1),     ncol = 9, byrow = TRUE) dimnames(contrast) <- list(c(0:7,\"-\",\"?\"),     c(0:7, \"-\")) contrast ##   0 1 2 3 4 5 6 7 - ## 0 1 0 0 0 0 0 0 0 0 ## 1 0 1 0 0 0 0 0 0 0 ## 2 0 0 1 0 0 0 0 0 0 ## 3 0 0 0 1 0 0 0 0 0 ## 4 0 0 0 0 1 0 0 0 0 ## 5 0 0 0 0 0 1 0 0 0 ## 6 0 0 0 0 0 0 1 0 0 ## 7 0 0 0 0 0 0 0 1 0 ## - 0 0 0 0 0 0 0 0 1 ## ? 1 1 1 1 1 1 1 1 1 mm_pd <- phyDat(mm_pd, type=\"USER\", contrast=contrast)"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"parsimony","dir":"Articles","previous_headings":"","what":"Parsimony","title":"Phylogenetic trees from morphological data","text":"morphological data, one frequently used approaches conduct phylogenetic trees maximum parsimony (MP). pratchet (already described Estimating phylogenetic trees phangorn) implements parsimony ratchet (Nixon 1999). create starting tree, can use function random.addition: tree can given pratchet: =TRUE get (case 19) trees lowest parsimony score multiPhylo object. Since minimum 1000 iterations, already edge support. Now can assign edge lengths.","code":"mm_start <- random.addition(mm_pd) mm_tree <- pratchet(mm_pd, start = mm_start, minit = 1000, maxit = 10000,                     all = TRUE, trace = 0) mm_tree ## 19 phylogenetic trees mm_tree <- acctran(mm_tree, mm_pd)"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"branch-and-bound","dir":"Articles","previous_headings":"Parsimony","what":"Branch and bound","title":"Phylogenetic trees from morphological data","text":"case mites-dataset 12 sequences, ’s also possible use branch bound algorithm (Hendy Penny 1982) find parsimonious trees. bigger datasets definitely recommended use pratchet.","code":"mm_bab <- bab(mm_pd, trace = 0) mm_bab ## 37 phylogenetic trees"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"root-trees","dir":"Articles","previous_headings":"Parsimony","what":"Root trees","title":"Phylogenetic trees from morphological data","text":"want unrooted trees rooted, possibility use midpoint perform midpoint rooting. Rooting trees specific species (chose C. cymba ) can done function root ape package (Paradis Schliep 2019). save correct node labels (edge support), ’s important set edgelabel=TRUE.","code":"mm_tree_rooted <- root(mm_tree, outgroup = \"C._cymba\", resolve.root = TRUE,                        edgelabel = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"plot-trees","dir":"Articles","previous_headings":"Parsimony","what":"Plot trees","title":"Phylogenetic trees from morphological data","text":"plotBS plot tree respective edge support. also possible save plots .pdf (various formats, e.g. svg, png, tiff) file. digits argument determine number digits shown bootstrap values.","code":"# subsetting for tree nr. 9 plotBS(mm_tree_rooted[[9]], digits = 2)  # save plot as pdf pdf(file = \"mm_rooted.pdf\") plotBS(mm_tree_rooted[[9]], digits = 2) dev.off()"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"consensus-tree","dir":"Articles","previous_headings":"Parsimony","what":"Consensus tree","title":"Phylogenetic trees from morphological data","text":"look consensus tree 19 trees pratchet, 37 parsimonious trees bab, can use consensus function ape. Unrooted rooted consensus trees mites dataset MP. can clearly see , expected, two rooted trees topology.","code":"# unrooted pratchet tree mm_cons <- consensus(mm_tree)  # rooted pratchet tree mm_cons_root <- consensus(mm_tree_rooted, rooted = TRUE)  # branch and bound, we root the consensus tree in the same step mm_bab_cons <- root(consensus(mm_bab), outgroup = \"C._cymba\",                     resolve.root = TRUE, edgelabel = TRUE) plot(mm_cons, main=\"Unrooted pratchet consensus tree\") plot(mm_cons_root, main=\"Rooted pratchet consensus tree\") plot(mm_bab_cons, main=\"Rooted bab consensus tree\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Morphological.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Phylogenetic trees from morphological data","text":"","code":"## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.12.1.3 ape_5.8-1         ##  ## loaded via a namespace (and not attached): ##  [1] nlme_3.1-168      cli_3.6.5         knitr_1.50        rlang_1.1.6       ##  [5] xfun_0.52         generics_0.1.4    textshaping_1.0.1 jsonlite_2.0.0    ##  [9] backports_1.5.0   htmltools_0.5.8.1 ragg_1.4.0        sass_0.4.10       ## [13] rmarkdown_2.29    quadprog_1.5-8    grid_4.5.1        evaluate_1.0.4    ## [17] jquerylib_0.1.4   fastmap_1.2.0     yaml_2.3.10       lifecycle_1.0.4   ## [21] compiler_4.5.1    codetools_0.2-20  igraph_2.1.4      fs_1.6.6          ## [25] pkgconfig_2.0.3   Rcpp_1.0.14       htmlwidgets_1.6.4 systemfonts_1.2.3 ## [29] lattice_0.22-7    digest_0.6.37     R6_2.6.1          parallel_4.5.1    ## [33] magrittr_2.0.3    checkmate_2.3.2   Matrix_1.7-3      bslib_0.9.0       ## [37] tools_4.5.1       pkgdown_2.1.3     cachem_1.1.0      desc_1.4.3"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"consensusnet","dir":"Articles","previous_headings":"","what":"consensusNet","title":"Splits and Networx","text":"consensusNet (Holland et al. 2004) generalization consensus tree. Instead representing splits (taxon bipartitions) occurring least 50% trees bootstrap MCMC sample one can use lower threshold explore competing splits. Note , basic implementation used , consensusNet edge lengths proportional frequency corresponding splits provided list trees. input consensusNet list trees .e. object class multiPhylo.   many cases, consensusNet return two incompatible (competing) splits. plotted planar (2-dimensional) graph. situation requires n-dimensional graph, maximum number dimensions equals maximum number incompatible splits. example, three alternative incompatible splits: (,B)|(C,D) vs. (,C)|(B,D) vs. (,D)|(B,C), need 3-dimensional graph show three alternatives. nice way get still good impression network plot 3D. result spinning graph similar ","code":"set.seed(1) bs <- bootstrap.phyDat(yeast, FUN = function(x)nj(dist.hamming(x)),      bs=100) tree <- nj(dist.hamming(yeast)) par(\"mar\" = rep(1, 4)) tree <- plotBS(tree, bs, \"phylogram\") cnet <- consensusNet(bs, .3) plot(cnet, show.edge.label=TRUE) plot(cnet, \"3D\") # rotate 3d plot play3d(spin3d(axis=c(0,1,0), rpm=6), duration=10) # create animated gif file  movie3d(spin3d(axis=c(0,1,0), rpm=6), duration=10)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"neighbornet","dir":"Articles","previous_headings":"","what":"neighborNet","title":"Splits and Networx","text":"function neighborNet implements popular method Bryant Moulton (2004). Neighbor-Net algorithm essentially 2D-version Neighbor joining algorithm. Neighbour-net computed two steps: first computes circular ordering taxa data set; second step involves estimation edge weights using non-negative Least-Squares (nnls).  advantage Neighbor-Net returns circular split system can always displayed planar (2D) graph. rendering networx done using fantastic igraph package (Csardi Nepusz 2006).","code":"dm <- dist.hamming(yeast) nnet <- neighborNet(dm) par(\"mar\" = rep(1, 4)) plot(nnet)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"adding-support-values","dir":"Articles","previous_headings":"","what":"Adding support values","title":"Splits and Networx","text":"can use generic function addConfidences add (branch) support values tree, .e. object class phylo networx, splits phylo object. Neighbor-Net object computed provides support values. can add support values tree computed splits (edges) shared objects.  Analogously, can also add support values tree:","code":"nnet <- addConfidences(nnet, tree) par(\"mar\" = rep(1, 4)) plot(nnet, show.edge.label=TRUE) tree2 <- rNNI(tree, 2) tree2 <- addConfidences(tree2, tree) # several support values are missing par(\"mar\" = rep(1, 4)) plot(tree2, show.node.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"estimating-edge-weights-nnls","dir":"Articles","previous_headings":"","what":"Estimating edge weights (nnls)","title":"Splits and Networx","text":"Consensus networks, hand, provide primarily information support values corresponding split, information actual difference taxon bipartitions defined split. example, one may interested alternative support values correspond actual genetic distance involved taxa. Given distance matrix, can estimate edge weights using non-negative Least-Squares, plot onto consensusNet splits graph.","code":"cnet <- nnls.networx(cnet, dm) par(\"mar\" = rep(1, 4)) plot(cnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"import-and-export-networks-advanced-functions-for-networx-objects","dir":"Articles","previous_headings":"Estimating edge weights (nnls)","what":"Import and export networks, advanced functions for networx objects","title":"Splits and Networx","text":"functions read.nexus.networx write.nexus.networx can read write nexus files SplitsTree (Huson Bryant 2006). Check-new vignette IntertwiningTreesAndNetworks (K. Schliep et al. 2017) additional functions, examples, advanced application.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Networx.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Splits and Networx","text":"","code":"sessionInfo() ## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] phangorn_2.12.1.3 ape_5.8-1         ##  ## loaded via a namespace (and not attached): ##  [1] nlme_3.1-168      cli_3.6.5         knitr_1.50        rlang_1.1.6       ##  [5] xfun_0.52         generics_0.1.4    textshaping_1.0.1 jsonlite_2.0.0    ##  [9] backports_1.5.0   htmltools_0.5.8.1 ragg_1.4.0        sass_0.4.10       ## [13] rmarkdown_2.29    quadprog_1.5-8    grid_4.5.1        evaluate_1.0.4    ## [17] jquerylib_0.1.4   fastmap_1.2.0     yaml_2.3.10       lifecycle_1.0.4   ## [21] compiler_4.5.1    codetools_0.2-20  igraph_2.1.4      fs_1.6.6          ## [25] pkgconfig_2.0.3   Rcpp_1.0.14       htmlwidgets_1.6.4 systemfonts_1.2.3 ## [29] lattice_0.22-7    digest_0.6.37     R6_2.6.1          parallel_4.5.1    ## [33] magrittr_2.0.3    checkmate_2.3.2   Matrix_1.7-3      bslib_0.9.0       ## [37] tools_4.5.1       pkgdown_2.1.3     cachem_1.1.0      desc_1.4.3"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimating phylogenetic trees with phangorn","text":"notes enable user estimate phylogenetic trees alignment data different methods using phangorn package (Schliep 2011) . Several functions package also described detail (Paradis 2012). theoretical background methods see e.g. (Felsenstein 2004; Yang 2006). document illustrates package’s features estimate phylogenetic trees using different reconstruction methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Estimating phylogenetic trees with phangorn","text":"first thing read alignment. Unfortunately exist many different file formats alignments can stored . cases, function read.phyDat used read alignment. ape package (Paradis Schliep 2019) phangorn, several functions read alignments, depending format data set (“nexus”, “phylip”, “fasta”) kind data (amino acid, nucleotides, morphological data). function read.phyDat calls functions transforms phyDat object. specific parameter settings available look help files function read.dna (phylip, fasta, clustal format), read.nexus.data nexus files. amino acid data additional read.aa called. Morphological data shown later vignette Phylogenetic trees morphological data. start analysis loading phangorn package reading alignment.","code":"library(ape) library(phangorn) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"distance-based-methods","dir":"Articles","previous_headings":"","what":"Distance based methods","title":"Estimating phylogenetic trees with phangorn","text":"reading nucleotide alignment can build first tree distance based methods. function dist.dna ape package computes distances many DNA substitution models, use function dist.dna, transform data class DNAbin. function dist.ml phangorn offers substitution models “JC69” “F81” DNA, also common substitution models amino acids (e.g. “WAG”, “JTT”, “LG”, “Dayhoff”, “cpREV”, “mtmam”, “mtArt”, “MtZoa” “mtREV24”). constructing distance matrix, reconstruct rooted tree UPGMA alternatively unrooted tree using Neighbor Joining (Saitou Nei 1987; Studier Keppler 1988). distance methods like fastme available ape package. can plot trees treeUPGMA treeNJ commands: Rooted UPGMA tree. Unrooted NJ tree.","code":"dm  <- dist.ml(primates) treeUPGMA  <- upgma(dm) treeNJ  <- NJ(dm) plot(treeUPGMA, main=\"UPGMA\") plot(treeNJ, \"unrooted\", main=\"NJ\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"bootstrap","dir":"Articles","previous_headings":"Distance based methods","what":"Bootstrap","title":"Estimating phylogenetic trees with phangorn","text":"run bootstrap first need write function computes tree alignment. first need compute distance matrix afterwards compute tree. can give function bootstrap.phyDat function. new syntax R 4.1 can written bit shorter: Finally, can plot tree bootstrap values added: Rooted UPGMA tree. Distance based methods fast use UPGMA NJ tree starting trees maximum parsimony maximum likelihood analyses.","code":"fun <- function(x) upgma(dist.ml(x)) bs_upgma <- bootstrap.phyDat(primates,  fun) bs_upgma <- bootstrap.phyDat(primates,  \\(x){dist.ml(x) |> upgma}) plotBS(treeUPGMA, bs_upgma, main=\"UPGMA\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"parsimony","dir":"Articles","previous_headings":"","what":"Parsimony","title":"Estimating phylogenetic trees with phangorn","text":"function parsimony returns parsimony score, minimum number changes necessary describe data given tree. can compare parsimony score two trees computed far: function users want use infer phylogenies MP (maximum parsimony) pratchet, implementation parsimony ratchet (Nixon 1999). allows escape local optima find better trees performing NNI / SPR rearrangements. current implementation Create bootstrap data set DbD_b original data set. Take current best tree perform tree rearrangements DbD_b save bootstrap tree TbT_b. Use TbT_b perform tree rearrangements original data set. tree lower parsimony score currently best tree, replace . Iterate 1:3 either given number iteration reached (minit) improvements recorded number iterations (k). set minimum iteration parsimony ratchet (minit) 100 iterations, default number k 10. ratchet implicitly performs bootstrap resampling, already computed branch support, case least 100 bootstrap iterations. parameter trace=0 tells function write current status console. function may return several best trees, trees branch length assigned yet. Now let’s : assigning edge weights, prune away internal edges length tol (default = 1e-08), trees may contain multifurcations. trees might differed edges length 0. mentioned , parsimony ratchet implicitly performs bootstrap analysis (step 1). make use store trees visited. allows us add bootstrap support values tree.  treeRatchet list trees, .e. object class multiPhylo, can subset -th trees treeRatchet[[]]. cases pratchet enough use, phangorn exports function might useful. random.addition computes random addition can used generate starting trees. function optim.parsimony performs tree rearrangements find trees lower parsimony score. tree rearrangements implemented nearest-neighbor interchanges (NNI) subtree pruning regrafting (SPR). latter far works fitch algorithm.","code":"parsimony(treeUPGMA, primates) ## [1] 751 parsimony(treeNJ, primates) ## [1] 746 treeRatchet  <- pratchet(primates, trace = 0, minit=100) parsimony(treeRatchet, primates) ## [1] 746 treeRatchet  <- acctran(treeRatchet, primates) treeRatchet  <- di2multi(treeRatchet) if(inherits(treeRatchet, \"multiPhylo\")){   treeRatchet <- unique(treeRatchet) } plotBS(midpoint(treeRatchet), type=\"phylogram\") add.scale.bar() treeRA <- random.addition(primates) treeSPR  <- optim.parsimony(treeRA, primates) ## Final p-score 746 after  1 nni operations parsimony(c(treeRA, treeSPR), primates) ## [1] 750 746"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"branch-and-bound","dir":"Articles","previous_headings":"Parsimony","what":"Branch and bound","title":"Estimating phylogenetic trees with phangorn","text":"data sets species also possible find parsimonious trees using branch bound algorithm (Hendy Penny 1982). data sets 10 taxa can take long time depends strongly “tree-like” data . 20-30 taxa take almost forever.","code":"(trees <- bab(primates[1:10,], trace=0)) ## 1 phylogenetic tree"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"maximum-likelihood","dir":"Articles","previous_headings":"","what":"Maximum likelihood","title":"Estimating phylogenetic trees with phangorn","text":"last method describe vignette Maximum Likelihood (ML) introduced Felsenstein (Felsenstein 1981).","code":""},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"model-selection","dir":"Articles","previous_headings":"Maximum likelihood","what":"Model selection","title":"Estimating phylogenetic trees with phangorn","text":"Usually, first step, try find best fitting model. use function modelTest compare different nucleotide protein models AIC, AICc BIC, similar popular programs ModelTest ProtTest (D. Posada Crandall 1998; David Posada 2008; Abascal, Zardoya, Posada 2005). default available nucleotide amino acid models compared. Vignette Markov models transition rate matrices gives background models, estimated can work . ’s also possible select common models: results modelTest illustrated following table: speed computations thresholds optimizations modelTest strict optim.pml (shown coming vignettes) tree rearrangements performed, time consuming part optimizing process. modelTest computes optimizes lot models waste computer time save results. results saved call together optimized trees environment function .pml evaluates call get pml object back use optimization analysis. can either done specific model, specific criterion.","code":"mt <- modelTest(primates) mt <- modelTest(primates, model=c(\"JC\", \"F81\", \"K80\", \"HKY\", \"SYM\", \"GTR\"),                  control = pml.control(trace = 0)) fit <- as.pml(mt, \"HKY+G(4)+I\") fit <- as.pml(mt, \"BIC\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"conducting-a-ml-tree","dir":"Articles","previous_headings":"Maximum likelihood","what":"Conducting a ML tree","title":"Estimating phylogenetic trees with phangorn","text":"simplify workflow, can give result modelTest function pml_bb optimize parameters taking best model according BIC. Ultrafast bootstrapping (Minh, Nguyen, Haeseler 2013) conducted automatically default rearrangements=\"stochastic\" used. rearrangements=\"NNI\" used, bootstrapping conducted. can also use pml_bb defined model infer phylogenetic tree.","code":"fit_mt <- pml_bb(mt, control = pml.control(trace = 0)) fit_mt ## model: HKY+G(4)  ## loglikelihood: -2615.014  ## unconstrained loglikelihood: -1230.335  ## Model of rate heterogeneity: Discrete gamma model ## Number of rate categories: 4  ## Shape parameter: 2.272913  ##        Rate Proportion ## 1 0.3238122       0.25 ## 2 0.6812153       0.25 ## 3 1.0755277       0.25 ## 4 1.9194448       0.25 ##  ## Rate matrix: ##          a        c        g        t ## a  0.00000  1.00000 54.54208  1.00000 ## c  1.00000  0.00000  1.00000 54.54208 ## g 54.54208  1.00000  0.00000  1.00000 ## t  1.00000 54.54208  1.00000  0.00000 ##  ## Base frequencies:   ##          a          c          g          t  ## 0.37480751 0.40160148 0.03911303 0.18447798 fitGTR <- pml_bb(primates, model=\"GTR+G(4)+I\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"bootstrap-1","dir":"Articles","previous_headings":"Maximum likelihood","what":"Bootstrap","title":"Estimating phylogenetic trees with phangorn","text":"instead want conduct standard bootstrapping (Felsenstein 1985; Penny Hendy 1985), can function bootstrap.pml: Now can plot tree bootstrap support values edges compare standard bootstrap values ultrafast bootstrap values. function plotBS possible plot two, also transfer bootstraps (Lemoine et al. 2018) especially useful large data sets. Unrooted tree (midpoint rooted) ultrafast, standard transfer bootstrap support values. want assign standard transfer bootstrap values node labels tree instead plotting (e.g. export tree somewhere else), plotBS gives option type = \"n\": also possible look consensusNet identify potential conflict. ConsensusNet standard bootstrap sample. Several analyses, e.g.bootstrap modelTest, can computationally demanding, nowadays computers several cores, one can distribute computations using parallel package. However, possible use approach R running command line (“X11”), using GUI (example “Aqua” Macs) unfortunately parallel package work Windows.","code":"bs <- bootstrap.pml(fit_mt, bs=100, optNni=TRUE,     control = pml.control(trace = 0)) plotBS(midpoint(fit_mt$tree), p = .5, type=\"p\", digits=2, main=\"Ultrafast bootstrap\")  plotBS(midpoint(fit_mt$tree), bs, p = 50, type=\"p\", main=\"Standard bootstrap\")  plotBS(midpoint(fit_mt$tree), bs, p = 50, type=\"p\", digits=0, method = \"TBE\", main=\"Transfer bootstrap\") # assigning standard bootstrap values to our tree; this is the default method tree_stdbs <- plotBS(fit_mt$tree, bs, type = \"n\")  # assigning transfer bootstrap values to our tree tree_tfbs <- plotBS(fit_mt$tree, bs, type = \"n\", method = \"TBE\") cnet <- consensusNet(bs, p=0.2) plot(cnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"exporting-a-tree","dir":"Articles","previous_headings":"Maximum likelihood","what":"Exporting a tree","title":"Estimating phylogenetic trees with phangorn","text":"Now tree bootstrap values, can easily write file Newick-format:","code":"# tree with ultrafast bootstrap values write.tree(fit_mt$tree, \"primates.tree\")  # tree with standard bootstrap values write.tree(tree_stdbs, \"primates.tree\")  # tree with transfer bootstrap values write.tree(tree_tfbs, \"primates.tree\")"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"molecular-dating-with-a-strict-clock-for-ultrametric-and-tipdated-phylogenies","dir":"Articles","previous_headings":"Maximum likelihood","what":"Molecular dating with a strict clock for ultrametric and tipdated phylogenies","title":"Estimating phylogenetic trees with phangorn","text":"assume “molecular clock” phylogenies can used infer divergence times (Zuckerkandl Pauling 1965). implemented strict clock described (Felsenstein 2004), p. 266, allowing infer ultrametric tip-dated phylogenies. function pml_bb ensures tree ultrametric, constraints given tip dates fulfilled. differs function optim.pml th tree supplied function fulfill constraints. case ultrametric starting tree can use UPGMA WPGMA tree.  phangorn also can estimate tipdated phylogenies. use H3N2 virus data set treetime (Sagulenko, Puller, Neher 2018) example. Additionally alignment also need read data containing dates tips. first process sampling dates create named vector. lubridate package (Grolemund Wickham 2011) comes handy dates case one recode dates, e.g. days months. use pml_bb function, optimizes tree given constraints tip.dates vector. loglikelihood lower unrooted tree, keep mind rooted trees use less parameters. unrooted trees estimate one edge length parameter tree, ultrametric trees estimate parameter internal node tipdated trees one additional parameter rate. rate comparable slope fo tip--root regression programs like TempEst (Rambaut et al. 2016). last plot tree timescale.","code":"fit_strict <- pml_bb(primates, model=\"HKY+G(4)\", method=\"ultrametric\",                      rearrangement=\"NNI\", control = pml.control(trace = 0)) plot(fit_strict) fdir <- system.file(\"extdata/trees\", package = \"phangorn\") tmp <- read.csv(file.path(fdir,\"H3N2_NA_20.csv\")) H3N2 <- read.phyDat(file.path(fdir,\"H3N2_NA_20.fasta\"), format=\"fasta\") dates <- setNames(tmp$numdate_given, tmp$name) head(dates) ##               A/Hawaii/02/2013|KF789866|05/28/2013|USA|12_13|H3N2/1-1409  ##                                                                 2013.405  ##         A/Boston/DOA2_107/2012|CY148382|11/01/2012|USA|12_13|H3N2/1-1409  ##                                                                 2012.838  ##               A/Oregon/15/2009|GQ895004|06/25/2009|USA|08_09|H3N2/1-1409  ##                                                                 2009.482  ## A/Hong_Kong/H090_695_V10/2009|CY115546|07/10/2009|Hong_Kong||H3N2/8-1416  ##                                                                 2009.523  ##            A/New_York/182/2000|CY001279|02/18/2000|USA|99_00|H3N2/1-1409  ##                                                                 2000.134  ##        A/Canterbury/58/2000|CY009150|09/05/2000|New_Zealand||H3N2/8-1416  ##                                                                 2000.682 fit_td <- pml_bb(H3N2, model=\"HKY+I\", method=\"tipdated\", tip.dates=dates,                 rearrangement=\"NNI\", control = pml.control(trace = 0)) fit_td ## model: HKY+I  ## loglikelihood: -3117.866  ## unconstrained loglikelihood: -2883.911  ## Proportion of invariant sites: 0.6865064  ##  ## Rate: 0.002534975  ##  ## Rate matrix: ##          a        c        g        t ## a 0.000000 1.000000 9.866433 1.000000 ## c 1.000000 0.000000 1.000000 9.866433 ## g 9.866433 1.000000 0.000000 1.000000 ## t 1.000000 9.866433 1.000000 0.000000 ##  ## Base frequencies:   ##         a         c         g         t  ## 0.3097759 0.1928617 0.2376819 0.2596805  ##  ## Rate: 0.002534975 plot(fit_td, align.tip.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/articles/Trees.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session info","title":"Estimating phylogenetic trees with phangorn","text":"","code":"## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ## [1] knitr_1.50        phangorn_2.12.1.3 ape_5.8-1         ##  ## loaded via a namespace (and not attached): ##  [1] nlme_3.1-168      cli_3.6.5         rlang_1.1.6       xfun_0.52         ##  [5] generics_0.1.4    textshaping_1.0.1 jsonlite_2.0.0    backports_1.5.0   ##  [9] htmltools_0.5.8.1 ragg_1.4.0        sass_0.4.10       rmarkdown_2.29    ## [13] quadprog_1.5-8    grid_4.5.1        evaluate_1.0.4    jquerylib_0.1.4   ## [17] fastmap_1.2.0     yaml_2.3.10       lifecycle_1.0.4   compiler_4.5.1    ## [21] codetools_0.2-20  igraph_2.1.4      fs_1.6.6          fastmatch_1.1-6   ## [25] pkgconfig_2.0.3   Rcpp_1.0.14       htmlwidgets_1.6.4 systemfonts_1.2.3 ## [29] lattice_0.22-7    digest_0.6.37     R6_2.6.1          parallel_4.5.1    ## [33] magrittr_2.0.3    checkmate_2.3.2   Matrix_1.7-3      bslib_0.9.0       ## [37] tools_4.5.1       pkgdown_2.1.3     cachem_1.1.0      desc_1.4.3"},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Klaus Schliep. Author, maintainer. Emmanuel Paradis. Author. Leonardo de Oliveira Martins. Author. Alastair Potts. Author. Iris Bardel-Kahr. Author. Tim W. White. Contributor. Cyrill Stachniss. Contributor. Michelle Kendall. Contributor. Keren Halabi. Contributor. Richel Bilderbeek. Contributor. Kristin Winchell. Contributor. Liam Revell. Contributor. Mike Gilchrist. Contributor. Jeremy Beaulieu. Contributor. Brian O'Meara. Contributor. Long Qu. Contributor. Joseph Brown. Contributor. Santiago Claramunt. Contributor.","code":""},{"path":"https://klausvigo.github.io/phangorn/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schliep K.P. 2011. phangorn: phylogenetic analysis R. Bioinformatics, 27(4) 592-593 Schliep, K., Potts, . J., Morrison, D. ., Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecology Evolution, 8: 1212--1220. doi: 10.1111/2041-210X.12760","code":"@Article{,   title = {phangorn: phylogenetic analysis in R},   author = {Klaus Schliep},   journal = {Bioinformatics},   year = {2011},   volume = {27},   number = {4},   pages = {592--593},   doi = {10.1093/bioinformatics/btq706}, } @Article{,   author = {Klaus Schliep and Alastair J. Potts and David A. Morrison and Guido W. Grimm},   title = {Intertwining phylogenetic trees and networks},   journal = {Methods in Ecology and Evolution},   volume = {8},   number = {10},   pages = {1212--1220},   keywords = {exploratory data analysis, networks, phangorn, R, trees},   year = {2017}, }"},{"path":"https://klausvigo.github.io/phangorn/index.html","id":"phangorn-","dir":"","previous_headings":"","what":"Phylogenetic Reconstruction and Analysis","title":"Phylogenetic Reconstruction and Analysis","text":"phangorn package phylogenetic reconstruction analysis R language. phangorn offers possibility reconstructing phylogenies distance based methods, maximum parsimony maximum likelihood (ML) performing Hadamard conjugation. Extending general ML framework, package provides possibility estimating mixture partition models. Furthermore, phangorn offers several functions exploring comparing trees, phylogenetic models splits, simulating character data performing congruence analyses. get introduction phylogenetic inference want look :","code":"vignette(\"Trees\", package=\"phangorn\")"},{"path":"https://klausvigo.github.io/phangorn/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Phylogenetic Reconstruction and Analysis","text":"can install latest release phangorn package CRAN, development version github r-universe. install development version may need install Biostrings package bioconductor first: use functionality might install might need install rgl ggseqlogo package. development version usually depends latest ape development version information download can found .","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\") BiocManager::install(\"Biostrings\") install.packages(\"rgl\") install.packages(\"ggseqlogo\")"},{"path":"https://klausvigo.github.io/phangorn/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Phylogenetic Reconstruction and Analysis","text":"use phangorn please cite: Schliep K.P. 2011. phangorn: phylogenetic analysis R. Bioinformatics, 27(4) 592-593","code":""},{"path":"https://klausvigo.github.io/phangorn/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Phylogenetic Reconstruction and Analysis","text":"phangorn licensed GPLv2.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":null,"dir":"Reference","previous_headings":"","what":"tree utility function — Ancestors","title":"tree utility function — Ancestors","text":"Functions describing relationships among phylogenetic nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"tree utility function — Ancestors","text":"","code":"Ancestors(x, node, type = c(\"all\", \"parent\"))  allDescendants(x)  Children(x, node)  Descendants(x, node, type = c(\"tips\", \"children\", \"all\"))  Siblings(x, node, include.self = FALSE)  mrca.phylo(x, node = NULL, full = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"tree utility function — Ancestors","text":"x tree (phylo object). node integer character vector (scalar) corresponding node ID type specify whether return just direct children / parents include.self whether include self list siblings full logical indicating whether return MRCAs among tips nodes (TRUE); default return MRCAs among tips.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"tree utility function — Ancestors","text":"vector list containing indices nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"tree utility function — Ancestors","text":"functions inspired treewalk phylobase package, work S3 phylo objects.  nodes indices given edge matrix phylo object. taxon labels indices can easily derived matching tip.label argument phylo object, see example .  functions allow node either scalar vector.  mrca faster version mrca ape, phangorn dependencies. argument node missing function evaluated nodes.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"tree utility function — Ancestors","text":"allDescendants(): list descendant nodes node","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/Ancestors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"tree utility function — Ancestors","text":"","code":"tree <- rtree(10) plot(tree, show.tip.label = FALSE) nodelabels() tiplabels()  Ancestors(tree, 1:3, \"all\") #> [[1]] #> [1] 13 12 11 #>  #> [[2]] #> [1] 13 12 11 #>  #> [[3]] #> [1] 14 12 11 #>  Children(tree, 11) #> [1] 12 16 Descendants(tree, 11, \"tips\") #> [[1]] #>  [1]  1  2  3  4  5  6  7  8  9 10 #>  Siblings(tree, 3) #> [1] 15 # Siblings of all nodes Siblings(tree) #> [[1]] #> [1] 2 #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1] 15 #>  #> [[4]] #> [1] 5 #>  #> [[5]] #> [1] 4 #>  #> [[6]] #> [1] 18 #>  #> [[7]] #> [1] 8 #>  #> [[8]] #> [1] 7 #>  #> [[9]] #> [1] 10 #>  #> [[10]] #> [1] 9 #>  #> [[11]] #> NULL #>  #> [[12]] #> [1] 16 #>  #> [[13]] #> [1] 14 #>  #> [[14]] #> [1] 13 #>  #> [[15]] #> [1] 3 #>  #> [[16]] #> [1] 12 #>  #> [[17]] #> [1] 19 #>  #> [[18]] #> [1] 6 #>  #> [[19]] #> [1] 17 #>  mrca.phylo(tree, 1:3) #> [1] 12 mrca.phylo(tree, match(c(\"t1\", \"t2\", \"t3\"), tree$tip)) #> [1] 11 mrca.phylo(tree) #>     t4 t6 t1 t5 t7 t9 t2 t10 t8 t3 #> t4   1 13 12 12 12 11 11  11 11 11 #> t6  13  2 12 12 12 11 11  11 11 11 #> t1  12 12  3 14 14 11 11  11 11 11 #> t5  12 12 14  4 15 11 11  11 11 11 #> t7  12 12 14 15  5 11 11  11 11 11 #> t9  11 11 11 11 11  6 17  17 16 16 #> t2  11 11 11 11 11 17  7  18 16 16 #> t10 11 11 11 11 11 17 18   8 16 16 #> t8  11 11 11 11 11 16 16  16  9 19 #> t3  11 11 11 11 11 16 16  16 19 10 # same as mrca(tree), but faster for large trees"},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":null,"dir":"Reference","previous_headings":"","what":"Consistency Index and Retention Index — CI","title":"Consistency Index and Retention Index — CI","text":"CI RI compute Consistency Index (CI) Retention Index (RI).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Consistency Index and Retention Index — CI","text":"","code":"CI(tree, data, cost = NULL, sitewise = FALSE)  RI(tree, data, cost = NULL, sitewise = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Consistency Index and Retention Index — CI","text":"tree phylogenetic tree, .e. object class phylo. data object class phyDat containing sequences. cost cost matrix transitions two states. sitewise return CI/RI alignment sitewise","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Consistency Index and Retention Index — CI","text":"scalar vector CI/RI vector.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Consistency Index and Retention Index — CI","text":"Consistency Index defined minimum number changes divided number changes required tree (parsimony score). Consistency Index equal one homoplasy. Retention Index defined $$RI = \\frac{MaxChanges - ObsChanges}{MaxChanges - MinChanges}$$","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/CI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Consistency Index and Retention Index — CI","text":"","code":"example(as.phylo.formula) #>  #> as.ph.> data(carnivora) #>  #> as.ph.> frm <- ~SuperFamily/Family/Genus/Species #>  #> as.ph.> tr <- as.phylo(frm, data = carnivora, collapse=FALSE) #>  #> as.ph.> tr$edge.length <- rep(1, nrow(tr$edge)) #>  #> as.ph.> plot(tr, show.node.label=TRUE)  #>  #> as.ph.> Nnode(tr) #> [1] 83 #>  #> as.ph.> ## compare with: #> as.ph.> Nnode(as.phylo(frm, data = carnivora, collapse = FALSE)) #> [1] 83 lab <- tr$tip.label lab[79] <- \"Herpestes fuscus\" tr$tip.label <- abbreviateGenus(lab) X <- matrix(0, 112, 3, dimnames = list(tr$tip.label, c(\"Canis\", \"Panthera\",             \"Canis_Panthera\"))) desc_canis <- Descendants(tr, \"Canis\")[[1]] desc_panthera <- Descendants(tr, \"Panthera\")[[1]] X[desc_canis, c(1,3)] <- 1 X[desc_panthera, c(2,3)] <- 1 col <- rep(\"black\", 112) col[desc_panthera] <- \"red\" col[desc_canis] <- \"blue\" X <- phyDat(X, \"USER\", levels=c(0,1)) plot(tr, \"f\", tip.color=col)  # The first two sites are homoplase free! CI(tr, X, sitewise=TRUE) #> [1] 1.0 1.0 0.5 RI(tr, X, sitewise=TRUE) #> [1] 1.000 1.000 0.875"},{"path":"https://klausvigo.github.io/phangorn/reference/Laurasiatherian.html","id":null,"dir":"Reference","previous_headings":"","what":"Laurasiatherian data (AWCMEE) — Laurasiatherian","title":"Laurasiatherian data (AWCMEE) — Laurasiatherian","text":"Laurasiatherian RNA sequence data","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Laurasiatherian.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Laurasiatherian data (AWCMEE) — Laurasiatherian","text":"Data taken former repository Allan Wilson Centre converted R format klaus.schliep@gmail.com.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/Laurasiatherian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Laurasiatherian data (AWCMEE) — Laurasiatherian","text":"","code":"data(Laurasiatherian) str(Laurasiatherian) #> List of 47 #>  $ Platypus  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Wallaroo  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Possum    : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Bandicoot : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Opposum   : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Armadillo : int [1:1605] 2 1 2 1 3 3 4 2 4 3 ... #>  $ Elephant  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Aardvark  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Tenrec    : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Hedghog   : int [1:1605] 1 4 1 1 3 3 4 2 4 3 ... #>  $ Gymnure   : int [1:1605] 1 1 1 1 3 3 4 2 4 3 ... #>  $ Mole      : int [1:1605] 1 1 1 1 3 3 4 4 4 3 ... #>  $ Shrew     : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Rbat      : int [1:1605] 2 1 4 1 3 3 2 4 4 2 ... #>  $ FlyingFox : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ RyFlyFox  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ FruitBat  : int [1:1605] 4 1 4 1 3 3 4 4 4 3 ... #>  $ LongTBat  : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Horse     : int [1:1605] 2 1 4 1 3 3 2 4 4 3 ... #>  $ Donkey    : int [1:1605] 2 1 4 1 3 3 2 4 4 3 ... #>  $ WhiteRhino: int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ IndianRhin: int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Pig       : int [1:1605] 2 1 2 1 3 3 4 4 4 3 ... #>  $ Alpaca    : int [1:1605] 2 1 2 1 3 3 4 4 4 1 ... #>  $ Cow       : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Sheep     : int [1:1605] 4 1 4 1 3 3 4 4 4 3 ... #>  $ Hippo     : int [1:1605] 4 1 2 1 3 3 4 4 4 3 ... #>  $ FinWhale  : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ BlueWhale : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ SpermWhale: int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Rabbit    : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ Pika      : int [1:1605] 1 1 4 1 3 3 4 4 4 3 ... #>  $ Squirrel  : int [1:1605] 2 1 4 1 3 3 4 4 4 3 ... #>  $ Dormouse  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ GuineaPig : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Mouse     : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Vole      : int [1:1605] 1 1 1 1 3 3 4 4 4 3 ... #>  $ CaneRat   : int [1:1605] 2 1 1 1 4 3 4 4 4 3 ... #>  $ Baboon    : int [1:1605] 1 1 4 1 3 3 2 4 4 3 ... #>  $ Human     : int [1:1605] 1 1 4 1 3 3 4 4 4 3 ... #>  $ Loris     : int [1:1605] 2 1 2 1 3 3 4 4 4 3 ... #>  $ Cebus     : int [1:1605] 2 1 2 1 3 3 4 4 4 3 ... #>  $ Cat       : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ Dog       : int [1:1605] 4 1 1 1 3 3 4 4 4 3 ... #>  $ HarbSeal  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ FurSeal   : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  $ GraySeal  : int [1:1605] 2 1 1 1 3 3 4 4 4 3 ... #>  - attr(*, \"class\")= chr \"phyDat\" #>  - attr(*, \"weight\")= int [1:1605] 1 5 1 444 3 314 1 1 328 1 ... #>  - attr(*, \"nr\")= int 1605 #>  - attr(*, \"nc\")= num 4 #>  - attr(*, \"index\")= int [1:3179] 1 2 3 4 5 6 7 8 9 6 ... #>  - attr(*, \"levels\")= chr [1:4] \"a\" \"c\" \"g\" \"t\" #>  - attr(*, \"allLevels\")= chr [1:18] \"a\" \"c\" \"g\" \"t\" ... #>  - attr(*, \"type\")= chr \"DNA\" #>  - attr(*, \"contrast\")= num [1:18, 1:4] 1 0 0 0 0 1 1 1 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:4] \"a\" \"c\" \"g\" \"t\""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbor-Joining — NJ","title":"Neighbor-Joining — NJ","text":"function performs neighbor-joining tree estimation Saitou Nei (1987). UNJ unweighted version Gascuel (1997).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbor-Joining — NJ","text":"","code":"NJ(x)  UNJ(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbor-Joining — NJ","text":"x distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbor-Joining — NJ","text":"object class \"phylo\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Neighbor-Joining — NJ","text":"NJ wrapper around nj ape.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Neighbor-Joining — NJ","text":"Saitou, N. Nei, M. (1987) neighbor-joining method: new method reconstructing phylogenetic trees. Molecular Biology Evolution, 4, 406–425. Studier, J. Keppler, K. J. (1988) Note Neighbor-Joining Algorithm Saitou Nei. Molecular Biology Evolution, 6, 729–731. Gascuel, O. (1997) Concerning NJ algorithm unweighted version, UNJ. Birkin et. al. Mathematical Hierarchies Biology, 149–170.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neighbor-Joining — NJ","text":"Klaus P. Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/NJ.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neighbor-Joining — NJ","text":"","code":"data(Laurasiatherian) dm <- dist.ml(Laurasiatherian) tree <- NJ(dm) plot(tree)"},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Shimodaira-Hasegawa Test — SH.test","title":"Shimodaira-Hasegawa Test — SH.test","text":"function computes Shimodaira–Hasegawa test set trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shimodaira-Hasegawa Test — SH.test","text":"","code":"SH.test(..., B = 10000, data = NULL, weight = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shimodaira-Hasegawa Test — SH.test","text":"... either series objects class \"pml\" separated commas, list containing objects object class \"pmlPart\" matrix containing site-wise likelihoods columns. B number bootstrap replicates. data object class \"phyDat\". weight matrix site (log-)likelihoods supplied optional vector containing number occurrences site pattern.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shimodaira-Hasegawa Test — SH.test","text":"numeric vector P-value associated tree given ....","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Shimodaira-Hasegawa Test — SH.test","text":"Shimodaira, H. Hasegawa, M. (1999) Multiple comparisons log-likelihoods applications phylogenetic inference. Molecular Biology Evolution, 16, 1114–1116.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Shimodaira-Hasegawa Test — SH.test","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SH.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shimodaira-Hasegawa Test — SH.test","text":"","code":"data(Laurasiatherian) dm <- dist.logDet(Laurasiatherian) tree1 <- NJ(dm) tree2 <- unroot(upgma(dm)) fit1 <- pml(tree1, Laurasiatherian) fit2 <- pml(tree2, Laurasiatherian) fit1 <- optim.pml(fit1) # optimize edge weights #> optimize edge weights:  -54807.68 --> -54290.26  #> optimize edge weights:  -54290.26 --> -54290.26  #> optimize edge weights:  -54290.26 --> -54290.26  fit2 <- optim.pml(fit2) #> optimize edge weights:  -55623.41 --> -54911.33  #> optimize edge weights:  -54911.33 --> -54911.33  #> optimize edge weights:  -54911.33 --> -54911.33  # with pml objects as input SH.test(fit1, fit2, B=1000) #>      Trees      ln L Diff ln L p-value #> [1,]     1 -54290.26    0.0000   0.493 #> [2,]     2 -54911.33  621.0767   0.000 # in real analysis use larger B, e.g. 10000  # with matrix as input X <- matrix(c(fit1$siteLik, fit2$siteLik), ncol=2) SH.test(X, weight=attr(Laurasiatherian, \"weight\"), B=1000) #>      Trees      ln L Diff ln L p-value #> [1,]     1 -54290.26    0.0000   0.489 #> [2,]     2 -54911.33  621.0767   0.000 if (FALSE) { # \\dontrun{ example(pmlPart) SH.test(sp, B=1000) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"function computes Swofford–Olsen–Waddell–Hillis (SOWH) test, parametric bootstrap test. function computational demanding likely slow.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"","code":"SOWH.test(x, n = 100, restricted = list(optNni = FALSE), optNni = TRUE,   trace = 1, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"x object class \"pml\". n number bootstrap replicates. restricted list restricted parameter settings. optNni Logical value indicating whether topology gets optimized (NNI). trace Show output computations. ... arguments passed \"optim.pml\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"object class SOWH. list three elements, one matrix containing bootstrap replicate (log-) likelihood restricted unrestricted estimate two pml objects restricted unrestricted model.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"SOWH.test performs parametric bootstrap test compare two trees. makes extensive use simSeq optim.pml can take quite long.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"Goldman, N., Anderson, J. P., Rodrigo, . G. (2000) Likelihood -based tests topologies phylogenetics. Systematic Biology 49 652-670. Swofford, D.L., Olsen, G.J., Waddell, P.J. Hillis, D.M. (1996) Phylogenetic Inference Hillis, D.M., Moritz, C. Mable, B.K. (Eds.) Molecular Systematics (2nd ed.) 407-514, Sunderland, MA: Sinauer","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/SOWH.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Swofford-Olsen-Waddell-Hillis Test — SOWH.test","text":"","code":"# in real analysis use larger n, e.g. 500 preferably more if (FALSE) { # \\dontrun{ data(Laurasiatherian) dm <- dist.logDet(Laurasiatherian) tree <- NJ(dm) fit <- pml(tree, Laurasiatherian) fit <- optim.pml(fit, TRUE) set.seed(6) tree <- rNNI(fit$tree, 1) fit <- update(fit, tree = tree) (res <- SOWH.test(fit, n=100)) summary(res) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/acctran.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign edge length to tree — acctran","title":"Assign edge length to tree — acctran","text":"parsimony_edgelength acctran assign edge length tree edge length number mutations. parsimony_edgelengths assigns edge lengths using joint reconstruction based sankoff algorithm. Ties broken random trees can multifurating. acctran based fitch algorithm faster. However trees need bifurcating ties split.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/acctran.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign edge length to tree — acctran","text":"","code":"acctran(tree, data)  parsimony_edgelength(tree, data)"},{"path":"https://klausvigo.github.io/phangorn/reference/acctran.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign edge length to tree — acctran","text":"tree tree, .e. object class pml data object class phyDat","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/acctran.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign edge length to tree — acctran","text":"tree edge length.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/acctran.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Assign edge length to tree — acctran","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/acctran.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign edge length to tree — acctran","text":"","code":"data(Laurasiatherian) # lower number of iterations for the example, to run time less than 5 sec. treeRatchet <- pratchet(Laurasiatherian, minit=5, k=5, trace=0) # assign edge length (number of substitutions) treeRatchet <- parsimony_edgelength(treeRatchet, Laurasiatherian) plot(midpoint(treeRatchet)) add.scale.bar(0,0, length=100)"},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":null,"dir":"Reference","previous_headings":"","what":"Add tips to a tree — add.tips","title":"Add tips to a tree — add.tips","text":"function binds tips nodes phylogenetic trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add tips to a tree — add.tips","text":"","code":"add.tips(tree, tips, where, edge.length = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add tips to a tree — add.tips","text":"tree object class \"phylo\". tips character vector containing names tips. integer character vector length tips giving number node tip tree add new tips. edge.length optional numeric vector edge length","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add tips to a tree — add.tips","text":"object class phylo","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Add tips to a tree — add.tips","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add.tips.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add tips to a tree — add.tips","text":"","code":"tree <- rcoal(10) plot(tree) nodelabels() tiplabels()  tree1 <- add.tips(tree, c(\"A\", \"B\", \"C\"), c(1,2,15)) plot(tree1)"},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare splits and add support values to an object — addConfidences","title":"Compare splits and add support values to an object — addConfidences","text":"Add support values splits, phylo networx object.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare splits and add support values to an object — addConfidences","text":"","code":"addConfidences(x, y, ...)  # S3 method for class 'phylo' addConfidences(x, y, rooted = FALSE, ...)  presenceAbsence(x, y)  createLabel(x, y, label_y, type = \"edge\", nomatch = NA)"},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare splits and add support values to an object — addConfidences","text":"x object class splits, phylo networx y object class splits, phylo, multiPhylo networx ... arguments passed methods. rooted logial, FALSE bipartitions considered, TRUE clades. label_y label y matched x. usually length(.splits(x)). type labels returned edges (networx) splits. nomatch default value match x y found.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare splits and add support values to an object — addConfidences","text":"object x added bootstrap / MCMC support values.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compare splits and add support values to an object — addConfidences","text":"Schliep, K., Potts, . J., Morrison, D. . Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecol Evol.8, 1212–1220. doi:10.1111/2041-210X.12760","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compare splits and add support values to an object — addConfidences","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/addConfidences.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare splits and add support values to an object — addConfidences","text":"","code":"data(woodmouse) woodmouse <- phyDat(woodmouse) tmpfile <- normalizePath(system.file(              \"extdata/trees/RAxML_bootstrap.woodmouse\", package=\"phangorn\")) boot_trees <- read.tree(tmpfile)  dm <- dist.ml(woodmouse) tree <- upgma(dm) nnet <- neighborNet(dm)  tree <- addConfidences(tree, boot_trees) nnet <- addConfidences(nnet, boot_trees)  plot(tree, show.node.label=TRUE)  plot(nnet, show.edge.label=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw Confidences Intervals on Phylogenies — add_ci","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"low-level plotting commands draw confidence intervals node tree rectangles coloured backgrounds add boxplots ultrametric tipdated trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"","code":"add_ci(tree, trees, col95 = \"#FF00004D\", col50 = \"#0000FF4D\",   height = 0.7, legend = TRUE, ...)  add_boxplot(tree, trees, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"tree phylogenetic tree confidences added. trees phylogenetic trees, .e. object class multiPhylo col95 colour used 95% intervals; default: transparent red. col50 colour used 50% intervals; default: transparent blue. height height boxes. legend logical value. ... arguments passed functions, legend bxp.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"Nothing. Function called adding plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"trees rooted, either ultrametric tip dated.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"Emmanuel Paradis, Santiago Claramunt, Joseph Brown, Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw Confidences Intervals on Phylogenies — add_ci","text":"","code":"data(\"Laurasiatherian\") dm <- dist.hamming(Laurasiatherian) tree <- upgma(dm) set.seed(123) trees <- bootstrap.phyDat(Laurasiatherian,                           FUN=function(x)upgma(dist.hamming(x)), bs=100) tree <- plotBS(tree, trees, \"phylogram\") add_ci(tree, trees, bty=\"n\")  plot(tree, direction=\"downwards\") add_boxplot(tree, trees, boxwex=.7)"},{"path":"https://klausvigo.github.io/phangorn/reference/add_edge_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign and compute edge lengths from a sample of trees — add_edge_length","title":"Assign and compute edge lengths from a sample of trees — add_edge_length","text":"command can infer average edge lengths assign (bootstrap/MCMC) sample.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_edge_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign and compute edge lengths from a sample of trees — add_edge_length","text":"","code":"add_edge_length(tree, trees, fun = function(x) median(na.omit(x)),   rooted = all(is.rooted(trees)))"},{"path":"https://klausvigo.github.io/phangorn/reference/add_edge_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign and compute edge lengths from a sample of trees — add_edge_length","text":"tree phylogenetic tree splitnetwork edge lengths assigned . trees object class multiPhylo, average edges computed . fun function compute average (default median). rooted rooted logical, FALSE edge lengths function observed splits, TRUE edge lengths estimated height observed clades.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_edge_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign and compute edge lengths from a sample of trees — add_edge_length","text":"tree newly assigned edge length.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/add_edge_length.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Assign and compute edge lengths from a sample of trees — add_edge_length","text":"Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/add_edge_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assign and compute edge lengths from a sample of trees — add_edge_length","text":"","code":"data(\"Laurasiatherian\") set.seed(123) bs <- bootstrap.phyDat(Laurasiatherian,                 FUN=function(x)upgma(dist.ml(x)), bs=100) tree_compat <- allCompat(bs, rooted=TRUE) |>               add_edge_length(bs) plot(tree_compat) add_boxplot(tree_compat, bs, boxwex=.7)"},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute all trees topologies. — allTrees","title":"Compute all trees topologies. — allTrees","text":"allTrees computes bifurcating tree topologies rooted unrooted trees 10 tips. number trees grows fast.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute all trees topologies. — allTrees","text":"","code":"allTrees(n, rooted = FALSE, tip.label = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute all trees topologies. — allTrees","text":"n Number tips (<=10). rooted Rooted unrooted trees (default: rooted). tip.label Tip labels.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute all trees topologies. — allTrees","text":"object class multiPhylo.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute all trees topologies. — allTrees","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/allTrees.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute all trees topologies. — allTrees","text":"","code":"trees <- allTrees(5)  old.par <- par(no.readonly = TRUE) par(mfrow = c(3,5)) for(i in 1:15)plot(trees[[i]])  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Ancestral character reconstruction. — ancestral.pml","title":"Ancestral character reconstruction. — ancestral.pml","text":"Marginal reconstruction ancestral character states.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ancestral character reconstruction. — ancestral.pml","text":"","code":"ancestral.pml(object, type = \"marginal\", return = \"prob\", ...)  anc_pml(object, type = \"marginal\", ...)  ancestral.pars(tree, data, type = c(\"MPR\", \"ACCTRAN\", \"POSTORDER\"),   cost = NULL, return = \"prob\", ...)  anc_pars(tree, data, type = c(\"MPR\", \"ACCTRAN\", \"POSTORDER\"), cost = NULL,   ...)  pace(tree, data, type = c(\"MPR\", \"ACCTRAN\", \"POSTORDER\"), cost = NULL,   return = \"prob\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ancestral character reconstruction. — ancestral.pml","text":"object object class pml type method used assign characters internal nodes, see details. return return phyDat object matrix probabilities. ... arguments passed methods. tree tree, .e. object class pml data object class phyDat cost cost matrix transitions two states.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ancestral character reconstruction. — ancestral.pml","text":"object class ancestral. list containing tree node labels, original alignment phyDat object, data.frame containing probabilities belonging state (internal nodes) likely state.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Ancestral character reconstruction. — ancestral.pml","text":"argument \"type\" defines criterion assign internal nodes. ancestral.pml far \"ml marginal (empirical) \"bayes\" ancestral.pars \"MPR\" \"ACCTRAN\" possible. function return list containing tree node labels, original alignment phyDat object, data.frame containing probabilities belonging state (internal nodes) likely state. parsimony nucleotide data likely state might ambiguous. ML unlikely case. input tree contain unique node labels function ape::MakeNodeLabel used create . parsimony reconstruction one keep mind often unique solution. functions use node labels provided tree (also part pml object) unique. Otherwise function ape::MakeNodeLabel used create . details see vignette(\"Ancestral\").","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Ancestral character reconstruction. — ancestral.pml","text":"Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland. Swofford, D.L., Maddison, W.P. (1987) Reconstructing ancestral character states Wagner parsimony. Math. Biosci. 87: 199–229 Yang, Z. (2006). Computational Molecular evolution. Oxford University Press, Oxford.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Ancestral character reconstruction. — ancestral.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/ancestral.pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ancestral character reconstruction. — ancestral.pml","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  # generate node labels to ensure plotting will work tree <- makeNodeLabel(tree) fit <- pml(tree, Laurasiatherian) anc.ml <- anc_pml(fit) anc.p <- anc_pars(tree, Laurasiatherian) # plot ancestral sequences at the root plotSeqLogo( anc.ml, 48, 1, 20)  plotSeqLogo( anc.p, 48, 1, 20)  # plot the first character plotAnc(anc.ml)  # plot the third character plotAnc(anc.ml, 3)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"Conversion among phylogenetic network objects — as.networx","title":"Conversion among phylogenetic network objects — as.networx","text":".networx convert splits objects networx object. important exists generic plot function plot phylogenetic network split graphs.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conversion among phylogenetic network objects — as.networx","text":"","code":"as.networx(x, ...)  # S3 method for class 'splits' as.networx(x, planar = FALSE, coord = \"none\", ...)  # S3 method for class 'phylo' as.networx(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conversion among phylogenetic network objects — as.networx","text":"x object class \"splits\" \"phylo\" ... arguments passed methods. planar logical whether produce planar graph cyclic splits (may excludes splits). coord add coordinates nodes, allows reproduce plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conversion among phylogenetic network objects — as.networx","text":"object class networx.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conversion among phylogenetic network objects — as.networx","text":"networx object hold information phylogenetic network extends phylo object. Therefore generic function phylo objects also work networx objects.  argument planar = TRUE create planar split graph based cyclic ordering. objects can nicely plotted \"2D\". argument \"coord\" allows create coordinates, options \"none\", \"equal angle\", \"3D\", \"2D\" \"outline\" (Bagci et al. 2021).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Conversion among phylogenetic network objects — as.networx","text":"internal representation likely change.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Conversion among phylogenetic network objects — as.networx","text":"Schliep, K., Potts, . J., Morrison, D. . Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecol Evol. 8, 1212–1220. doi:10.1111/2041-210X.12760 Bagci, C., Bryant, D., Cetinkaya, B. Huson, D.H. (2021), Microbial Phylogenetic Context Using Phylogenetic Outlines. Genome Biology Evolution. Volume 13. Issue 9. evab213","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Conversion among phylogenetic network objects — as.networx","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conversion among phylogenetic network objects — as.networx","text":"","code":"set.seed(1) tree1 <- rtree(20, rooted=FALSE) sp <- as.splits(rNNI(tree1, n=10)) net <- as.networx(sp) plot(net)   spl <- allCircularSplits(5) plot(as.networx(spl))  plot(as.networx(spl, coord=\"outline\"))  if (FALSE) { # \\dontrun{ # also see example in consensusNet example(consensusNet) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Conversion among Sequence Formats — phyDat","title":"Conversion among Sequence Formats — phyDat","text":"functions transform several DNA formats phyDat format. allSitePattern generates alignment possible site patterns.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conversion among Sequence Formats — phyDat","text":"","code":"phyDat(data, type = \"DNA\", levels = NULL, return.index = TRUE, ...)  as.phyDat(x, ...)  # S3 method for class 'factor' as.phyDat(x, ...)  # S3 method for class 'DNAbin' as.phyDat(x, ...)  # S3 method for class 'AAbin' as.phyDat(x, ...)  # S3 method for class 'alignment' as.phyDat(x, type = \"DNA\", ...)  phyDat2alignment(x)  # S3 method for class 'MultipleAlignment' as.phyDat(x, ...)  # S3 method for class 'AAStringSet' as.phyDat(x, ...)  # S3 method for class 'DNAStringSet' as.phyDat(x, ...)  as.StringSet(x, ...)  # S3 method for class 'phyDat' as.StringSet(x, ...)  # S3 method for class 'phyDat' as.MultipleAlignment(x, ...)  # S3 method for class 'phyDat' as.character(x, allLevels = TRUE, ...)  # S3 method for class 'phyDat' as.data.frame(x, ...)  # S3 method for class 'phyDat' as.DNAbin(x, ...)  # S3 method for class 'phyDat' as.AAbin(x, ...)  genlight2phyDat(x, ambiguity = NA)  acgt2ry(obj)  unalign(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conversion among Sequence Formats — phyDat","text":"data object containing sequences. type Type sequences (\"DNA\", \"AA\", \"CODON\" \"USER\"). levels Level attributes. return.index TRUE returns index site patterns. ... arguments passed methods. x object containing sequences. allLevels return original data. ambiguity character ambiguous character contrast provided. obj object class phyDat","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conversion among Sequence Formats — phyDat","text":"functions return object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Conversion among Sequence Formats — phyDat","text":"type \"USER\" vector give levels. example c(\"\", \"c\", \"g\", \"t\", \"-\") create data object can used phylogenetic analysis gaps fifth state.  detailed example specifying \"USER\" defined data formats vignette \"phangorn-specials\". acgt2ry converts phyDat object nucleotides binary ry-coded dataset. unalign converts phyDat object nucleotides amino acids DNAbin AAbin object list form removing gaps. objects can exported using write.FASTA.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Conversion among Sequence Formats — phyDat","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conversion among Sequence Formats — phyDat","text":"","code":"data(Laurasiatherian) class(Laurasiatherian) #> [1] \"phyDat\" Laurasiatherian #> 47 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  # transform as characters LauraChar <- as.character(Laurasiatherian) # and back Laura <- phyDat(LauraChar) all.equal(Laurasiatherian, Laura) #> [1] TRUE LauraDNAbin <- as.DNAbin(Laurasiatherian) all.equal(Laurasiatherian, as.phyDat(LauraDNAbin)) #> [1] TRUE"},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Splits representation of graphs and trees. — allSplits","title":"Splits representation of graphs and trees. — allSplits","text":".splits produces list splits bipartitions.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splits representation of graphs and trees. — allSplits","text":"","code":"allSplits(k, labels = NULL)  allCircularSplits(k, labels = NULL)  as.splits(x, ...)  # S3 method for class 'splits' as.matrix(x, zero.print = 0L, one.print = 1L, ...)  # S3 method for class 'splits' as.Matrix(x, ...)  # S3 method for class 'splits' print(x, maxp = getOption(\"max.print\"), zero.print = \".\",   one.print = \"|\", ...)  # S3 method for class 'splits' c(..., recursive = FALSE)  # S3 method for class 'splits' unique(x, incomparables = FALSE, unrooted = TRUE, ...)  # S3 method for class 'phylo' as.splits(x, ...)  # S3 method for class 'multiPhylo' as.splits(x, ...)  # S3 method for class 'networx' as.splits(x, ...)  # S3 method for class 'splits' as.prop.part(x, ...)  # S3 method for class 'splits' as.bitsplits(x)  # S3 method for class 'bitsplits' as.splits(x, ...)  compatible(obj1, obj2 = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splits representation of graphs and trees. — allSplits","text":"k number taxa. labels names taxa. x object class phylo multiPhylo. ... arguments passed methods. zero.print character printed zeros. one.print character printed ones. maxp integer, default options(max.print), influences many entries large matrices printed . recursive logical. recursive = TRUE, function recursively descends lists (pairlists) combining elements vector. incomparables compatibility far. unrooted todo. obj1, obj2 object class splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splits representation of graphs and trees. — allSplits","text":".splits returns object class splits, mainly list splits attributes. Often splits object contain attributes confidences bootstrap Bayesian support values weight storing edge weights. compatible return lower triangular matrix 1 indicates two splits incompatible.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Splits representation of graphs and trees. — allSplits","text":"internal representation likely change.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Splits representation of graphs and trees. — allSplits","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/as.splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splits representation of graphs and trees. — allSplits","text":"","code":"(sp <- as.splits(rtree(5))) #>       t5 t3 t2 t1 t4 #>  [1,]  |  .  .  .  . #>  [2,]  .  |  .  .  . #>  [3,]  .  .  |  .  . #>  [4,]  .  .  .  |  . #>  [5,]  .  .  .  .  | #>  [6,]  |  |  |  |  | #>  [7,]  |  |  |  |  . #>  [8,]  .  |  |  |  . #>  [9,]  .  .  |  |  . write.nexus.splits(sp) #> #NEXUS #>  #> [Splits block for Spectronet or SplitsTree] #> [generated by phangorn 2.12.1.3 ] #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=5; #> \tTAXLABELS t5 t3 t2 t1 t4 ; #> END; #>  #> BEGIN SPLITS; #> \tDIMENSIONS ntax=5 nsplits=8; #> \tFORMAT labels=left weights=yes confidences=no intervals=no; #> \tMATRIX #> \t\t1\t0.731792511884123 \t1, #> \t\t2\t0.431473690550774 \t1 3 4 5, #> \t\t3\t0.0130775754805654 \t1 2 4 5, #> \t\t4\t0.715566066093743 \t1 2 3 5, #> \t\t5\t0.103184235747904 \t1 2 3 4, #> \t\t6\t0.976170694921166 \t1 2 3 4, #> \t\t7\t0.356726912083104 \t1 5, #> \t\t8\t0.148211560677737 \t1 2 5, #> \t; #> END; spl <- allCircularSplits(5) plot(as.networx(spl))"},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":null,"dir":"Reference","previous_headings":"","what":"Branch and bound for finding all most parsimonious trees — bab","title":"Branch and bound for finding all most parsimonious trees — bab","text":"bab finds parsimonious trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branch and bound for finding all most parsimonious trees — bab","text":"","code":"bab(data, tree = NULL, trace = 1, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Branch and bound for finding all most parsimonious trees — bab","text":"data object class phyDat. tree phylogenetic tree object class phylo, otherwise pratchet search performed. trace defines much information printed optimization. ... arguments passed methods","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Branch and bound for finding all most parsimonious trees — bab","text":"bab returns parsimonious trees object class multiPhylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Branch and bound for finding all most parsimonious trees — bab","text":"implementation slow depending data may take long time. worst case \\((2n-5)!! = 1 \\times 3 \\times 5 \\times \\ldots \\times (2n-5)\\) possible trees examined, n number species / tips. ten species already 2027025 tip-labelled unrooted trees. uses basic strategies find lower upper bounds similar penny phylip. bab uses basic heuristic approach MinMax Squeeze (Holland et al. 2005) improve lower bound. bab might return multifurcating trees. multifurcations resolved ways.  positive side bab like many implementations restricted binary nucleotide data.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Branch and bound for finding all most parsimonious trees — bab","text":"Hendy, M.D. Penny D. (1982) Branch bound algorithms determine minimal evolutionary trees.  Math. Biosc. 59, 277-290 Holland, B.R., Huber, K.T. Penny, D. Moulton, V. (2005) MinMax Squeeze: Guaranteeing Minimal Tree Population Data, Molecular Biology Evolution, 22, 235–242 White, W.T. Holland, B.R. (2011) Faster exact maximum parsimony search XMP. Bioinformatics, 27(10),1359–1367","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Branch and bound for finding all most parsimonious trees — bab","text":"Klaus Schliep klaus.schliep@gmail.com based work Liam Revell","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branch and bound for finding all most parsimonious trees — bab","text":"","code":"data(yeast) dfactorial(11) #> [1] 10395 # choose only the first two genes gene12 <- yeast[, 1:3158] trees <- bab(gene12) #> Compute starting tree #> lower bound: 2798  #> upper bound: 3487  #> Search Baumraum (tree space) #>    |                                                                               |                                                                      |   0%   |                                                                               |=                                                                     |   1%   |                                                                               |=                                                                     |   2%   |                                                                               |==                                                                    |   3%   |                                                                               |===                                                                   |   4%   |                                                                               |===                                                                   |   5%   |                                                                               |====                                                                  |   6%   |                                                                               |=====                                                                 |   7%   |                                                                               |=====                                                                 |   8%   |                                                                               |======                                                                |   9%   |                                                                               |=======                                                               |  10%   |                                                                               |========                                                              |  11%   |                                                                               |=========                                                             |  12%   |                                                                               |=========                                                             |  13%   |                                                                               |==========                                                            |  14%   |                                                                               |===========                                                           |  15%   |                                                                               |===========                                                           |  16%   |                                                                               |============                                                          |  17%   |                                                                               |=============                                                         |  18%   |                                                                               |=============                                                         |  19%   |                                                                               |==============                                                        |  20%   |                                                                               |===============                                                       |  21%   |                                                                               |===============                                                       |  22%   |                                                                               |================                                                      |  23%   |                                                                               |=================                                                     |  24%   |                                                                               |=================                                                     |  25%   |                                                                               |==================                                                    |  26%   |                                                                               |===================                                                   |  27%   |                                                                               |===================                                                   |  28%   |                                                                               |====================                                                  |  29%   |                                                                               |=====================                                                 |  30%   |                                                                               |======================                                                |  31%   |                                                                               |=======================                                               |  32%   |                                                                               |=======================                                               |  33%   |                                                                               |========================                                              |  34%   |                                                                               |=========================                                             |  35%   |                                                                               |=========================                                             |  36%   |                                                                               |==========================                                            |  37%   |                                                                               |===========================                                           |  38%   |                                                                               |===========================                                           |  39%   |                                                                               |============================                                          |  40%   |                                                                               |=============================                                         |  41%   |                                                                               |=============================                                         |  42%   |                                                                               |==============================                                        |  43%   |                                                                               |===============================                                       |  44%   |                                                                               |===============================                                       |  45%   |                                                                               |================================                                      |  46%   |                                                                               |=================================                                     |  47%   |                                                                               |=================================                                     |  48%   |                                                                               |==================================                                    |  49%   |                                                                               |===================================                                   |  50%   |                                                                               |====================================                                  |  51%   |                                                                               |=====================================                                 |  52%   |                                                                               |=====================================                                 |  53%   |                                                                               |======================================                                |  54%   |                                                                               |======================================================================| 100%"},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":null,"dir":"Reference","previous_headings":"","what":"Summaries of alignments — baseFreq","title":"Summaries of alignments — baseFreq","text":"baseFreq computes frequencies (absolute relative) states sample sequences. glance computes useful information alignment. composition\\_test computes \\(\\chi^2\\)-test testing state composition species differs.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summaries of alignments — baseFreq","text":"","code":"baseFreq(obj, freq = FALSE, all = FALSE, drop.unused.levels = FALSE)  # S3 method for class 'phyDat' glance(x, ...)  composition_test(obj)  # S3 method for class 'phyDat' summary(object, ...)  # S3 method for class 'summary.phyDat' print(x, ..., digits = max(3L, getOption(\"digits\") -   3L))"},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summaries of alignments — baseFreq","text":"freq logical, 'TRUE', frequencies counts returned otherwise proportions logical; = TRUE, counts bases, ambiguous codes, missing data, alignment gaps returned defined contrast. drop.unused.levels logical, drop unused levels ... arguments passed methods. object, obj, x object class phyDat digits minimal number significant digits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summaries of alignments — baseFreq","text":"baseFreq returns named vector glance one row data.frame.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summaries of alignments — baseFreq","text":"Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/baseFreq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summaries of alignments — baseFreq","text":"","code":"data(Laurasiatherian) data(chloroplast) # base frequencies baseFreq(Laurasiatherian) #>         a         c         g         t  #> 0.3321866 0.1990791 0.2040652 0.2646691  baseFreq(Laurasiatherian, all=TRUE) #>         a         c         g         t         u         m         r         w  #> 0.3321866 0.1990791 0.2040652 0.2646691 0.0000000 0.0000000 0.0000000 0.0000000  #>         s         y         k         v         h         d         b         n  #> 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000  #>         ?         -  #> 0.0000000 0.0000000  baseFreq(Laurasiatherian, freq=TRUE) #>     a     c     g     t  #> 49633 29745 30490 39545  baseFreq(chloroplast) #>           A           R           N           D           C           Q  #> 0.086702955 0.051669804 0.036230253 0.040435459 0.006650569 0.039678317  #>           E           G           H           I           L           K  #> 0.046635835 0.090775149 0.029395514 0.073585987 0.101712777 0.040148973  #>           M           F           P           S           T           W  #> 0.024852664 0.051260539 0.048109192 0.054176557 0.051618646 0.021905951  #>           Y           V  #> 0.031636245 0.072818613  glance(Laurasiatherian) #>   nseq nchar unique_site_pattern parsimony_informative_sites const_sites #> 1   47  3179                1605                        1400        1354 #>   duplicated_seq gaps ambiguous type #> 1              0    0         0  DNA glance(chloroplast) #>   nseq nchar unique_site_pattern parsimony_informative_sites const_sites #> 1   19  5144                2775                        2032        2190 #>   duplicated_seq gaps ambiguous type #> 1              0    0         0   AA composition_test(Laurasiatherian)[1:10,] #>            statistic df     p-value #> Platypus   2.1137955  3 0.549126893 #> Wallaroo   2.4109765  3 0.491594621 #> Possum     3.5419454  3 0.315362557 #> Bandicoot  7.9087006  3 0.047936758 #> Opposum   12.5176626  3 0.005804765 #> Armadillo  1.5323619  3 0.674821614 #> Elephant   0.2412612  3 0.970668519 #> Aardvark   1.7363022  3 0.628893376 #> Tenrec     0.9995630  3 0.801357693 #> Hedghog    5.2957058  3 0.151381280"},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap — bootstrap.pml","title":"Bootstrap — bootstrap.pml","text":"bootstrap.pml performs (non-parametric) bootstrap analysis bootstrap.phyDat produces list bootstrapped data sets. plotBS plots phylogenetic tree bootstrap values assigned (internal) edges.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap — bootstrap.pml","text":"","code":"bootstrap.pml(x, bs = 100, trees = TRUE, multicore = FALSE,   mc.cores = NULL, tip.dates = NULL, ...)  bootstrap.phyDat(x, FUN, bs = 100, multicore = FALSE, mc.cores = NULL,   jumble = TRUE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap — bootstrap.pml","text":"x object class pml phyDat. bs number bootstrap samples. trees return trees (default) whole pml objects. multicore logical, whether models estimated parallel. mc.cores number cores use bootstrap. supported UNIX-alike systems. tip.dates named vector sampling times associated tips/sequences. Leave empty estimating tip dated phylogenies. ... parameters used optim.pml plot.phylo. FUN function estimate trees. jumble logical, jumble order sequences.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap — bootstrap.pml","text":"bootstrap.pml returns object class multi.phylo list element object class pml. plotBS returns silently tree, .e. object class phylo bootstrap values node labels. argument BStrees optional supplied tree labels supplied node.label slot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrap — bootstrap.pml","text":"possible bootstrap performed parallel, help multicore package. Unfortunately multicore package work windows GUI interfaces (\"aqua\" mac). However speed nicely command line (\"X11\").","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bootstrap — bootstrap.pml","text":"Felsenstein J. (1985) Confidence limits phylogenies. approach using bootstrap. Evolution 39, 783–791 Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D., De Oliveira, T., & Gascuel, O. (2018). Renewing Felsenstein’s phylogenetic bootstrap era big data. Nature, 556(7702), 452–456. Penny D. Hendy M.D. (1985) Testing methods evolutionary tree construction. Cladistics 1, 266–278 Penny D. Hendy M.D. (1986) Estimating reliability evolutionary trees. Molecular Biology Evolution 3, 403–417","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bootstrap — bootstrap.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/bootstrap.pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap — bootstrap.pml","text":"","code":"if (FALSE) { # \\dontrun{ data(Laurasiatherian) dm <- dist.hamming(Laurasiatherian) tree <- NJ(dm) # NJ set.seed(123) NJtrees <- bootstrap.phyDat(Laurasiatherian,      FUN=function(x)NJ(dist.hamming(x)), bs=100) treeNJ <- plotBS(tree, NJtrees, \"phylogram\")  # Maximum likelihood fit <- pml(tree, Laurasiatherian) fit <- optim.pml(fit, rearrangement=\"NNI\") set.seed(123) bs <- bootstrap.pml(fit, bs=100, optNni=TRUE) treeBS <- plotBS(fit$tree,bs)  # Maximum parsimony treeMP <- pratchet(Laurasiatherian) treeMP <- acctran(treeMP, Laurasiatherian) set.seed(123) BStrees <- bootstrap.phyDat(Laurasiatherian, pratchet, bs = 100) treeMP <- plotBS(treeMP, BStrees, \"phylogram\") add.scale.bar()  # export tree with bootstrap values as node labels # write.tree(treeBS) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/chloroplast.html","id":null,"dir":"Reference","previous_headings":"","what":"Chloroplast alignment — chloroplast","title":"Chloroplast alignment — chloroplast","text":"Amino acid alignment 15 genes 19 different chloroplast.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/chloroplast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chloroplast alignment — chloroplast","text":"","code":"data(chloroplast) chloroplast #> 19 sequences with 5144 character and 2775 different site patterns. #> The states are A R N D C Q E G H I L K M F P S T W Y V"},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility function to plot.phylo — cladePar","title":"Utility function to plot.phylo — cladePar","text":"cladePar can help coloring (choosing edge width/type) clades.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility function to plot.phylo — cladePar","text":"","code":"cladePar(tree, node, edge.color = \"red\", tip.color = edge.color,   edge.width = 1, edge.lty = \"solid\", x = NULL, plot = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility function to plot.phylo — cladePar","text":"tree object class phylo. node node common ancestor clade. edge.color see plot.phylo. tip.color see plot.phylo. edge.width see plot.phylo. edge.lty see plot.phylo. x result previous call cladeInfo. plot logical, TRUE tree plotted. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility function to plot.phylo — cladePar","text":"list containing information edges tips.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Utility function to plot.phylo — cladePar","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cladePar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility function to plot.phylo — cladePar","text":"","code":"tree <- rtree(10) plot(tree) nodelabels()  x <- cladePar(tree, 12) cladePar(tree, 18, \"blue\", \"blue\", x=x, plot=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Species Tree — coalSpeciesTree","title":"Species Tree — coalSpeciesTree","text":"coalSpeciesTree estimates species trees can handle multiple individuals per species.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Species Tree — coalSpeciesTree","text":"","code":"coalSpeciesTree(tree, X = NULL, sTree = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Species Tree — coalSpeciesTree","text":"tree object class multiPhylo X phyDat object define individual belongs species. sTree species tree fixes topology.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Species Tree — coalSpeciesTree","text":"function returns object class phylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Species Tree — coalSpeciesTree","text":"coalSpeciesTree estimates single linkage tree suggested Liu et al. (2010) element wise minima cophenetic matrices gene trees. extends speciesTree ape allows several individuals per gene tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Species Tree — coalSpeciesTree","text":"Liu, L., Yu, L. Pearl, D. K. (2010) Maximum tree: consistent estimator species tree. Journal Mathematical Biology, 60, 95–106.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Species Tree — coalSpeciesTree","text":"Klaus Schliep klaus.schliep@gmail.com Emmanuel Paradies","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/coalSpeciesTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Species Tree — coalSpeciesTree","text":"","code":"## example in Liu et al. (2010) tr1 <- read.tree(text = \"(((B:0.05,C:0.05):0.01,D:0.06):0.04,A:0.1);\") tr2 <- read.tree(text = \"(((A:0.07,C:0.07):0.02,D:0.09):0.03,B:0.12);\") TR <- c(tr1, tr2) sp_tree <- coalSpeciesTree(TR)"},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":null,"dir":"Reference","previous_headings":"","what":"codonTest — codonTest","title":"codonTest — codonTest","text":"Models detecting positive selection","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"codonTest — codonTest","text":"","code":"codonTest(tree, object, model = c(\"M0\", \"M1a\", \"M2a\"),   frequencies = \"F3x4\", opt_freq = FALSE, codonstart = 1,   control = pml.control(maxit = 20), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"codonTest — codonTest","text":"tree phylogenetic tree. object object class phyDat. model vector containing substitution models compare \"\" test available models. frequencies character string vector defining compute codon frequencies opt_freq optimize frequencies (far ignored) codonstart integer giving start translation. 1, 2, 3, larger values accepted effect start translation within sequence. control list parameters controlling fitting process. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"codonTest — codonTest","text":"list element called summary containing data.frame log-likelihood, number estimated parameters, etc. tested models. object called posterior contains posterior probability rate class sites estimates defined models.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"codonTest — codonTest","text":"codonTest allows test positive selection similar programs like PAML (Yang ) HyPhy (Kosakovsky Pond et al. 2005). several options deriving codon frequencies. Frequencies can \"equal\" (1/61), derived nucleotide frequencies \"F1x4\" \"F3x4\" \"empirical\" codon frequencies. frequencies taken using empirical frequencies estimated via maximum likelihood. far M0 model (Goldman Yang 2002), M1a M2a implemented. M0 model always computed optional. convergence may slow sometimes fails.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"codonTest — codonTest","text":"Ziheng Yang (2014). Molecular Evolution: Statistical Approach. Oxford University Press, Oxford Sergei L. Kosakovsky Pond, Simon D. W. Frost, Spencer V. Muse (2005) HyPhy: hypothesis testing using phylogenies, Bioinformatics, 21(5): 676–679, doi:10.1093/bioinformatics/bti079 Nielsen, R., Z. Yang. (1998) Likelihood models detecting positively selected amino acid sites applications HIV-1 envelope gene. Genetics, 148: 929–936","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"codonTest — codonTest","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/codonTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"codonTest — codonTest","text":"","code":"if (FALSE) { # \\dontrun{ # load woodmouse data from ape data(woodmouse) dat_codon <- dna2codon(as.phyDat(woodmouse), code=2) tree <- NJ(dist.ml(dat_codon)) # optimize the model the old way fit <- pml(tree, dat_codon, bf=\"F3x4\") M0 <- optim.pml(fit, model=\"codon1\") # Now using the codonTest function fit_codon <- codonTest(tree, dat_codon) fit_codon plot(fit_codon, \"M1a\") } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"Computes consensusNetwork, .e. object class networx list trees, .e. class class multiPhylo. Computes networx object collection splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"","code":"consensusNet(obj, prob = 0.3, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"obj object class multiPhylo. prob proportion split present trees represented network. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"consensusNet returns object class networx.  just intermediate plot phylogenetic networks igraph.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"Holland B.R., Huber K.T., Moulton V., Lockhart P.J. (2004) Using consensus networks visualize contradictory evidence species phylogeny. Molecular Biology Evolution, 21, 1459–61","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/consensusNet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes a consensusNetwork from a list of trees Computes a networx object from a collection of splits. — consensusNet","text":"","code":"data(Laurasiatherian) set.seed(1) bs <- bootstrap.phyDat(Laurasiatherian, FUN = function(x)nj(dist.hamming(x)),     bs=50) cnet <- consensusNet(bs, .3) plot(cnet, angle=-60, direction=\"axial\")  if (FALSE) { # \\dontrun{ library(rgl) open3d() plot(cnet, type = \"3D\", show.tip.label=FALSE, show.nodes=TRUE) plot(cnet, type = \"equal angle\", show.edge.label=TRUE)  tmpfile <- normalizePath(system.file(               \"extdata/trees/RAxML_bootstrap.woodmouse\", package=\"phangorn\")) trees <- read.tree(tmpfile) cnet_woodmouse <- consensusNet(trees, .3) plot(cnet_woodmouse, type = \"equal angle\", show.edge.label=TRUE) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"cophenetic.networx computes pairwise distances pairs tips phylogenetic network using branch lengths.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"","code":"# S3 method for class 'networx' cophenetic(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"x object class networx.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"object class dist, names set according tip labels (given element tip.label argument x).","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/cophenetic.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Distances from a Phylogenetic Network — cophenetic.networx","text":"","code":"example(neighborNet) #>  #> nghbrN> data(yeast) #>  #> nghbrN> dm <- dist.ml(yeast) #>  #> nghbrN> nnet <- neighborNet(dm) #>  #> nghbrN> plot(nnet)  #>  #> nghbrN> plot(nnet, type=\"outline\")  cophenetic(nnet) #>            Sbay       Skud       Smik       Spar       Scer       Scas #> Skud 0.15679569                                                        #> Smik 0.17138720 0.15382927                                             #> Spar 0.16838347 0.15082553 0.12360062                                  #> Scer 0.17717456 0.16108716 0.13763679 0.08678458                       #> Scas 0.34958331 0.35210510 0.34479766 0.34179392 0.34350386            #> Calb 0.54518366 0.54770545 0.54039800 0.53739427 0.53910421 0.52768392 #> Sklu 0.38096004 0.38397653 0.38238343 0.37937970 0.38167995 0.39014046 #>            Calb #> Skud            #> Smik            #> Spar            #> Scer            #> Scas            #> Calb            #> Sklu 0.54213286"},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the \\(\\delta\\) score — delta.score","title":"Computes the \\(\\delta\\) score — delta.score","text":"Computes treelikeness","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the \\(\\delta\\) score — delta.score","text":"","code":"delta.score(x, arg = \"mean\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the \\(\\delta\\) score — delta.score","text":"x object class phyDat arg Specifies return value, one \"\", \"mean\" \"sd\" ... arguments passed dist.hamming","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the \\(\\delta\\) score — delta.score","text":"vector containing \\(\\delta\\) scores.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes the \\(\\delta\\) score — delta.score","text":"BR Holland, KT Huber, Dress, V Moulton (2002) \\(\\delta\\) Plots: tool analyzing phylogenetic distance data Russell D. Gray, David Bryant, Simon J. Greenhill (2010) shape fabric human history Molecular Biology Evolution, 19(12) 2051–2059 Russell D. Gray, David Bryant, Simon J. Greenhill (2010) shape fabric human history Phil. Trans. R. Soc. B, 365 3923–3933; DOI: 10.1098/rstb.2010.0162","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computes the \\(\\delta\\) score — delta.score","text":"Alastair Potts Klaus Schliep","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/delta.score.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes the \\(\\delta\\) score — delta.score","text":"","code":"data(yeast) hist(delta.score(yeast, \"all\"))"},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a densiTree. — densiTree","title":"Plots a densiTree. — densiTree","text":"R function plot trees similar produced DensiTree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a densiTree. — densiTree","text":"","code":"densiTree(x, type = \"phylogram\", ..., alpha = 1/length(x),   consensus = NULL, direction = \"rightwards\", optim = FALSE,   scaleX = FALSE, col = 1, width = 1, lty = 1, cex = 0.8, font = 3,   tip.color = 1, adj = 0, srt = 0, underscore = FALSE,   label.offset = 0, scale.bar = TRUE, jitter = list(amount = 0, random =   TRUE), tip.dates = NULL, xlim = NULL, ylim = NULL,   show.consensus = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a densiTree. — densiTree","text":"x object class multiPhylo. type character string specifying type phylogeny, far \"cladogram\" (default) \"phylogram\" supported. ... arguments passed plot. alpha parameter semi-transparent colors. consensus tree character vector used define order tip labels. direction character string specifying direction tree. Four values possible: \"rightwards\" (default), \"leftwards\", \"upwards\", \"downwards\". optim yet used. scaleX scale trees identical heights. col scalar vector giving colours used draw edges plotted phylogeny. taken order input trees x. fewer colours given number trees, colours recycled. width edge width. lty line type. cex numeric value giving factor scaling tip labels. font integer specifying type font labels: 1 (plain text), 2 (bold), 3 (italic, default), 4 (bold italic). tip.color color tip labels. adj numeric specifying justification text strings labels: 0 (left-justification), 0.5 (centering), 1 (right-justification). srt numeric giving much labels rotated degrees. underscore logical specifying whether underscores tip labels written spaces (default) left (TRUE). label.offset numeric giving space nodes tips phylogeny corresponding labels. scale.bar logical specifying whether add scale.bar plot. jitter allows shift trees. list two arguments: amount jitter random equally spaced (see details ) tip.dates named vector sampling times associated tips. xlim x limits plot. ylim y limits plot. show.consensus superimpose consensus tree?","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plots a densiTree. — densiTree","text":"densiTree returns silently x.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plots a densiTree. — densiTree","text":"consensus tree provided densiTree computes consensus tree, input trees different labels mrp.supertree backbone. avoid many unnecessary crossings edges. Trees rooted, wise output may visually pleasing. jitter shifts trees bit exactly top . amount == 0, ignored. random=TRUE result permutation runif(n, -amount, amount), otherwise seq(-amount, amount, length=n), n <- length(x).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plots a densiTree. — densiTree","text":"densiTree inspired great DensiTree program Remco Bouckaert. Remco R. Bouckaert (2010) DensiTree: making sense sets phylogenetic trees Bioinformatics, 26 (10), 1372-1373.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plots a densiTree. — densiTree","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/densiTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plots a densiTree. — densiTree","text":"","code":"data(Laurasiatherian) set.seed(1) bs <- bootstrap.phyDat(Laurasiatherian, FUN =    function(x) upgma(dist.hamming(x)), bs=25) # cladogram nice to show topological differences densiTree(bs, type=\"cladogram\", col=\"blue\")  densiTree(bs, type=\"phylogram\", col=\"green\", direction=\"downwards\", width=2)  # show consensus tree tree_compat <- allCompat(bs, rooted=TRUE) |> add_edge_length(bs) densiTree(bs, type=\"phylogram\", col=\"green\", consensus = tree_compat,   show.consensus=TRUE)   # plot five trees slightly shifted, no transparent color densiTree(bs[1:5], type=\"phylogram\", col=1:5, width=2, jitter=     list(amount=.3, random=FALSE), alpha=1)  if (FALSE) { # \\dontrun{ # phylograms are nice to show different age estimates require(PhyloOrchard) data(BinindaEmondsEtAl2007) BinindaEmondsEtAl2007 <- .compressTipLabel(BinindaEmondsEtAl2007) densiTree(BinindaEmondsEtAl2007, type=\"phylogram\", col=\"red\") } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a design matrix or non-negative LS — designTree","title":"Compute a design matrix or non-negative LS — designTree","text":"nnls.tree estimates branch length using non-negative least squares given tree distance matrix.  designTree designSplits compute design matrices estimation edge length (phylogenetic) trees using linear models.  larger trees sparse design matrix can save lot memory. designTree also computes contrast matrix method \"rooted\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a design matrix or non-negative LS — designTree","text":"","code":"designTree(tree, method = \"unrooted\", sparse = FALSE, tip.dates = NULL,   calibration = NULL, ...)  nnls.tree(dm, tree, method = c(\"unrooted\", \"ultrametric\", \"tipdated\"),   rooted = NULL, trace = 1, weight = NULL, balanced = FALSE,   tip.dates = NULL, calibration = NULL)  nnls.phylo(x, dm, method = \"unrooted\", trace = 0, ...)  nnls.splits(x, dm, trace = 0, eps = 1e-08)  nnls.networx(x, dm, eps = 1e-08)  designSplits(x, splits = \"all\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a design matrix or non-negative LS — designTree","text":"tree object class phylo method compute \"unrooted\", \"ultrametric\" \"tipdated\" tree. sparse return sparse design matrix. tip.dates named vector sampling times associated tips tree. calibration named vector calibration times associated nodes tree. ... arguments, passed methods. dm distance matrix. rooted compute \"ultrametric\" \"unrooted\" tree (better use method). trace defines much information printed optimization. weight vector weights used fitting process. Weighted least squares used weights w, .e., sum(w * e^2) minimized. balanced use weights balanced fastME x number taxa. eps minimum edge length (default s 1e-8). splits one \"\", \"star\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a design matrix or non-negative LS — designTree","text":"nnls.tree return tree, .e. object class phylo.  designTree designSplits matrix, possibly sparse.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute a design matrix or non-negative LS — designTree","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/designTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a design matrix or non-negative LS — designTree","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  dm <-  as.matrix(dm) y <- dm[lower.tri(dm)] X <- designTree(tree) lm(y~X-1) #>  #> Call: #> lm(formula = y ~ X - 1) #>  #> Coefficients: #>   X89<->36    X89<->37    X77<->35    X77<->38    X73<->33    X73<->34   #>  0.0499157   0.0491439   0.0724626   0.0755455   0.0712616   0.0725432   #>   X65<->73    X65<->77    X51<->65    X51<->89    X75<->10    X75<->11   #>  0.0034694   0.0099328   0.0029426   0.0432799   0.0885305   0.0820387   #>   X62<->12    X62<->13    X86<->15    X86<->16    X67<->14    X67<->17   #>  0.0461128   0.0479378   0.0134025   0.0151296   0.0467324   0.0580930   #>   X63<->67    X63<->86    X59<->63    X59<->18    X88<->45    X88<->47   #>  0.0035646   0.0360953   0.0032091   0.0775894   0.0034977   0.0063178   #>   X80<->88    X80<->46    X74<->80    X74<->44    X72<->74    X72<->43   #>  0.0231875   0.0381300   0.0154870   0.0421651   0.0015801   0.0392256   #>   X85<->19    X85<->20    X79<->21    X79<->22    X71<->79    X71<->85   #>  0.0088520   0.0092959   0.0229321   0.0224528   0.0145614   0.0299323   #>   X81<->25    X81<->26    X87<->28    X87<->29    X82<->87    X82<->30   #>  0.0274720   0.0286839   0.0148471   0.0117270   0.0181692   0.0364881   #>   X70<->82    X70<->27    X68<->70    X68<->24    X66<->68    X66<->81   #>  0.0219311   0.0563100   0.0033377   0.0569549   0.0008004   0.0221615   #>   X61<->66    X61<->23    X60<->61    X60<->71    X58<->60    X58<->72   #>  0.0021831   0.0502453   0.0042762   0.0102058   0.0020978   0.0117101   #>   X57<->58    X57<->59    X56<->57    X56<->62    X53<->56    X53<->75   #>  0.0013537   0.0043899   0.0011632   0.0063020   0.0070446   0.0117666   #>   X84<->39    X84<->40    X78<->84    X78<->42    X52<->78    X52<->41   #>  0.0696111   0.0583581   0.0144780   0.0701359   0.0225117   0.0792075   #>   X50<->52    X50<->53    X49<->50    X49<->51     X92<->2     X92<->3   #>  0.0008563   0.0018880   0.0036910   0.0033483   0.0324915   0.0274029   #>   X91<->92     X91<->4    X90<->91     X90<->5    X83<->90     X83<->1   #>  0.0090135   0.0362511   0.0024394   0.0505988   0.0425011   0.1170301   #>   X69<->83     X69<->9     X64<->7     X64<->8    X55<->64     X55<->6   #>  0.0289009   0.0967237   0.1091965   0.0693124   0.0029756   0.0874519   #>   X54<->55    X54<->69    X76<->31    X76<->32    X48<->76    X48<->54   #>  0.0027613   0.0065884   0.0534621   0.0681912   0.0151764   0.0010911   #>   X48<->49   #> -0.0018629   #>  # avoids negative edge weights tree2 <- nnls.tree(dm, tree)"},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic Operators — ldfactorial","title":"Arithmetic Operators — ldfactorial","text":"double factorial function","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic Operators — ldfactorial","text":"","code":"ldfactorial(x)  dfactorial(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic Operators — ldfactorial","text":"x numeric scalar vector","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic Operators — ldfactorial","text":"dfactorial(x) returns double factorial, \\(x\\!\\! = 1 * 3 * 5 * \\ldots * x \\) ldfactorial(x) natural logarithm .","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic Operators — ldfactorial","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dfactorial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic Operators — ldfactorial","text":"","code":"dfactorial(1:10) #>  [1]    1.000000    1.595769    3.000000    6.383076   15.000000   38.298459 #>  [7]  105.000000  306.387671  945.000000 3063.876713"},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":null,"dir":"Reference","previous_headings":"","what":"Discrete Gamma and Beta distribution — discrete.gamma","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"discrete.gamma internally used likelihood computations pml optim.pml. useful understand works simulation studies cases .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"","code":"discrete.gamma(alpha, k)  discrete.beta(shape1, shape2, k)  plot_gamma_plus_inv(shape = 1, inv = 0, k = 4, discrete = TRUE,   cdf = TRUE, append = FALSE, xlab = \"x\", ylab = ifelse(cdf, \"F(x)\",   \"f(x)\"), xlim = NULL, verticals = FALSE, edge.length = NULL,   site.rate = \"gamma\", ...)  plotRates(obj, cdf.color = \"blue\", main = \"cdf\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"alpha Shape parameter gamma distribution. k Number intervals discrete gamma distribution. shape1, shape2 non-negative parameters Beta distribution. shape Shape parameter gamma distribution. inv Proportion invariable sites. discrete logical whether plot discrete (default) continuous pdf cdf. cdf logical whether plot cumulative distribution function density / probability function. append logical; TRUE add existing plot. xlab label x axis, defaults description x. ylab label y axis, defaults description y. xlim x limits plot. verticals logical; TRUE, draw vertical lines steps. edge.length Total edge length (sum edges tree). site.rate Indicates type gamma distribution use. Options \"gamma\" (Yang 1994) \"gamma_quadrature\" using Laguerre quadrature approach Felsenstein (2001) ... arguments passed methods. obj object class pml cdf.color color cdf. main main title plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"discrete.gamma returns matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"functions exported used different packages far package coalescentMCMC, intended end user. functions call C code far less forgiving import expect pml.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/discrete.gamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Discrete Gamma and Beta distribution — discrete.gamma","text":"","code":"discrete.gamma(1, 4) #> [1] 0.1369538 0.4767519 1.0000000 2.3862944  old.par <- par(no.readonly = TRUE) par(mfrow = c(2,1)) plot_gamma_plus_inv(shape=2, discrete = FALSE, cdf=FALSE) plot_gamma_plus_inv(shape=2, append = TRUE, cdf=FALSE)  plot_gamma_plus_inv(shape=2, discrete = FALSE) plot_gamma_plus_inv(shape=2, append = TRUE)  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Distances from Sequences — dist.hamming","title":"Pairwise Distances from Sequences — dist.hamming","text":"dist.hamming, dist.ml dist.logDet compute pairwise distances object class phyDat. dist.ml uses DNA / AA sequences compute distances different substitution models.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Distances from Sequences — dist.hamming","text":"","code":"dist.hamming(x, ratio = TRUE, exclude = \"none\")  dist.ml(x, model = \"JC69\", exclude = \"none\", bf = NULL, Q = NULL,   k = 1L, shape = 1, ...)  dist.logDet(x)"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Distances from Sequences — dist.hamming","text":"x object class phyDat ratio Compute uncorrected ('p') distance character difference. exclude One \"none\", \"\", \"pairwise\" indicating whether delete sites gaps, missing data (ambiguous states). See details . model One \"JC69\", \"F81\" one 17 amino acid models see details. bf vector base frequencies. Q vector containing lower triangular part rate matrix. k Number intervals discrete gamma distribution. shape Shape parameter gamma distribution. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Distances from Sequences — dist.hamming","text":"object class dist","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise Distances from Sequences — dist.hamming","text":"far 17 amino acid models supported (\"WAG\", \"JTT\", \"LG\", \"Dayhoff\", \"cpREV\", \"mtmam\", \"mtArt\", \"MtZoa\", \"mtREV24\", \"VT\",\"RtREV\", \"HIVw\", \"HIVb\", \"FLU\", \"Blosum62\", \"Dayhoff_DCMut\" \"JTT_DCMut\") additional rate matrices frequencies can supplied. \"F81\" model uses empirical base frequencies, \"JC69\" equal base frequencies. even case data nucleotides. argument exclude decides gaps / ambiguous data / missing data treated. Usually gaps treated ambiguous states, can give gaps state gap_as_state. exclude=\"none\" keeps ambiguous data. behavior dist.ml case achieve using optim.pml compute pairwise distances, might bit odd. exclude=\"\" removes sites ambiguous states gaps coded ambiguous states. can lead situation sites fo alignment left. Safer therefore use exclude=\"pairwise\" removes sites ambiguous pair sequences.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pairwise Distances from Sequences — dist.hamming","text":"Lockhart, P. J., Steel, M. ., Hendy, M. D. Penny, D. (1994) Recovering evolutionary trees realistic model sequence evolution. Molecular Biology Evolution, 11, 605–602. Jukes TH Cantor CR (1969). Evolution Protein Molecules. New York: Academic Press. 21–132. McGuire, G., Prentice, M. J. Wright, F. (1999). Improved error bounds genetic distances DNA sequences. Biometrics, 55, 1064–1070.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Distances from Sequences — dist.hamming","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.hamming.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Distances from Sequences — dist.hamming","text":"","code":"data(Laurasiatherian) dm1 <- dist.hamming(Laurasiatherian) tree1 <- NJ(dm1) dm2 <- dist.logDet(Laurasiatherian) tree2 <- NJ(dm2) treedist(tree1,tree2) #>      symmetric.difference   branch.score.difference           path.difference  #>                4.00000000                0.05705091               30.95157508  #> quadratic.path.difference  #>                0.80097967  # JC model dm3 <- dist.ml(Laurasiatherian) tree3 <- NJ(dm3) treedist(tree1,tree3) #>      symmetric.difference   branch.score.difference           path.difference  #>                 6.0000000                 0.0412520                30.3644529  #> quadratic.path.difference  #>                 0.6106899  # F81 + Gamma dm4 <- dist.ml(Laurasiatherian, model=\"F81\", k=4, shape=.4) tree4 <- NJ(dm4) treedist(tree1,tree4) #>      symmetric.difference   branch.score.difference           path.difference  #>                12.0000000                 0.1356107                40.7676342  #> quadratic.path.difference  #>                 2.0709714  treedist(tree3,tree4) #>      symmetric.difference   branch.score.difference           path.difference  #>                8.00000000                0.09494752               39.52214569  #> quadratic.path.difference  #>                1.46345381"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"function computes matrix pairwise uncorrected polymorphism p-distances. Polymorphism p-distances include intra-individual site polymorphisms (2ISPs; e.g. \"R\") calculating genetic distances.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"","code":"dist.p(x, cost = \"polymorphism\", ignore.indels = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"x matrix containing DNA sequences; must class \"phyDat\" (use .phyDat convert DNAbin objects). cost cost matrix \"polymorphism\" predefined one. ignore.indels logical indicating whether gaps treated fifth state . Warning, gap site treated characters, indel spans number base positions treated multiple character states.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"object class dist.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"polymorphism p-distances (Potts et al. 2014) developed analyse intra-individual variant polymorphism. example, widely used ribosomal internal transcribed spacer () region (e.g. Alvarez Wendel, 2003) consists 100's 1000's units within array across potentially multiple nucleolus organizing regions (Bailey et al., 2003; Goeker Grimm, 2008). can give rise intra-individual site polymorphisms (2ISPs) can detected direct-PCR sequencing cloning . Clone consensus sequences (see Goeker Grimm, 2008) can analysed function.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"Alvarez, ., J. F. Wendel. (2003) Ribosomal sequences plant phylogenetic inference.  Molecular Phylogenetics Evolution, 29, 417–434. Bailey, C. D., T. G. Carr, S. . Harris, C. E. Hughes. (2003) Characterization angiosperm nrDNA polymorphism, paralogy, pseudogenes. Molecular Phylogenetics Evolution 29, 435–455. Goeker, M., G. Grimm. (2008) General functions transform associate data host data, use phylogenetic inference sequences intra-individual variability. BMC Evolutionary Biology, 8:86. Potts, .J., T.. Hedderson, G.W. Grimm. (2014) Constructing phylogenies presence intra-individual site polymorphisms (2ISPs) focus nuclear ribosomal cistron. Systematic Biology, 63, 1–16","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"Klaus Schliep Alastair Potts","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dist.p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Polymorphism P-Distances from DNA Sequences — dist.p","text":"","code":"data(Laurasiatherian) laura <- as.DNAbin(Laurasiatherian)  dm <- dist.p(Laurasiatherian, \"polymorphism\")  ######################################################## # Dealing with indel 2ISPs # These can be coded using an \"x\" in the alignment. Note # that as.character usage in the read.dna() function. ######################################################### cat(\"3 5\",     \"No305     ATRA-\",     \"No304     ATAYX\",     \"No306     ATAGA\",     file = \"exdna.txt\", sep = \"\\n\") (ex.dna <- read.dna(\"exdna.txt\", format = \"sequential\", as.character=TRUE)) #>       [,1] [,2] [,3] [,4] [,5] #> No305 \"a\"  \"t\"  \"r\"  \"a\"  \"-\"  #> No304 \"a\"  \"t\"  \"a\"  \"y\"  \"x\"  #> No306 \"a\"  \"t\"  \"a\"  \"g\"  \"a\"  dat <- phyDat(ex.dna, \"USER\", levels=unique(as.vector(ex.dna))) dist.p(dat) #>       No305 No304 #> No304     4       #> No306     3     4  unlink(\"exdna.txt\")"},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance Hadamard — distanceHadamard","title":"Distance Hadamard — distanceHadamard","text":"Distance Hadamard produces spectra splits distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance Hadamard — distanceHadamard","text":"","code":"distanceHadamard(dm, eps = 0.001)"},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance Hadamard — distanceHadamard","text":"dm distance matrix. eps Threshold value splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance Hadamard — distanceHadamard","text":"distanceHadamard returns matrix. first column contains distance spectra, second one edge-spectra. eps positive object splits greater eps returned.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distance Hadamard — distanceHadamard","text":"Hendy, M. D. Penny, D. (1993). Spectral Analysis Phylogenetic Data. Journal Classification, 10, 5-24.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance Hadamard — distanceHadamard","text":"Klaus Schliep klaus.schliep@gmail.com, Tim White","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/distanceHadamard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance Hadamard — distanceHadamard","text":"","code":"data(yeast) dm <- dist.hamming(yeast) dm <- as.matrix(dm) fit <- distanceHadamard(dm) lento(fit)  plot(as.networx(fit))"},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate nucleic acid sequences into codons — dna2codon","title":"Translate nucleic acid sequences into codons — dna2codon","text":"function transforms dna2codon DNA sequences codon sequences, codon2dna transform way. dna2codon translates nucleotide amino acids using function trans.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate nucleic acid sequences into codons — dna2codon","text":"","code":"dna2codon(x, codonstart = 1, code = 1, ambiguity = \"---\", ...)  codon2dna(x)  dna2aa(x, codonstart = 1, code = 1)"},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate nucleic acid sequences into codons — dna2codon","text":"x object containing sequences. codonstart integer giving start translation. 1, 2, 3, larger values accepted effect start translation within sequence. code ncbi genetic code number translation (see details). default standard genetic code used. ambiguity character ambiguous character contrast provided. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate nucleic acid sequences into codons — dna2codon","text":"functions return object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Translate nucleic acid sequences into codons — dna2codon","text":"following genetic codes described . number preceding corresponds code argument. Alignment gaps ambiguities currently ignored sites containing deleted.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Translate nucleic acid sequences into codons — dna2codon","text":"https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=cgencodes","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Translate nucleic acid sequences into codons — dna2codon","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/dna2codon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate nucleic acid sequences into codons — dna2codon","text":"","code":"data(Laurasiatherian) class(Laurasiatherian) #> [1] \"phyDat\" Laurasiatherian #> 47 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  dna2codon(Laurasiatherian) #> 47 sequences with 1059 character and 914 different site patterns. #> The states are aaa aac aag aat aca acc acg act aga agc agg agt ata atc atg att caa cac cag cat cca ccc ccg cct cga cgc cgg cgt cta ctc ctg ctt gaa gac gag gat gca gcc gcg gct gga ggc ggg ggt gta gtc gtg gtt tac tat tca tcc tcg tct tgc tgg tgt tta ttc ttg ttt"},{"path":"https://klausvigo.github.io/phangorn/reference/gap_as_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Treat gaps as a state — gap_as_state","title":"Treat gaps as a state — gap_as_state","text":"function gap_as_state changes contrast phyDat object treat state. Internally phyDat stored similar factor objects contrast matrix attributes change.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/gap_as_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Treat gaps as a state — gap_as_state","text":"","code":"gap_as_state(obj, gap = \"-\", ambiguous = \"?\")  gap_as_ambiguous(obj, gap = \"-\")  has_gap_state(obj)"},{"path":"https://klausvigo.github.io/phangorn/reference/gap_as_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Treat gaps as a state — gap_as_state","text":"obj object class phyDat. gap character codes gaps (default \"-\"). ambiguous character codes ambiguous state","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/gap_as_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Treat gaps as a state — gap_as_state","text":"functions return object class phyDat.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/gap_as_state.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Treat gaps as a state — gap_as_state","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/gap_as_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Treat gaps as a state — gap_as_state","text":"","code":"data(Laurasiatherian) tmp <- gap_as_state(Laurasiatherian) contr <- attr(tmp, \"contrast\") rownames(contr) <- attr(tmp, \"allLevels\") contr #>   a c g t - #> a 1 0 0 0 0 #> c 0 1 0 0 0 #> g 0 0 1 0 0 #> t 0 0 0 1 0 #> u 0 0 0 1 0 #> m 1 1 0 0 0 #> r 1 0 1 0 0 #> w 1 0 0 1 0 #> s 0 1 1 0 0 #> y 0 1 0 1 0 #> k 0 0 1 1 0 #> v 1 1 1 0 0 #> h 1 1 0 1 0 #> d 1 0 1 1 0 #> b 0 1 1 1 0 #> n 1 1 1 1 0 #> ? 1 1 1 1 1 #> - 0 0 0 0 1"},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":null,"dir":"Reference","previous_headings":"","what":"Clans, slices and clips — getClans","title":"Clans, slices and clips — getClans","text":"Functions clanistics compute clans, slices, clips unrooted trees functions quantify fragmentation trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clans, slices and clips — getClans","text":"","code":"getClans(tree)  getSlices(tree)  getClips(tree, all = TRUE)  getDiversity(tree, x, norm = TRUE, var.names = NULL, labels = \"new\")  # S3 method for class 'clanistics' summary(object, ...)  diversity(tree, X)"},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clans, slices and clips — getClans","text":"tree object class phylo multiPhylo (getDiversity). logical, return just largest clip. x object class phyDat. norm logical, return Equitability Index (default) Shannon Diversity. var.names vector variable names. labels see details. object object summary desired. ... arguments passed methods. X data.frame","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clans, slices and clips — getClans","text":"getClans, getSlices getClips return matrix partitions, matrix ones zeros rows correspond clan, slice clip columns tips. one indicates tip belongs certain partition.  getDiversity returns list tree object, first data.frame equitability index Shannon divergence parsimony scores (p-score) trees variables. data.frame two attributes, first splits object identify taxa tree second splits object containing partitions perfectly fit.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clans, slices and clips — getClans","text":"Every split unrooted tree defines two complementary clans. Thus unrooted binary tree \\(n\\) leaves \\(2n - 3\\) edges, therefore \\(4n - 6\\) clans (including \\(n\\) trivial clans containing one leave). Slices defined pair splits tripartitions, clans. number distinguishable slices binary tree \\(n\\) tips \\(2n^2 - 10n + 12\\). clip different type partition, defining groups leaves related terms evolutionary distances topology.  Namely, clips groups leaves pairwise path-length distances smaller given threshold value (Lapointe et al. 2010). exists different numbers clips different thresholds, largest (trivial) one whole tree.  always clip containing two leaves smallest pairwise distance. Clans, slices clips can used characterize well vector categorial characters (natives/intruders) fit tree. follow definitions Lapointe et al.(2010).  complete clan clan contains leaves given state/color, can also contain leaves another state/color. clan homogeneous contains leaves one state/color. getDiversity computes either  Shannon Diversity: \\(H = -\\sum_{=1}^{k}(N_i/N) log(N_i/N), N=\\sum_{=1}^{k} N_i\\)   Equitability Index: \\(E = H / log(N)\\)  \\(N_i\\) sizes \\(k\\) largest homogeneous clans intruders.  categories data can separated edge tree E-value zero, maximum equitability (E=1) reached intruders separate clans. getDiversity computes Intruder indices whole tree, complete clans complete slices. Additionally parsimony scores (p-scores) reported. p-score indicates leaves contain one color (p-score=0), leaves can separated single split (perfect clan, p-score=1) pair splits (perfect slice, p-score=2). far 2 states supported (native, intruder), however also possible recode several states native intruder state using contrasts, details see section 2 vignette(\"phangorn-specials\"). Furthermore unknown character states coded ambiguous character, can act either native intruder minimizing number clans changes (parsimony analysis) needed describe tree given data. Set attribute labels \"old\" analysis Schliep et al. (2010) \"new\" names intuitive. diversity returns data.frame parsimony score tree levels variables X. X data.frame column factor rownames X correspond tips trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Clans, slices and clips — getClans","text":"Lapointe, F.-J., Lopez, P., Boucher, Y., Koenig, J., Bapteste, E. (2010) Clanistics: multi-level perspective harvesting unrooted gene trees. Trends Microbiology 18: 341-347 Wilkinson, M., McInerney, J.O., Hirt, R.P., Foster, P.G., Embley, T.M. (2007) clades clans: terms phylogenetic relationships unrooted trees. Trends Ecology Evolution 22: 114-115 Schliep, K., Lopez, P., Lapointe F.-J., Bapteste E. (2011) Harvesting Evolutionary Signals Forest Prokaryotic Gene Trees, Molecular Biology Evolution 28(4): 1393-1405","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Clans, slices and clips — getClans","text":"Klaus Schliep klaus.schliep@gmail.com Francois-Joseph Lapointe francois-joseph.lapointe@umontreal.ca","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/getClans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clans, slices and clips — getClans","text":"","code":"set.seed(111) tree <- rtree(10) getClans(tree) #>       t3 t8 t2 t1 t5 t6 t9 t10 t4 t7 #>  [1,]  1  0  0  0  0  0  0   0  0  0 #>  [2,]  0  1  0  0  0  0  0   0  0  0 #>  [3,]  0  0  1  0  0  0  0   0  0  0 #>  [4,]  0  0  0  1  0  0  0   0  0  0 #>  [5,]  0  0  0  0  1  0  0   0  0  0 #>  [6,]  0  0  0  0  0  1  0   0  0  0 #>  [7,]  0  0  0  0  0  0  1   0  0  0 #>  [8,]  0  0  0  0  0  0  0   1  0  0 #>  [9,]  0  0  0  0  0  0  0   0  1  0 #> [10,]  0  0  0  0  0  0  0   0  0  1 #> [11,]  0  1  1  1  1  1  1   1  1  1 #> [12,]  1  0  1  1  1  1  1   1  1  1 #> [13,]  1  1  0  1  1  1  1   1  1  1 #> [14,]  1  1  1  0  1  1  1   1  1  1 #> [15,]  1  1  1  1  0  1  1   1  1  1 #> [16,]  1  1  1  1  1  0  1   1  1  1 #> [17,]  1  1  1  1  1  1  0   1  1  1 #> [18,]  1  1  1  1  1  1  1   0  1  1 #> [19,]  1  1  1  1  1  1  1   1  0  1 #> [20,]  1  1  1  1  1  1  1   1  1  0 #> [21,]  1  1  1  0  0  0  0   0  0  0 #> [22,]  0  1  1  0  0  0  0   0  0  0 #> [23,]  0  0  0  0  1  1  1   1  1  1 #> [24,]  0  0  0  0  0  1  1   1  1  1 #> [25,]  0  0  0  0  0  1  1   1  0  0 #> [26,]  0  0  0  0  0  0  1   1  0  0 #> [27,]  0  0  0  0  0  0  0   0  1  1 #> [28,]  0  0  0  1  1  1  1   1  1  1 #> [29,]  1  0  0  1  1  1  1   1  1  1 #> [30,]  1  1  1  1  0  0  0   0  0  0 #> [31,]  1  1  1  1  1  0  0   0  0  0 #> [32,]  1  1  1  1  1  0  0   0  1  1 #> [33,]  1  1  1  1  1  1  0   0  1  1 #> [34,]  1  1  1  1  1  1  1   1  0  0 getClips(tree, all=TRUE) #>      t3 t8 t2 t1 t5 t6 t9 t10 t4 t7 #> [1,]  1  0  1  0  0  0  0   0  0  0 #> [2,]  0  0  0  0  0  0  1   1  0  0 #> [3,]  0  0  0  0  0  0  0   0  1  1 getSlices(tree) #>        t3 t8 t2 t1 t5 t6 t9 t10 t4 t7 #>   [1,]  0  0  1  1  1  1  1   1  1  1 #>   [2,]  0  1  0  1  1  1  1   1  1  1 #>   [3,]  0  1  1  0  1  1  1   1  1  1 #>   [4,]  0  1  1  1  0  1  1   1  1  1 #>   [5,]  0  1  1  1  1  0  1   1  1  1 #>   [6,]  0  1  1  1  1  1  0   1  1  1 #>   [7,]  0  1  1  1  1  1  1   0  1  1 #>   [8,]  0  1  1  1  1  1  1   1  0  1 #>   [9,]  0  1  1  1  1  1  1   1  1  0 #>  [10,]  0  1  1  1  0  0  0   0  0  0 #>  [11,]  0  1  1  1  1  0  0   0  0  0 #>  [12,]  0  1  1  1  1  0  0   0  1  1 #>  [13,]  0  1  1  1  1  1  0   0  1  1 #>  [14,]  0  1  1  1  1  1  1   1  0  0 #>  [15,]  1  0  1  0  1  1  1   1  1  1 #>  [16,]  1  0  1  1  0  1  1   1  1  1 #>  [17,]  1  0  1  1  1  0  1   1  1  1 #>  [18,]  1  0  1  1  1  1  0   1  1  1 #>  [19,]  1  0  1  1  1  1  1   0  1  1 #>  [20,]  1  0  1  1  1  1  1   1  0  1 #>  [21,]  1  0  1  1  1  1  1   1  1  0 #>  [22,]  1  0  1  0  0  0  0   0  0  0 #>  [23,]  1  0  1  1  0  0  0   0  0  0 #>  [24,]  1  0  1  1  1  0  0   0  0  0 #>  [25,]  1  0  1  1  1  0  0   0  1  1 #>  [26,]  1  0  1  1  1  1  0   0  1  1 #>  [27,]  1  0  1  1  1  1  1   1  0  0 #>  [28,]  1  1  0  0  1  1  1   1  1  1 #>  [29,]  1  1  0  1  0  1  1   1  1  1 #>  [30,]  1  1  0  1  1  0  1   1  1  1 #>  [31,]  1  1  0  1  1  1  0   1  1  1 #>  [32,]  1  1  0  1  1  1  1   0  1  1 #>  [33,]  1  1  0  1  1  1  1   1  0  1 #>  [34,]  1  1  0  1  1  1  1   1  1  0 #>  [35,]  1  1  0  0  0  0  0   0  0  0 #>  [36,]  1  1  0  1  0  0  0   0  0  0 #>  [37,]  1  1  0  1  1  0  0   0  0  0 #>  [38,]  1  1  0  1  1  0  0   0  1  1 #>  [39,]  1  1  0  1  1  1  0   0  1  1 #>  [40,]  1  1  0  1  1  1  1   1  0  0 #>  [41,]  1  1  1  0  0  1  1   1  1  1 #>  [42,]  1  1  1  0  1  0  1   1  1  1 #>  [43,]  1  1  1  0  1  1  0   1  1  1 #>  [44,]  1  1  1  0  1  1  1   0  1  1 #>  [45,]  1  1  1  0  1  1  1   1  0  1 #>  [46,]  1  1  1  0  1  1  1   1  1  0 #>  [47,]  1  0  0  0  1  1  1   1  1  1 #>  [48,]  1  1  1  0  1  0  0   0  0  0 #>  [49,]  1  1  1  0  1  0  0   0  1  1 #>  [50,]  1  1  1  0  1  1  0   0  1  1 #>  [51,]  1  1  1  0  1  1  1   1  0  0 #>  [52,]  1  1  1  1  0  0  1   1  1  1 #>  [53,]  1  1  1  1  0  1  0   1  1  1 #>  [54,]  1  1  1  1  0  1  1   0  1  1 #>  [55,]  1  1  1  1  0  1  1   1  0  1 #>  [56,]  1  1  1  1  0  1  1   1  1  0 #>  [57,]  0  0  0  1  0  1  1   1  1  1 #>  [58,]  1  0  0  1  0  1  1   1  1  1 #>  [59,]  1  1  1  1  0  0  0   0  1  1 #>  [60,]  1  1  1  1  0  1  0   0  1  1 #>  [61,]  1  1  1  1  0  1  1   1  0  0 #>  [62,]  1  1  1  1  1  0  0   1  1  1 #>  [63,]  1  1  1  1  1  0  1   0  1  1 #>  [64,]  1  1  1  1  1  0  1   1  0  1 #>  [65,]  1  1  1  1  1  0  1   1  1  0 #>  [66,]  0  0  0  0  1  0  1   1  1  1 #>  [67,]  0  0  0  0  0  0  1   1  1  1 #>  [68,]  0  0  0  1  1  0  1   1  1  1 #>  [69,]  1  0  0  1  1  0  1   1  1  1 #>  [70,]  1  1  1  1  1  0  1   1  0  0 #>  [71,]  1  1  1  1  1  1  0   1  0  1 #>  [72,]  1  1  1  1  1  1  0   1  1  0 #>  [73,]  0  0  0  0  1  1  0   1  1  1 #>  [74,]  0  0  0  0  0  1  0   1  1  1 #>  [75,]  0  0  0  0  0  1  0   1  0  0 #>  [76,]  0  0  0  1  1  1  0   1  1  1 #>  [77,]  1  0  0  1  1  1  0   1  1  1 #>  [78,]  1  1  1  1  1  1  0   1  0  0 #>  [79,]  1  1  1  1  1  1  1   0  0  1 #>  [80,]  1  1  1  1  1  1  1   0  1  0 #>  [81,]  0  0  0  0  1  1  1   0  1  1 #>  [82,]  0  0  0  0  0  1  1   0  1  1 #>  [83,]  0  0  0  0  0  1  1   0  0  0 #>  [84,]  0  0  0  1  1  1  1   0  1  1 #>  [85,]  1  0  0  1  1  1  1   0  1  1 #>  [86,]  1  1  1  1  1  1  1   0  0  0 #>  [87,]  0  0  0  0  1  1  1   1  0  1 #>  [88,]  0  0  0  0  0  1  1   1  0  1 #>  [89,]  0  0  0  1  1  1  1   1  0  1 #>  [90,]  1  0  0  1  1  1  1   1  0  1 #>  [91,]  1  1  1  1  1  0  0   0  0  1 #>  [92,]  1  1  1  1  1  1  0   0  0  1 #>  [93,]  0  0  0  0  1  1  1   1  1  0 #>  [94,]  0  0  0  0  0  1  1   1  1  0 #>  [95,]  0  0  0  1  1  1  1   1  1  0 #>  [96,]  1  0  0  1  1  1  1   1  1  0 #>  [97,]  1  1  1  1  1  0  0   0  1  0 #>  [98,]  1  1  1  1  1  1  0   0  1  0 #>  [99,]  0  0  0  0  1  0  0   0  1  1 #> [100,]  0  0  0  0  1  1  0   0  1  1 #> [101,]  0  0  0  0  1  1  1   1  0  0 #> [102,]  0  0  0  0  0  1  0   0  1  1 #> [103,]  0  0  0  1  1  0  0   0  0  0 #> [104,]  0  0  0  1  1  0  0   0  1  1 #> [105,]  0  0  0  1  1  1  0   0  1  1 #> [106,]  0  0  0  1  1  1  1   1  0  0 #> [107,]  1  0  0  1  0  0  0   0  0  0 #> [108,]  1  0  0  1  1  0  0   0  0  0 #> [109,]  1  0  0  1  1  0  0   0  1  1 #> [110,]  1  0  0  1  1  1  0   0  1  1 #> [111,]  1  0  0  1  1  1  1   1  0  0 #> [112,]  1  1  1  1  1  1  0   0  0  0  set.seed(123) trees <- rmtree(10, 20) X <- matrix(sample(c(\"red\", \"blue\", \"violet\"), 100, TRUE, c(.5,.4, .1)),    ncol=5, dimnames=list(paste('t',1:20, sep=\"\"), paste('Var',1:5, sep=\"_\"))) x <- phyDat(X, type = \"USER\", levels = c(\"red\", \"blue\"), ambiguity=\"violet\") plot(trees[[1]], \"u\", tip.color = X[trees[[1]]$tip,1])  # intruders are blue   (divTab <- getDiversity(trees, x, var.names=colnames(X))) #>    tree variable    E clan # natives # intruder # unknown   E slice # intruder #> 1     1    Var_1 0.8568636         9         10         1 1.0000000          7 #> 2     1    Var_2 0.6562658        11          7         2 0.7500000          4 #> 3     1    Var_3 0.7500962         8         11         1 0.8018797          8 #> 4     1    Var_4 0.9474428         7         11         2 1.0000000          9 #> 5     1    Var_5 1.0000000         8         10         2 1.0000000          9 #> 6     2    Var_1 0.8568636         9         10         1 1.0000000          7 #> 7     2    Var_2 0.7964530        11          7         2 0.8277294          5 #> 8     2    Var_3 0.9474428         8         11         1 1.0000000          9 #> 9     2    Var_4 0.8224909         7         11         2 0.9166667          8 #> 10    2    Var_5 0.6387640         8         10         2 0.7420981          6 #> 11    3    Var_1 0.8795880         9         10         1 0.9166667          8 #> 12    3    Var_2 0.8982265        11          7         2 1.0000000          5 #> 13    3    Var_3 0.7372138         8         11         1 0.8982265          7 #> 14    3    Var_4 0.8948855         7         11         2 0.9298967          9 #> 15    3    Var_5 1.0000000         8         10         2 1.0000000          9 #> 16    4    Var_1 0.8795880         9         10         1 0.9166667          8 #> 17    4    Var_2 0.8982265        11          7         2 1.0000000          5 #> 18    4    Var_3 0.7372138         8         11         1 0.8982265          7 #> 19    4    Var_4 0.8948855         7         11         2 0.9298967          9 #> 20    4    Var_5 1.0000000         8         10         2 1.0000000          9 #> 21    5    Var_1 0.7966576         9         10         1 0.8982265          7 #> 22    5    Var_2 0.8982265        11          7         2 1.0000000          5 #> 23    5    Var_3 0.8224909         8         11         1 0.9166667          8 #> 24    5    Var_4 0.5699628         7         11         2 0.6934264          6 #> 25    5    Var_5 0.4729033         8         10         2 0.7500000          4 #> 26    6    Var_1 0.7966576         9         10         1 0.8982265          7 #> 27    6    Var_2 0.8982265        11          7         2 1.0000000          5 #> 28    6    Var_3 0.8224909         8         11         1 0.9166667          8 #> 29    6    Var_4 1.0000000         7         11         2 1.0000000         10 #> 30    6    Var_5 0.9397940         8         10         2 1.0000000          8 #> 31    7    Var_1 0.8795880         9         10         1 0.9166667          8 #> 32    7    Var_2 1.0000000        11          7         2 1.0000000          6 #> 33    7    Var_3 0.9474428         8         11         1 1.0000000          9 #> 34    7    Var_4 0.7500962         7         11         2 0.8018797          8 #> 35    7    Var_5 0.9397940         8         10         2 1.0000000          8 #> 36    8    Var_1 0.8795880         9         10         1 0.9166667          8 #> 37    8    Var_2 0.8982265        11          7         2 1.0000000          5 #> 38    8    Var_3 0.8224909         8         11         1 0.9166667          8 #> 39    8    Var_4 0.6846566         7         11         2 0.7964530          7 #> 40    8    Var_5 0.8568636         8         10         2 1.0000000          7 #> 41    9    Var_1 0.7364516         9         10         1 0.7964530          7 #> 42    9    Var_2 0.7964530        11          7         2 0.8277294          5 #> 43    9    Var_3 0.8948855         8         11         1 0.9298967          9 #> 44    9    Var_4 0.7897710         7         11         2 0.7896901          9 #> 45    9    Var_5 0.7591760         8         10         2 1.0000000          6 #> 46   10    Var_1 0.5903090         9         10         1 0.8277294          5 #> 47   10    Var_2 0.8982265        11          7         2 1.0000000          5 #> 48   10    Var_3 0.8224909         8         11         1 0.9166667          8 #> 49   10    Var_4 0.8750481         7         11         2 1.0000000          8 #> 50   10    Var_5 0.9397940         8         10         2 1.0000000          8 #>    # unknown E melange # intruder # unknown bs 1 bs 2 p-score #> 1          1 1.0000000          6         1   NA   NA       8 #> 2          2 1.0000000          2         2   NA   NA       4 #> 3          1 1.0000000          5         1   NA   NA       6 #> 4          2 1.0000000          8         2   NA   NA       7 #> 5          2 1.0000000          8         2   NA   NA       7 #> 6          1 1.0000000          6         1   NA   NA       7 #> 7          2 1.0000000          3         1   NA   NA       5 #> 8          1 1.0000000          8         1   NA   NA       7 #> 9          2 1.0000000          6         2   NA   NA       5 #> 10         1 0.7500000          4         1   NA   NA       5 #> 11         1 1.0000000          6         1   NA   NA       7 #> 12         2 1.0000000          4         2   NA   NA       6 #> 13         1 1.0000000          5         1   NA   NA       7 #> 14         2 1.0000000          7         1   NA   NA       5 #> 15         2 1.0000000          8         2   NA   NA       8 #> 16         1 1.0000000          6         1   NA   NA       4 #> 17         2 1.0000000          4         2   NA   NA       5 #> 18         1 1.0000000          5         1   NA   NA       6 #> 19         2 1.0000000          7         2   NA   NA       6 #> 20         2 1.0000000          8         2   NA   NA       8 #> 21         1 1.0000000          5         1   NA   NA       7 #> 22         2 1.0000000          4         2   NA   NA       6 #> 23         1 1.0000000          6         1   NA   NA       7 #> 24         0 1.0000000          3         0   NA   NA       5 #> 25         2 1.0000000          2         2   NA   NA       4 #> 26         1 1.0000000          5         1   NA   NA       6 #> 27         1 1.0000000          4         1   NA   NA       6 #> 28         1 1.0000000          6         1   NA   NA       6 #> 29         2 1.0000000          9         2   NA   NA       7 #> 30         2 1.0000000          7         2   NA   NA       7 #> 31         1 1.0000000          6         0   NA   NA       6 #> 32         2 1.0000000          5         2   NA   NA       6 #> 33         1 1.0000000          8         1   NA   NA       7 #> 34         1 1.0000000          5         1   NA   NA       5 #> 35         2 1.0000000          7         2   NA   NA       7 #> 36         1 1.0000000          6         0   NA   NA       8 #> 37         2 1.0000000          4         2   NA   NA       6 #> 38         1 1.0000000          6         1   NA   NA       7 #> 39         2 0.8277294          5         2   NA   NA       6 #> 40         2 1.0000000          6         2   NA   NA       4 #> 41         1 0.8277294          5         1   NA   NA       6 #> 42         2 1.0000000          3         1   NA   NA       4 #> 43         1 1.0000000          7         1   NA   NA       7 #> 44         2 0.7964530          7         2   NA   NA       5 #> 45         2 1.0000000          5         2   NA   NA       6 #> 46         1 1.0000000          3         1   NA   NA       5 #> 47         2 1.0000000          4         2   NA   NA       6 #> 48         1 1.0000000          6         1   NA   NA       5 #> 49         2 1.0000000          7         2   NA   NA       6 #> 50         1 1.0000000          7         1   NA   NA       7 summary(divTab) #>   Variable Natives_only Intruder_only Clan Slice Melange #> 1    Var_1            0             0    0     0      10 #> 2    Var_2            0             0    0     0      10 #> 3    Var_3            0             0    0     0      10 #> 4    Var_4            0             0    0     0      10 #> 5    Var_5            0             0    0     0      10"},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":null,"dir":"Reference","previous_headings":"","what":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"collection functions perform Hadamard conjugation Hv Hadamard matrix H vector v using fast Hadamard multiplication.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"","code":"hadamard(x)  fhm(v)  h4st(obj, levels = c(\"a\", \"c\", \"g\", \"t\"))  h2st(obj, eps = 0.001)"},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"x vector length \\(2^n\\), n integer. v vector length \\(2^n\\), n integer. obj data.frame character matrix, typical sequence alignment. levels levels sequences. eps Threshold value splits.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"hadamard returns Hadamard matrix. fhm returns fast Hadamard multiplication.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"h2st h4st perform Hadamard conjugation 2-state (binary, RY-coded) 4-state (DNA/RNA) data. write.nexus.splits writes splits returned h2st distanceHadamard nexus file, can processed Spectronet SplitsTree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"Hendy, M.D. (1989). relationship simple evolutionary tree models observable sequence data. Systematic Zoology, 38 310–321. Hendy, M. D. Penny, D. (1993). Spectral Analysis Phylogenetic Data. Journal Classification, 10, 5–24. Hendy, M. D. (2005). Hadamard conjugation: analytical tool phylogenetics. O. Gascuel, editor, Mathematics evolution phylogeny, Oxford University Press, Oxford Waddell P. J. (1995). Statistical methods phylogenetic analysis: Including hadamard conjugation, LogDet transforms, maximum likelihood. PhD thesis.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/hadamard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hadamard Matrices and Fast Hadamard Multiplication — hadamard","text":"","code":"H <- hadamard(3) v <- 1:8 H %*% v #>      [,1] #> [1,]   36 #> [2,]   -4 #> [3,]   -8 #> [4,]    0 #> [5,]  -16 #> [6,]    0 #> [7,]    0 #> [8,]    0 fhm(v) #> [1]  36  -4  -8   0 -16   0   0   0  data(yeast)  # RY-coding dat_ry <- acgt2ry(yeast) #> Warning: Found unknown characters (not supplied in levels). Deleted sites with unknown states. fit2 <- h2st(dat_ry) lento(fit2)   # write.nexus.splits(fit2, file = \"test.nxs\") # read this file into Spectronet or SplitsTree to show the network  fit4 <- h4st(yeast) old.par <- par(no.readonly = TRUE) par(mfrow=c(3,1)) lento(fit4[[1]], main=\"Transversion\") lento(fit4[[2]], main=\"Transition 1\") lento(fit4[[3]], main=\"Transition 2\")  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify splits in a network — identify.networx","title":"Identify splits in a network — identify.networx","text":"identify.networx reads position graphics pointer mouse button pressed. returns split belonging edge closest pointer. network must plotted beforehand.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify splits in a network — identify.networx","text":"","code":"# S3 method for class 'networx' identify(x, quiet = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify splits in a network — identify.networx","text":"x object class networx quiet logical controlling whether print message inviting user click tree. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify splits in a network — identify.networx","text":"identify.networx returns splits object.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify splits in a network — identify.networx","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/identify.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify splits in a network — identify.networx","text":"","code":"if (FALSE) { # \\dontrun{ data(yeast) dm <- dist.ml(yeast) nnet <- neighborNet(dm) plot(nnet) identify(nnet) # click close to an edge } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of a Sequence Alignment — image.phyDat","title":"Plot of a Sequence Alignment — image.phyDat","text":"function plots image alignment sequences.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of a Sequence Alignment — image.phyDat","text":"","code":"# S3 method for class 'phyDat' image(x, ...)  # S3 method for class 'ancestral' image(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of a Sequence Alignment — image.phyDat","text":"x object containing sequences, object class phyDat. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of a Sequence Alignment — image.phyDat","text":"Nothing. function called plotting.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot of a Sequence Alignment — image.phyDat","text":"wrapper using image.DNAbin image.AAbin. Codons triplets handled nucleotide sequences.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/image.phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of a Sequence Alignment — image.phyDat","text":"","code":"data(\"chloroplast\") image(chloroplast[, 1:50], scheme=\"Clustal\", show.aa = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/latag2n.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace leading and trailing alignment gaps with an ambiguous state — latag2n.phyDat","title":"Replace leading and trailing alignment gaps with an ambiguous state — latag2n.phyDat","text":"Substitutes leading trailing alignment gaps aligned sequences N (.e., , C, G, T) ?. gaps middle sequences left unchanged.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/latag2n.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace leading and trailing alignment gaps with an ambiguous state — latag2n.phyDat","text":"","code":"latag2n.phyDat(x, amb = ifelse(attr(x, \"type\") == \"DNA\", \"N\", \"?\"),   gap = \"-\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/latag2n.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace leading and trailing alignment gaps with an ambiguous state — latag2n.phyDat","text":"x object class phyDat. amb character ambiguous state t replace gaps. gap gap parameter replace. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/latag2n.phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace leading and trailing alignment gaps with an ambiguous state — latag2n.phyDat","text":"returns object class phyDat.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/latag2n.phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace leading and trailing alignment gaps with an ambiguous state — latag2n.phyDat","text":"","code":"x <- phyDat(matrix(c(\"-\", \"A\", \"G\", \"-\", \"T\", \"C\"), 2, 3)) y <- latag2n.phyDat(x) image(x)  image(y)"},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":null,"dir":"Reference","previous_headings":"","what":"Lento plot — lento","title":"Lento plot — lento","text":"lento plot represents support conflict splits/bipartitions.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lento plot — lento","text":"","code":"lento(obj, xlim = NULL, ylim = NULL, main = \"Lento plot\", sub = NULL,   xlab = NULL, ylab = NULL, bipart = TRUE, trivial = FALSE,   col = rgb(0, 0, 0, 0.5), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lento plot — lento","text":"obj object class phylo, multiPhylo splits xlim graphical parameter ylim graphical parameter main graphical parameter sub graphical parameter xlab graphical parameter ylab graphical parameter bipart plot bipartition information. trivial logical, whether present trivial splits (default FALSE). col color splits / bipartition. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lento plot — lento","text":"lento returns plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lento plot — lento","text":"Lento, G.M., Hickson, R.E., Chambers G.K., Penny, D. (1995) Use spectral analysis test hypotheses origin pinninpeds. Molecular Biology Evolution, 12, 28-52.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lento plot — lento","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/lento.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lento plot — lento","text":"","code":"data(yeast) yeast.ry <- acgt2ry(yeast) #> Warning: Found unknown characters (not supplied in levels). Deleted sites with unknown states. splits.h <- h2st(yeast.ry) lento(splits.h, trivial=TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum agreement subtree — mast","title":"Maximum agreement subtree — mast","text":"mast computes maximum agreement subtree (MAST).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum agreement subtree — mast","text":"","code":"mast(x, y, tree = TRUE, rooted = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum agreement subtree — mast","text":"x tree, .e. object class phylo. y tree, .e. object class phylo. tree logical, TRUE returns tree wise tip labels maximum agreement subtree. rooted logical TRUE treats trees rooted otherwise unrooted.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum agreement subtree — mast","text":"mast returns vector tip labels MAST.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum agreement subtree — mast","text":"code derived code example Valiente (2009). version unrooted trees much slower.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Maximum agreement subtree — mast","text":"G. Valiente (2009). Combinatorial Pattern Matching Algorithms Computational Biology using Perl R. Taylor & Francis/CRC Press","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum agreement subtree — mast","text":"Klaus Schliep klaus.schliep@gmail.com based code Gabriel Valiente","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum agreement subtree — mast","text":"","code":"tree1 <- rtree(100) tree2 <- rNNI(tree1, 20) tips <- mast(tree1, tree2)"},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":null,"dir":"Reference","previous_headings":"","what":"Maximum clade credibility tree — maxCladeCred","title":"Maximum clade credibility tree — maxCladeCred","text":"maxCladeCred computes maximum clade credibility tree sample trees. far just best tree returned. annotations transformations edge length performed edge length taken tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Maximum clade credibility tree — maxCladeCred","text":"","code":"maxCladeCred(x, tree = TRUE, part = NULL, rooted = TRUE)  mcc(x, tree = TRUE, part = NULL, rooted = TRUE)  allCompat(x, rooted = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Maximum clade credibility tree — maxCladeCred","text":"x x object class multiPhylo phylo tree logical indicating whether return tree clade credibility (default) clade credibility score trees. part list partitions returned prop.part rooted logical, FALSE tree highest maximum bipartition credibility returned.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Maximum clade credibility tree — maxCladeCred","text":"tree (object class phylo) highest clade credibility numeric vector clade credibilities tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Maximum clade credibility tree — maxCladeCred","text":"list partition provided clade credibility computed trees x. allCompat returns 50% majority rule consensus tree added compatible splits similar option allcompat MrBayes. tree edge length. add_edge_length can used add edge lengths computed sample trees.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Maximum clade credibility tree — maxCladeCred","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/maxCladeCred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Maximum clade credibility tree — maxCladeCred","text":"","code":"data(Laurasiatherian) set.seed(42) bs <- bootstrap.phyDat(Laurasiatherian,   FUN = function(x)upgma(dist.hamming(x)), bs=100)  strict_consensus <- consensus(bs) majority_consensus <- consensus(bs, p=.5) all_compat <- allCompat(bs) max_clade_cred <- maxCladeCred(bs)  old.par <- par(no.readonly = TRUE) par(mfrow = c(2,2), mar = c(1,4,1,1)) plot(strict_consensus, main=\"Strict consensus tree\") plot(majority_consensus, main=\"Majority consensus tree\") plot(all_compat, main=\"Majority consensus tree with compatible splits\") plot(max_clade_cred, main=\"Maximum clade credibility tree\")   par(mfrow = c(2,1)) plot(max_clade_cred, main=\"Edge length from tree\") add_boxplot(max_clade_cred, bs) max_clade_cred_2 <- add_edge_length(max_clade_cred, bs) plot(max_clade_cred_2, main=\"Edge length computed from sample\") add_boxplot(max_clade_cred_2, bs)   par(old.par)  # compute clade credibility for trees given a prop.part object pp <- prop.part(bs) tree <- rNNI(bs[[1]], 20) maxCladeCred(c(tree, bs[[1]]), tree=FALSE, part = pp) #> [1]      -Inf -36.10917 # first value likely be -Inf"},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree manipulation — getRoot","title":"Tree manipulation — getRoot","text":"midpoint performs midpoint rooting tree.  pruneTree produces consensus tree. pruneTree prunes back tree produces consensus tree, trees already containing nodelabels.  assumes nodelabels numerical character allows conversion numerical, uses .numeric(.character(tree$node.labels)) convert . midpoint default assumes node labels contain support values. works support values computed splits, recomputed clades. keep_as_tip takes list tips /node labels returns tree pruned . node label, prunes descendants node internal node becomes tip.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree manipulation — getRoot","text":"","code":"getRoot(tree)  midpoint(tree, node.labels = \"support\", ...)  # S3 method for class 'phylo' midpoint(tree, node.labels = \"support\", ...)  # S3 method for class 'multiPhylo' midpoint(tree, node.labels = \"support\", ...)  pruneTree(tree, ..., FUN = \">=\")  keep_as_tip(tree, labels)"},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree manipulation — getRoot","text":"tree object class phylo. node.labels node labels 'support' values (edges), 'label' labels get 'deleted'? ... arguments, passed methods. FUN function evaluated nodelabels, result must logical. labels tip node labels keep tip labels tree","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree manipulation — getRoot","text":"pruneTree midpoint tree. getRoot returns root node.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tree manipulation — getRoot","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/midpoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree manipulation — getRoot","text":"","code":"tree <- rtree(10, rooted = FALSE) tree$node.label <- c(\"\", round(runif(tree$Nnode-1), digits=3))  tree2 <- midpoint(tree) tree3 <- pruneTree(tree, .5)  old.par <- par(no.readonly = TRUE) par(mfrow = c(3,1)) plot(tree, show.node.label=TRUE) plot(tree2, show.node.label=TRUE) plot(tree3, show.node.label=TRUE)  par(old.par)"},{"path":"https://klausvigo.github.io/phangorn/reference/mites.html","id":null,"dir":"Reference","previous_headings":"","what":"Morphological characters of Mites (Schäffer et al. 2010) — mites","title":"Morphological characters of Mites (Schäffer et al. 2010) — mites","text":"Matrix morphological characters character states 12 species mites. See vignette '02_Phylogenetic trees morphological data' examples import morphological data.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mites.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Morphological characters of Mites (Schäffer et al. 2010) — mites","text":"Schäffer, S., Pfingstl, T., Koblmüller, S., Winkler, K. ., Sturmbauer, C., & Krisper, G. (2010). Phylogenetic analysis European Scutovertex mites (Acari, Oribatida, Scutoverticidae) reveals paraphyly cryptic diversity: molecular genetic morphological approach. Molecular Phylogenetics Evolution, 55(2), 677–688.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/mites.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Morphological characters of Mites (Schäffer et al. 2010) — mites","text":"","code":"data(mites) mites #> 12 sequences with 79 character and 53 different site patterns. #> The states are 0 1 2 3 4 5 6 7  # infer all maximum parsimony trees trees <- bab(mites) #> Compute starting tree #> lower bound: 108  #> upper bound: 139  #> Search Baumraum (tree space) #>    |                                                                               |                                                                      |   0%   |                                                                               |=                                                                     |   1%   |                                                                               |=                                                                     |   2%   |                                                                               |==                                                                    |   3%   |                                                                               |===                                                                   |   4%   |                                                                               |===                                                                   |   5%   |                                                                               |====                                                                  |   6%   |                                                                               |=====                                                                 |   7%   |                                                                               |=====                                                                 |   8%   |                                                                               |======                                                                |   9%   |                                                                               |=======                                                               |  10%   |                                                                               |========                                                              |  11%   |                                                                               |=========                                                             |  12%   |                                                                               |=========                                                             |  13%   |                                                                               |==========                                                            |  14%   |                                                                               |===========                                                           |  15%   |                                                                               |===========                                                           |  16%   |                                                                               |============                                                          |  17%   |                                                                               |=============                                                         |  18%   |                                                                               |=============                                                         |  19%   |                                                                               |==============                                                        |  20%   |                                                                               |===============                                                       |  21%   |                                                                               |===============                                                       |  22%   |                                                                               |================                                                      |  23%   |                                                                               |=================                                                     |  24%   |                                                                               |=================                                                     |  25%   |                                                                               |==================                                                    |  26%   |                                                                               |===================                                                   |  27%   |                                                                               |===================                                                   |  28%   |                                                                               |====================                                                  |  29%   |                                                                               |=====================                                                 |  30%   |                                                                               |======================                                                |  31%   |                                                                               |=======================                                               |  32%   |                                                                               |=======================                                               |  33%   |                                                                               |========================                                              |  34%   |                                                                               |=========================                                             |  35%   |                                                                               |=========================                                             |  36%   |                                                                               |==========================                                            |  37%   |                                                                               |===========================                                           |  38%   |                                                                               |===========================                                           |  39%   |                                                                               |============================                                          |  40%   |                                                                               |=============================                                         |  41%   |                                                                               |=============================                                         |  42%   |                                                                               |==============================                                        |  43%   |                                                                               |===============================                                       |  44%   |                                                                               |===============================                                       |  45%   |                                                                               |================================                                      |  46%   |                                                                               |=================================                                     |  47%   |                                                                               |=================================                                     |  48%   |                                                                               |==================================                                    |  49%   |                                                                               |===================================                                   |  50%   |                                                                               |====================================                                  |  51%   |                                                                               |=====================================                                 |  52%   |                                                                               |=====================================                                 |  53%   |                                                                               |======================================                                |  54%   |                                                                               |=======================================                               |  55%   |                                                                               |=======================================                               |  56%   |                                                                               |========================================                              |  57%   |                                                                               |=========================================                             |  58%   |                                                                               |=========================================                             |  59%   |                                                                               |==========================================                            |  60%   |                                                                               |===========================================                           |  61%   |                                                                               |===========================================                           |  62%   |                                                                               |============================================                          |  63%   |                                                                               |=============================================                         |  64%   |                                                                               |=============================================                         |  65%   |                                                                               |==============================================                        |  66%   |                                                                               |===============================================                       |  67%   |                                                                               |===============================================                       |  68%   |                                                                               |================================================                      |  69%   |                                                                               |=================================================                     |  70%   |                                                                               |==================================================                    |  71%   |                                                                               |===================================================                   |  72%   |                                                                               |===================================================                   |  73%   |                                                                               |====================================================                  |  74%   |                                                                               |=====================================================                 |  75%   |                                                                               |=====================================================                 |  76%   |                                                                               |======================================================                |  77%   |                                                                               |=======================================================               |  78%   |                                                                               |=======================================================               |  79%   |                                                                               |========================================================              |  80%   |                                                                               |=========================================================             |  81%   |                                                                               |=========================================================             |  82%   |                                                                               |==========================================================            |  83%   |                                                                               |===========================================================           |  84%   |                                                                               |===========================================================           |  85%   |                                                                               |============================================================          |  86%   |                                                                               |=============================================================         |  87%   |                                                                               |=============================================================         |  88%   |                                                                               |==============================================================        |  89%   |                                                                               |===============================================================       |  90%   |                                                                               |================================================================      |  91%   |                                                                               |=================================================================     |  92%   |                                                                               |=================================================================     |  93%   |                                                                               |==================================================================    |  94%   |                                                                               |===================================================================   |  95%   |                                                                               |===================================================================   |  96%   |                                                                               |====================================================================  |  97%   |                                                                               |===================================================================== |  98%   |                                                                               |===================================================================== |  99%   |                                                                               |======================================================================| 100% # For larger data sets you might use pratchet instead bab # trees <- pratchet(mites, minit=200, trace=0, all=TRUE) # build consensus tree ctree <- root(consensus(trees, p=.5), outgroup = \"C._cymba\",               resolve.root=TRUE, edgelabel=TRUE) plotBS(ctree, trees)  cnet <- consensusNet(trees) plot(cnet)"},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":null,"dir":"Reference","previous_headings":"","what":"ModelTest — modelTest","title":"ModelTest — modelTest","text":"Comparison different nucleotide amino acid substitution models","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ModelTest — modelTest","text":"","code":"modelTest(object, tree = NULL, model = NULL, G = TRUE, I = TRUE,   FREQ = FALSE, k = 4, control = pml.control(epsilon = 1e-08, maxit = 10,   trace = 1), multicore = FALSE, mc.cores = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ModelTest — modelTest","text":"object object class phyDat pml tree phylogenetic tree. model vector containing substitution models compare \"\" test available models G logical, TRUE (default) (discrete) Gamma model tested logical, TRUE (default) invariant sites tested FREQ logical, FALSE (default) TRUE amino acid frequencies estimated. k number rate classes control list parameters controlling fitting process. multicore logical, whether models estimated parallel. mc.cores number cores use, .e. many child processes run simultaneously. Must least one, parallelization requires least two cores.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ModelTest — modelTest","text":"data.frame containing log-likelihood, number estimated parameters, AIC, AICc BIC tested models.  data.frame attributes \"env\" environment contains trees, data calls allow get estimated models, e.g. starting point analysis (see example).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"ModelTest — modelTest","text":"modelTest estimates specified models given tree data.  mclapply available, computations done parallel. modelTest runs model one thread.  may work within GUI interface work Windows.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"ModelTest — modelTest","text":"Burnham, K. P. Anderson, D. R (2002) Model selection multimodel inference: practical information-theoretic approach. 2nd ed. Springer, New York Posada, D. Crandall, K.. (1998) MODELTEST: testing model DNA substitution. Bioinformatics 14(9): 817-818 Posada, D. (2008) jModelTest: Phylogenetic Model Averaging. Molecular Biology Evolution 25: 1253-1256 Darriba D., Taboada G.L., Doallo R Posada D. (2011) ProtTest 3: fast selection best-fit models protein evolution. . Bioinformatics 27: 1164-1165","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"ModelTest — modelTest","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/modelTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ModelTest — modelTest","text":"","code":"if (FALSE) { # \\dontrun{ example(NJ) (mT <- modelTest(Laurasiatherian, tree, model = c(\"JC\", \"F81\", \"K80\", \"HKY\",                  \"SYM\", \"GTR\")))  # extract best model (best_model <- as.pml(mT))   data(chloroplast) (mTAA <- modelTest(chloroplast, model=c(\"JTT\", \"WAG\", \"LG\")))  # test all available amino acid models (mTAA_all <- modelTest(chloroplast, model=\"all\", multicore=TRUE, mc.cores=2)) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes a neighborNet from a distance matrix — neighborNet","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"Computes neighborNet, .e. object class networx distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"","code":"neighborNet(x, ord = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"x distance matrix. ord circular ordering.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"neighborNet returns object class networx.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"neighborNet still experimental. cyclic ordering sometimes differ SplitsTree implementation, ord argument can used enforce certain circular ordering.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"Bryant, D. & Moulton, V. (2004) Neighbor-Net: Agglomerative Method Construction Phylogenetic Networks. Molecular Biology Evolution, 21, 255-265 Bryant, D., & Huson, D. H. (2023). NeighborNet: improved algorithms implementation.  Frontiers bioinformatics, 3, 1178600.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/neighborNet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes a neighborNet from a distance matrix — neighborNet","text":"","code":"data(yeast) dm <- dist.ml(yeast) nnet <- neighborNet(dm) plot(nnet)  plot(nnet, type=\"outline\")"},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":null,"dir":"Reference","previous_headings":"","what":"Tree rearrangements. — nni","title":"Tree rearrangements. — nni","text":"nni returns list trees one nearest neighbor interchange away. rNNI rSPR two methods simulate random trees specified number rearrangement apart input tree. methods assume input tree bifurcating. methods may useful simulation studies.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tree rearrangements. — nni","text":"","code":"nni(tree)  rNNI(tree, moves = 1, n = length(moves))  rSPR(tree, moves = 1, n = length(moves), k = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tree rearrangements. — nni","text":"tree phylogenetic tree, object class phylo. moves Number tree rearrangements transformed tree.  Can vector n Number trees simulated. k defined just SPR distance k performed.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tree rearrangements. — nni","text":"object class multiPhylo.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Tree rearrangements. — nni","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/nni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tree rearrangements. — nni","text":"","code":"tree <- rtree(20, rooted = FALSE) trees1 <- nni(tree) trees2 <- rSPR(tree, 2, 10)"},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":null,"dir":"Reference","previous_headings":"","what":"Parsimony tree. — fitch","title":"Parsimony tree. — fitch","text":"pratchet implements parsimony ratchet (Nixon, 1999) preferred way search best parsimony tree. small number taxa function bab can used compute parsimonious trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parsimony tree. — fitch","text":"","code":"fitch(tree, data, site = \"pscore\")  random.addition(data, tree = NULL, method = \"fitch\")  parsimony(tree, data, method = \"fitch\", cost = NULL, site = \"pscore\")  optim.parsimony(tree, data, method = \"fitch\", cost = NULL, trace = 1,   rearrangements = \"SPR\", ...)  pratchet(data, start = NULL, method = \"fitch\", maxit = 1000,   minit = 100, k = 10, trace = 1, all = FALSE,   rearrangements = \"SPR\", perturbation = \"ratchet\", ...)  sankoff(tree, data, cost = NULL, site = \"pscore\")"},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parsimony tree. — fitch","text":"tree tree start nni search . data object class phyDat containing sequences. site return either 'pscore' 'site' wise parsimony scores. method one 'fitch' 'sankoff'. cost cost matrix transitions two states. trace defines much information printed optimization. rearrangements SPR NNI rearrangements. ... arguments passed methods (e.g. model=\"sankoff\" cost matrix). start starting tree can supplied. maxit maximum number iterations ratchet. minit minimum number iterations ratchet. k number rounds ratchet stopped, improvement. return equally good trees just one . perturbation whether use \"ratchet\", \"random_addition\" \"stochastic\" (nni) shuffling tree.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parsimony tree. — fitch","text":"parsimony returns maximum parsimony score (pscore). optim.parsimony returns tree NNI rearrangements. pratchet returns tree list trees containing best tree(s) found search.  acctran returns tree edge length according ACCTRAN criterion.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parsimony tree. — fitch","text":"parsimony returns parsimony score tree using either sankoff fitch algorithm. optim.parsimony optimizes topology using either Nearest Neighbor Interchange (NNI) rearrangements sub tree pruning regrafting (SPR) used inside pratchet. random.addition can used produce starting trees option argument perturbation pratchet. \"SPR\" rearrangements far available \"fitch\" method, \"sankoff\" uses \"NNI\". \"fitch\" algorithm works correct binary trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Parsimony tree. — fitch","text":"Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland. Nixon, K. (1999) Parsimony Ratchet, New Method Rapid Parsimony Analysis. Cladistics 15, 407-414","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parsimony tree. — fitch","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/parsimony.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parsimony tree. — fitch","text":"","code":"set.seed(3) data(Laurasiatherian) dm <- dist.hamming(Laurasiatherian) tree <- NJ(dm) parsimony(tree, Laurasiatherian) #> [1] 9796 treeRA <- random.addition(Laurasiatherian) treeSPR <- optim.parsimony(tree, Laurasiatherian) #> Final p-score 9715 after  11 nni operations   # lower number of iterations for the example (to run less than 5 seconds), # keep default values (maxit, minit, k) or increase them for real life # analyses. treeRatchet <- pratchet(Laurasiatherian, start=tree, maxit=100,                         minit=5, k=5, trace=0) # assign edge length (number of substitutions) treeRatchet <- acctran(treeRatchet, Laurasiatherian) # remove edges of length 0 treeRatchet <- di2multi(treeRatchet)  plot(midpoint(treeRatchet)) add.scale.bar(0,0, length=100)   parsimony(c(tree,treeSPR, treeRatchet), Laurasiatherian) #> [1] 9796 9715 9713"},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-internal.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal phangorn Functions — threshStateC","title":"Internal phangorn Functions — threshStateC","text":"Internal phangorn functions.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-internal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal phangorn Functions — threshStateC","text":"","code":"threshStateC(x, thresholds)  assert_phylo(x, has_edge_length = FALSE, is_rooted = FALSE,   is_ultrametric = FALSE)  assert_treeish(x, null.ok = FALSE)  assert_multiPhylo(x, is_ultrametric = FALSE, is_rooted = FALSE,   same_labels = FALSE, has_edge_length = FALSE)  assert_phyDat(x, contains_label = !is.null(label), label = NULL)  assert_pml(x)  assert_dist(x, finite = FALSE, missing = FALSE)  clean_phylo(x, unroot = FALSE, multi2di = FALSE,   collapse.singles = FALSE, reorder = FALSE)  clean_multiPhylo(x, unroot = FALSE, multi2di = FALSE,   collapse.singles = FALSE, reorder = FALSE, compress = FALSE)  candidate_tree(x, method = c(\"unrooted\", \"ultrametric\", \"tipdated\"),   eps = 1e-08, tip.dates = NULL, ...)  hash(x, ...)  map_duplicates(x, dist = length(x) < 500, ...)  edQt(Q = c(1, 1, 1, 1, 1, 1), bf = c(0.25, 0.25, 0.25, 0.25))  pml.free()  pml.init(data, k = 1L)  coords(obj, dim = \"3D\")  pmlPen(object, lambda, ...)  relabel(x, ref)  edge_length_hclust(x, dm, method = \"average\")"},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-package.html","id":null,"dir":"Reference","previous_headings":"","what":"phangorn: Phylogenetic Reconstruction and Analysis — phangorn-package","title":"phangorn: Phylogenetic Reconstruction and Analysis — phangorn-package","text":"Allows estimation phylogenetic trees networks using Maximum Likelihood, Maximum Parsimony, distance methods Hadamard conjugation (Schliep 2011). Offers methods tree comparison, model selection visualization phylogenetic networks described Schliep et al. (2017).","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/phangorn-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"phangorn: Phylogenetic Reconstruction and Analysis — phangorn-package","text":"Maintainer: Klaus Schliep klaus.schliep@gmail.com (ORCID) Authors: Emmanuel Paradis (ORCID) Leonardo de Oliveira Martins (ORCID) Alastair Potts Iris Bardel-Kahr (ORCID) contributors: Tim W. White [contributor] Cyrill Stachniss [contributor] Michelle Kendall m.kendall@imperial.ac.uk [contributor] Keren Halabi [contributor] Richel Bilderbeek [contributor] Kristin Winchell [contributor] Liam Revell [contributor] Mike Gilchrist [contributor] Jeremy Beaulieu [contributor] Brian O'Meara [contributor] Long Qu [contributor] Joseph Brown (ORCID) [contributor] Santiago Claramunt (ORCID) [contributor]","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Generic functions for class phyDat — print.phyDat","title":"Generic functions for class phyDat — print.phyDat","text":"functions help manipulate alignments class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generic functions for class phyDat — print.phyDat","text":"","code":"# S3 method for class 'phyDat' print(x, ...)  # S3 method for class 'phyDat' cbind(..., gaps = \"-\", compress = TRUE)  # S3 method for class 'phyDat' rbind(...)  # S3 method for class 'phyDat' c(..., gaps = \"-\", compress = TRUE)  # S3 method for class 'phyDat' subset(x, subset, select, site.pattern = TRUE, ...)  # S3 method for class 'phyDat' x[i, j, ..., drop = FALSE]  # S3 method for class 'phyDat' unique(x, incomparables = FALSE, identical = TRUE, ...)  removeUndeterminedSites(x, ...)  removeAmbiguousSites(x)  allSitePattern(n, levels = NULL, names = NULL, type = \"DNA\", code = 1)"},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generic functions for class phyDat — print.phyDat","text":"x object containing sequences. ... arguments passed methods. gaps character gaps (default '-'). compress logical, compress data store site patterns. subset subset taxa. select subset characters. site.pattern select site pattern sites (see details). , j indices rows /columns select drop. may numeric, logical, character (way standard R objects). drop compatibility generic (unused). incomparables compatibility unique. identical TRUE (default) sequences identical, FALSE sequences considered duplicates distance sequences zero (happens frequently ambiguous sites). n Number sequences. levels Level attributes. names Names sequences. type Type sequences (\"DNA\", \"AA\" \"USER\"). code ncbi genetic code number translation. default standard genetic code used.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generic functions for class phyDat — print.phyDat","text":"functions return object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generic functions for class phyDat — print.phyDat","text":"allSitePattern generates possible site patterns can useful simulation studies. details see vignette AdvancedFeatures. generic function c can used combine sequences unique get unique sequences unique haplotypes. phyDat stores identical columns alignment keeps index original positions. saves memory especially computations usually need done site pattern. example matrix x example 8 columns, column 1 2 also 3 5 identical. phyDat object y 6 site pattern. argument site.pattern=FALSE indexing behaves like original matrix x. site.pattern=TRUE can useful inside functions.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generic functions for class phyDat — print.phyDat","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generic functions for class phyDat — print.phyDat","text":"","code":"data(Laurasiatherian) class(Laurasiatherian) #> [1] \"phyDat\" Laurasiatherian #> 47 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  # base frequencies baseFreq(Laurasiatherian) #>         a         c         g         t  #> 0.3321866 0.1990791 0.2040652 0.2646691  # subsetting phyDat objects # the first 5 sequences subset(Laurasiatherian, subset=1:5) #> 5 sequences with 3179 character and 1605 different site patterns. #> The states are a c g t  # the first 5 characters subset(Laurasiatherian, select=1:5, site.pattern = FALSE) #> 47 sequences with 5 character and 5 different site patterns. #> The states are a c g t  # subsetting with [] Laurasiatherian[1:5, 1:20] #> 5 sequences with 20 character and 17 different site patterns. #> The states are a c g t  # short for subset(Laurasiatherian, subset=1:5, select=1:20, site.pattern = FALSE) #> 5 sequences with 20 character and 17 different site patterns. #> The states are a c g t  # the first 5 site patterns (often more than 5 characters) subset(Laurasiatherian, select=1:5, site.pattern = TRUE) #> 47 sequences with 454 character and 5 different site patterns. #> The states are a c g t   x <- matrix(c(\"a\", \"a\", \"c\", \"g\", \"c\", \"t\", \"a\", \"g\",               \"a\", \"a\", \"c\", \"g\", \"c\", \"t\", \"a\", \"g\",               \"a\", \"a\", \"c\", \"c\", \"c\", \"t\", \"t\", \"g\"), nrow=3, byrow = TRUE,             dimnames = list(c(\"t1\", \"t2\", \"t3\"), 1:8)) (y <- phyDat(x)) #> 3 sequences with 8 character and 6 different site patterns. #> The states are a c g t   subset(y, 1:2) #> 2 sequences with 8 character and 6 different site patterns. #> The states are a c g t  subset(y, 1:2, compress=TRUE) #> 2 sequences with 8 character and 4 different site patterns. #> The states are a c g t   subset(y, select=1:3, site.pattern = FALSE) |> as.character() #>    [,1] [,2] [,3] #> t1 \"a\"  \"a\"  \"c\"  #> t2 \"a\"  \"a\"  \"c\"  #> t3 \"a\"  \"a\"  \"c\"  subset(y, select=1:3, site.pattern = TRUE) |> as.character() #>    [,1] [,2] [,3] [,4] [,5] #> t1 \"a\"  \"a\"  \"c\"  \"c\"  \"g\"  #> t2 \"a\"  \"a\"  \"c\"  \"c\"  \"g\"  #> t3 \"a\"  \"a\"  \"c\"  \"c\"  \"c\"  y[,1:3] # same as subset(y, select=1:3, site.pattern = FALSE) #> 3 sequences with 3 character and 2 different site patterns. #> The states are a c g t   # Compute all possible site patterns # for nucleotides there $4 ^ (number of tips)$ patterns allSitePattern(5) #> 5 sequences with 1024 character and 1024 different site patterns. #> The states are a c g t"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot ancestral character on a tree — plotAnc","title":"Plot ancestral character on a tree — plotAnc","text":"plotAnc plots phylogeny adds character nodes. Either takes output  ancestral.pars ancestral.pml alignment node labels tree match constructed sequences alignment.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot ancestral character on a tree — plotAnc","text":"","code":"plotAnc(x, i = 1, type = \"phylogram\", ..., col = NULL, cex.pie = 0.5,   pos = \"bottomright\", scheme = NULL)  plotSeqLogo(x, node = getRoot(x$tree), start = 1, end = 10,   scheme = \"Ape_NT\", ...)  add_mutations(x, pos = NULL, frame = \"none\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot ancestral character on a tree — plotAnc","text":"x object class ancestral. plots -th site. type character string specifying type phylogeny drawn; must one \"phylogram\" (default), \"cladogram\", \"fan\", \"unrooted\", \"radial\", \"tidy\", unambiguous abbreviation . ... arguments passed methods. col vector containing colors possible states. cex.pie numeric defining size pie graphs. pos position range alignment add mutations. NULL mutations written . scheme predefined color scheme. amino acid options \"Ape_AA\", \"Zappo_AA\", \"Clustal\", \"Polarity\" \"Transmembrane_tendency\", nucleotides \"Ape_NT\" \"RY_NT\". Names can abbreviated. node plot probabilities plotted. start start position plot. end end position plot. frame character string specifying kind frame printed around text. See edgelabels.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot ancestral character on a tree — plotAnc","text":"plotAnc returns silently x. plotSeqLogo returns ggplot object. add_mutations adds position changes possible mutations phylogeny.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot ancestral character on a tree — plotAnc","text":"details see vignette(\"Ancestral\").","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot ancestral character on a tree — plotAnc","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.ancestral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot ancestral character on a tree — plotAnc","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  # generate node labels to ensure plotting will work tree <- makeNodeLabel(tree) anc.p <- anc_pars(tree, Laurasiatherian) # plot the third character plotAnc(anc.p, 3, pos=\"topright\")  plotSeqLogo(anc.p, node=\"Node10\", 1, 25)   data(chloroplast) tree <- pratchet(chloroplast,  maxit=10, trace=0) tree <- makeNodeLabel(tree) anc.ch <- anc_pars(tree, chloroplast) image(as.phyDat(anc.ch)[, 1:25])  plotAnc(anc.ch, 21, scheme=\"Ape_AA\", pos=\"topleft\")  plotAnc(anc.ch, 21, scheme=\"Clustal\", pos=\"topleft\")  plotSeqLogo(anc.ch, node=\"Node1\", 1, 25, scheme=\"Clustal\")    data(woodmouse) tree <- pml_bb(woodmouse, \"JC\", rearrangement=\"NNI\")$tree |> midpoint() #> optimize edge weights:  -1861.356 --> -1857.165  #> optimize edge weights:  -1857.165 --> -1857.165  #> optimize topology:  -1857.165 --> -1856.056  NNI moves:  2  #> optimize topology:  -1856.056 --> -1856.056  NNI moves:  0  woodmouse_aa <- trans(woodmouse, 2) |> as.phyDat() #> Warning: sequence length not a multiple of 3: 2 nucleotides dropped anc_aa <- anc_pars(tree, woodmouse_aa) plot(tree) add_mutations(anc_aa, adj = c(.5, -0.3), col=2)"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":null,"dir":"Reference","previous_headings":"","what":"plot phylogenetic networks — plot.networx","title":"plot phylogenetic networks — plot.networx","text":"far parameters behave rgl \"3D\" basic graphic \"2D\" device.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot phylogenetic networks — plot.networx","text":"","code":"# S3 method for class 'networx' plot(x, type = \"equal angle\", use.edge.length = TRUE,   show.tip.label = TRUE, show.edge.label = FALSE, edge.label = NULL,   show.node.label = FALSE, node.label = NULL, show.nodes = FALSE,   tip.color = \"black\", edge.color = \"black\", edge.width = 3,   edge.lty = 1, split.color = NULL, split.width = NULL,   split.lty = NULL, font = 3, cex = par(\"cex\"), cex.node.label = cex,   cex.edge.label = cex, col.node.label = tip.color,   col.edge.label = tip.color, font.node.label = font,   font.edge.label = font, underscore = FALSE, angle = 0, digits = 3,   ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot phylogenetic networks — plot.networx","text":"x object class \"networx\" type \"3D\" plot using rgl \"equal angle\", \"2D\" \"outline\" normal device. use.edge.length logical indicating whether use edge weights network draw branches (default) . show.tip.label logical indicating whether show tip labels graph (defaults TRUE, .e. labels shown). show.edge.label logical indicating whether show tip labels graph. edge.label additional vector edge labels (normally needed). show.node.label logical indicating whether show node labels (see example). node.label additional vector node labels (normally needed). show.nodes logical indicating whether show nodes (see example). tip.color colors used tip labels. edge.color colors used draw edges. edge.width width used draw edges. edge.lty vector line types. split.color colors used draw edges. split.width width used draw edges. split.lty vector line types. font integer specifying type font labels: 1 (plain text), 2 (bold), 3 (italic, default), 4 (bold italic). cex numeric value giving factor scaling labels. cex.node.label numeric value giving factor scaling node labels. cex.edge.label numeric value giving factor scaling edge labels. col.node.label colors used node labels. col.edge.label colors used edge labels. font.node.label font used node labels. font.edge.label font used edge labels. underscore logical specifying whether underscores tip labels written spaces (default) left (TRUE). angle rotate plot. digits edge labels numerical positive integer indicating many significant digits used. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot phylogenetic networks — plot.networx","text":"plot.networx returns invisibly list paramters plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"plot phylogenetic networks — plot.networx","text":"Often easier safer supply vectors graphical parameters splits (e.g. splits.color) edges. overwrite values edge.color.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"plot phylogenetic networks — plot.networx","text":"internal representation likely change.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"plot phylogenetic networks — plot.networx","text":"Dress, .W.M. Huson, D.H. (2004) Constructing Splits Graphs IEEE/ACM Transactions Computational Biology Bioinformatics (TCBB), 1(3), 109–115 Schliep, K., Potts, . J., Morrison, D. . Grimm, G. W. (2017), Intertwining phylogenetic trees networks. Methods Ecol Evol. 8, 1212–1220. doi:10.1111/2041-210X.12760 Bagci, C., Bryant, D., Cetinkaya, B. Huson, D.H. (2021), Microbial Phylogenetic Context Using Phylogenetic Outlines. Genome Biology Evolution. Volume 13. Issue 9. evab213","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"plot phylogenetic networks — plot.networx","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.networx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot phylogenetic networks — plot.networx","text":"","code":"set.seed(1) tree1 <- rtree(20, rooted=FALSE) sp <- as.splits(rNNI(tree1, n=10)) net <- as.networx(sp) plot(net)  plot(net, direction=\"axial\")  if (FALSE) { # \\dontrun{ # also see example in consensusNet example(consensusNet) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot phylogeny of a pml object — plot.pml","title":"Plot phylogeny of a pml object — plot.pml","text":"plot.pml wrapper around plot.phylo different default values unrooted, ultrametric tip dated phylogenies.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot phylogeny of a pml object — plot.pml","text":"","code":"# S3 method for class 'pml' plot(x, type = \"phylogram\", direction = \"rightwards\", ...,   adj = NULL, digits = 2, method = \"FBP\")"},{"path":"https://klausvigo.github.io/phangorn/reference/plot.pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot phylogeny of a pml object — plot.pml","text":"x object class pml. type character string specifying type phylogeny drawn; must one \"phylogram\" (default), \"cladogram\", \"fan\", \"unrooted\", \"radial\", \"tidy\", unambiguous abbreviation . direction character string specifying direction tree. Four values possible: \"rightwards\" (default), \"leftwards\", \"upwards\", \"downwards\". ... parameters passed plot.phylo. adj one two numeric values specifying horizontal vertical justification text symbols support values. digits integer indicating number decimal places. method either \"FBP\" classical bootstrap (default), \"TBE\" (transfer bootstrap) \"MCC\" assigning clade credibilities.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot phylogeny of a pml object — plot.pml","text":"plot.pml returns pml object x.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/plot.pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot phylogeny of a pml object — plot.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plot.pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot phylogeny of a pml object — plot.pml","text":"","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") tmp <- read.csv(file.path(fdir,\"H3N2_NA_20.csv\")) H3N2 <- read.phyDat(file.path(fdir,\"H3N2_NA_20.fasta\"), format=\"fasta\") dates <- setNames(tmp$numdate_given, tmp$name)  fit_td <- pml_bb(H3N2, model=\"JC\", method=\"tipdated\", tip.dates=dates,                  rearrangement=\"none\", control = pml.control(trace = 0)) plot(fit_td, show.tip.label = FALSE)  # Same as: # root_time <- max(dates) - max(node.depth.edgelength(fit_td$tree)) # plot(fit_td$tree, show.tip.label = FALSE) # axisPhylo(root.time = root_time, backward = FALSE) plot(fit_td, show.tip.label = FALSE, direction=\"up\")   fit_unrooted <- pml_bb(H3N2, model=\"JC\", rearrangement=\"none\",                        control = pml.control(trace = 0)) plot(fit_unrooted, cex=.5)"},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":null,"dir":"Reference","previous_headings":"","what":"Plotting trees with bootstrap values — plotBS","title":"Plotting trees with bootstrap values — plotBS","text":"plotBS plots phylogenetic tree bootstrap values assigned (internal) edges. can also used assign bootstrap values phylogenetic tree. add_support adds support values plot.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plotting trees with bootstrap values — plotBS","text":"","code":"plotBS(tree, trees, type = \"phylogram\", method = \"FBP\", bs.col = \"black\",   bs.adj = NULL, digits = 3, p = 0, frame = \"none\", tol = 1e-06,   sep = \"/\", ...)  add_support(tree, trees, method = \"FBP\", tol = 1e-08, scale = TRUE,   frame = \"none\", digits = 3, sep = \"/\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plotting trees with bootstrap values — plotBS","text":"tree tree edges bootstrap values plotted. trees list trees (object class \"multiPhylo\"). type type tree plot, one \"phylogram\", \"cladogram\", \"fan\", \"unrooted\", \"radial\" \"none\". type \"none\" tree returned bootstrap values assigned node labels. method either \"FBP\" classical bootstrap (default), \"TBE\" (transfer bootstrap) \"MCC\" assigning clade credibilities. case \"MCC\" trees need rooted. bs.col color bootstrap support labels. bs.adj one two numeric values specifying horizontal vertical justification bootstrap labels. digits integer indicating number decimal places. p plot support values higher percentage number (default 0). frame character string specifying kind frame printed around bootstrap values. must one \"none\" (default), \"rect\" \"circle\". tol numeric value giving tolerance consider branch length significantly greater zero. sep seperator different methods. ... parameters used plot.phylo. scale return ratio percentage.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plotting trees with bootstrap values — plotBS","text":"plotBS returns silently tree, .e. object class phylo bootstrap values node labels. argument trees optional supplied labels supplied node.label slot used.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plotting trees with bootstrap values — plotBS","text":"functions can either assign classical Felsenstein’s bootstrap proportions (FBP) (Felsenstein (1985), Hendy & Penny (1985))  transfer bootstrap expectation (TBE) Lemoine et al. (2018). Using option type==\"n\" just assigns bootstrap values return tree without plotting .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plotting trees with bootstrap values — plotBS","text":"Felsenstein J. (1985) Confidence limits phylogenies. approach using bootstrap. Evolution 39, 783–791 Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D., De Oliveira, T., & Gascuel, O. (2018). Renewing Felsenstein’s phylogenetic bootstrap era big data. Nature, 556(7702), 452–456. Penny D. Hendy M.D. (1985) Testing methods evolutionary tree construction. Cladistics 1, 266–278 Penny D. Hendy M.D. (1986) Estimating reliability evolutionary trees. Molecular Biology Evolution 3, 403–417","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plotting trees with bootstrap values — plotBS","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/plotBS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plotting trees with bootstrap values — plotBS","text":"","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") # RAxML best-known tree with bipartition support (from previous analysis) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bipartitions.woodmouse\")) # RAxML bootstrap trees (from previous analysis) raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.woodmouse\")) par(mfrow=c(1,2)) plotBS(raxml.tree,  raxml.bootstrap, \"p\") plotBS(raxml.tree,  raxml.bootstrap, \"p\", \"TBE\")"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":null,"dir":"Reference","previous_headings":"","what":"Auxiliary for Controlling Fitting — pml.control","title":"Auxiliary for Controlling Fitting — pml.control","text":"Auxiliary functions providing optim.pml, pml_bb fitting. Use construct control ratchet.par argument.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Auxiliary for Controlling Fitting — pml.control","text":"","code":"pml.control(epsilon = 1e-08, maxit = 10, trace = 1, tau = 1e-08,   statefreq = \"empirical\")  ratchet.control(iter = 20L, maxit = 200L, minit = 100L, prop = 1/2,   rell = TRUE, bs = 1000L)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Auxiliary for Controlling Fitting — pml.control","text":"epsilon Stop criterion optimization (see details). maxit Maximum number iterations (see details). trace Show output optimization (see details). tau minimal edge length. statefreq take \"empirical\" \"estimate\" state frequencies. iter Number iterations stop change. minit Minimum number iterations. prop used rearrangement=stochastic. many NNI moves added tree proportion number taxa.´ rell logical, TRUE approximate bootstraping similar Minh et al. (2013) performed. bs number approximate bootstrap samples.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Auxiliary for Controlling Fitting — pml.control","text":"list components named arguments controlling fitting process.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Auxiliary for Controlling Fitting — pml.control","text":"pml.control controls fitting process. epsilon maxit defined outer loop, affects pmlCluster, pmlPart pmlMix. epsilon absolute difference , instead defined (logLik(k)-logLik(k+1))/logLik(k+1). seems good compromise work reasonably well small large trees alignments. trace set zero put shown, functions called internally trace decreased one, higher trace produces feedback. can useful figure long run take debugging. statefreq controls base/state frequencies optimized empirical estimates taken, applies. nucleotide models (e.g. JC, SYM) equal base frequencies amino acid models precomputed state frequencies used, '+F' specified. tau might exactly zero duplicated sequences alignment observed. case analysis performed unique sequences duplicated taxa added tree zero edge length. may lead multifurcations three identical sequences. optimization good practice prune away edges length tau using di2multi. See also Janzen et al. (2021).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Auxiliary for Controlling Fitting — pml.control","text":"Minh, B. Q., Nguyen, M. . T., & von Haeseler, . (2013). Ultrafast approximation phylogenetic bootstrap. Molecular biology evolution, 30(5), 1188-1195. Janzen, T., Bokma, F.,Etienne,  R. S. (2021) Nucleotide Substitutions Speciation may Explain Substitution Rate Variation, Systematic Biology, 71(5), 1244–1254.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Auxiliary for Controlling Fitting — pml.control","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.control.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Auxiliary for Controlling Fitting — pml.control","text":"","code":"pml.control() #> $epsilon #> [1] 1e-08 #>  #> $maxit #> [1] 10 #>  #> $trace #> [1] 1 #>  #> $tau #> [1] 1e-08 #>  #> $statefreq #> [1] \"empirical\" #>  pml.control(maxit=25) #> $epsilon #> [1] 1e-08 #>  #> $maxit #> [1] 25 #>  #> $trace #> [1] 1 #>  #> $tau #> [1] 1e-08 #>  #> $statefreq #> [1] \"empirical\" #>"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal maximum likelihood functions. — lli","title":"Internal maximum likelihood functions. — lli","text":"functions internally used likelihood computations pml optim.pml.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal maximum likelihood functions. — lli","text":"","code":"lli(data, tree = NULL, ...)  pml.fit(tree, data, bf = rep(1/length(levels), length(levels)), shape = 1,   k = 1, Q = rep(1, length(levels) * (length(levels) - 1)/2),   levels = attr(data, \"levels\"), inv = 0, rate = 1, g = NULL,   w = NULL, eig = NULL, INV = NULL, ll.0 = NULL, llMix = NULL,   wMix = 0, ..., site = FALSE, ASC = FALSE, site.rate = \"gamma\")"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal maximum likelihood functions. — lli","text":"data alignment, object class phyDat. tree phylogenetic tree, object class phylo. ... arguments passed methods. bf Base frequencies. shape Shape parameter gamma distribution. k Number intervals discrete gamma distribution. Q vector containing lower triangular part rate matrix. levels alphabet used e.g. c(\"\", \"c\", \"g\", \"t\") DNA inv Proportion invariable sites. rate Rate. g vector quantiles (default NULL) w vector probabilities (default NULL) eig Eigenvalue decomposition Q INV Sparse representation invariant sites ll.0 default NULL llMix default NULL wMix default NULL site return log-likelihood vector sitewise likelihood values ASC ascertainment bias correction (ASC), allows estimate models like Lewis' Mkv. site.rate Indicates type gamma distribution use. Options \"gamma\" approach Yang 1994 (default), \"gamma_quadrature\" Laguerre quadrature approach Felsenstein 2001 \"freerate\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal maximum likelihood functions. — lli","text":"pml.fit returns log-likelihood.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Internal maximum likelihood functions. — lli","text":"functions exported used different packages far package coalescentMCMC, intended end user. functions call C code far less forgiving import expect pml.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Internal maximum likelihood functions. — lli","text":"Felsenstein, J. (1981) Evolutionary trees DNA sequences: maximum likelihood approach. Journal Molecular Evolution, 17, 368–376.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Internal maximum likelihood functions. — lli","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Internal maximum likelihood functions. — lli","text":"","code":"data(Laurasiatherian) tree <- NJ(dist.ml(Laurasiatherian)) bf <- rep(0.25, 4) eig <- edQt() pml.init(Laurasiatherian) #> NULL pml.fit(tree, Laurasiatherian, bf=bf, eig=eig) #> [1] -54808.83 pml.free() #> NULL pml(tree, Laurasiatherian) |> logLik() #> 'log Lik.' -54808.83 (df=91)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of a tree. — as.pml","title":"Likelihood of a tree. — as.pml","text":"pml computes likelihood phylogenetic tree given sequence alignment model. optim.pml optimizes different model parameters. user-friendly interface see pml_bb.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of a tree. — as.pml","text":"","code":"as.pml(x, ...)  pml(tree, data, bf = NULL, Q = NULL, inv = 0, k = 1, shape = 1,   rate = 1, model = NULL, site.rate = \"gamma\", ASC = FALSE, ...)  optim.pml(object, optNni = FALSE, optBf = FALSE, optQ = FALSE,   optInv = FALSE, optGamma = FALSE, optEdge = TRUE, optRate = FALSE,   optRooted = FALSE, control = pml.control(), model = NULL,   rearrangement = ifelse(optNni, \"NNI\", \"none\"), subs = NULL,   ratchet.par = ratchet.control(), ...)  # S3 method for class 'pml' logLik(object, ...)  # S3 method for class 'pml' anova(object, ...)  # S3 method for class 'pml' vcov(object, ...)  # S3 method for class 'pml' print(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of a tree. — as.pml","text":"x far object class modelTest. ... arguments passed methods. tree phylogenetic tree, object class phylo. data alignment, object class phyDat. bf Base frequencies (see details). Q vector containing lower triangular part rate matrix. inv Proportion invariable sites. k Number intervals discrete gamma distribution. shape Shape parameter gamma distribution. rate Rate. model allows choose amino acid models nucleotide model, see details. site.rate Indicates type gamma distribution use. Options \"gamma\" approach Yang 1994 (default), \"\"gamma_quadrature\"\" Laguerre quadrature approach Felsenstein 2001 \"freerate\". ASC ascertainment bias correction (ASC), allows estimate models like Lewis' Mkv. object object class pml. optNni Logical value indicating whether topology gets optimized (NNI). optBf Logical value indicating whether base frequencies gets optimized. optQ Logical value indicating whether rate matrix gets optimized. optInv Logical value indicating whether proportion variable size gets optimized. optGamma Logical value indicating whether gamma rate parameter gets optimized. optEdge Logical value indicating edge lengths gets optimized. optRate Logical value indicating overall rate gets optimized. optRooted Logical value indicating edge lengths rooted tree get optimized. control list parameters controlling fitting process. rearrangement type tree tree rearrangements perform, one \"none\", \"NNI\", \"stochastic\" \"ratchet\" subs (integer) vector length Q specify optimization Q ratchet.par search parameter stochastic search","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of a tree. — as.pml","text":"pml optim.pml return list class pml, useful computations like tree phylogenetic tree. data alignment. logLik Log-likelihood tree. siteLik Site log-likelihoods. weight Weight site patterns.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood of a tree. — as.pml","text":"Base frequencies pml can supplied different ways. amino acid usually defined specifying model, argument bf need specified. Otherwise bf=NULL, state given equal probability. can numeric vector given frequencies. Last least bf can string \"equal\", \"empirical\" codon models additionally \"F3x4\". topology search uses nearest neighbor interchange (NNI) implementation similar phyML.  option model pml used amino acid models.  option model defines nucleotide model getting optimized, models included modeltest can chosen. Setting option (e.g. \"K81\" \"GTR\") overrules options optBf optQ.  overview estimate different phylogenetic models pml: Via model optim.pml following nucleotide models can specified: JC, F81, K80, HKY, TrNe, TrN, TPM1, K81, TPM1u, TPM2, TPM2u, TPM3, TPM3u, TIM1e, TIM1, TIM2e, TIM2, TIM3e, TIM3, TVMe, TVM, SYM GTR.  models specified Posada (2008). far 17 amino acid models supported (\"WAG\", \"JTT\", \"LG\", \"Dayhoff\", \"cpREV\", \"mtmam\", \"mtArt\", \"MtZoa\", \"mtREV24\", \"VT\",\"RtREV\", \"HIVw\", \"HIVb\", \"FLU\", \"Blosum62\", \"Dayhoff_DCMut\" \"JTT_DCMut\") additionally rate matrices amino acid frequencies can supplied. also possible estimate codon models (e.g. YN98), details see also chapter vignette(\"phangorn-specials\"). option 'optRooted' set TRUE edge lengths rooted tree optimized. tree rooted now ultrametric! Optimising rooted trees generally much slower. rearrangement set stochastic stochastic search algorithm similar Nguyen et al. (2015). ratchet likelihood ratchet Vos (2003).  helps often find better tree topologies, especially larger trees.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Likelihood of a tree. — as.pml","text":"Felsenstein, J. (1981) Evolutionary trees DNA sequences: maximum likelihood approach. Journal Molecular Evolution, 17, 368–376. Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland. Yang, Z. (2006). Computational Molecular evolution. Oxford University Press, Oxford. Adachi, J., P. J. Waddell, W. Martin, M. Hasegawa (2000) Plastid genome phylogeny model amino acid substitution proteins encoded chloroplast DNA.  Journal Molecular Evolution, 50, 348–358 Rota-Stabelli, O., Z. Yang, M. Telford. (2009) MtZoa: general mitochondrial amino acid substitutions model animal evolutionary studies. Mol. Phyl. Evol, 52(1), 268–72 Whelan, S. Goldman, N. (2001) general empirical model protein evolution derived multiple protein families using maximum-likelihood approach. Molecular Biology Evolution, 18, 691–699 Le, S.Q. Gascuel, O. (2008) LG: Improved, General Amino-Acid Replacement Matrix Molecular Biology Evolution, 25(7), 1307–1320 Yang, Z., R. Nielsen, M. Hasegawa (1998) Models amino acid substitution applications Mitochondrial protein evolution. Molecular Biology Evolution, 15, 1600–1611 Abascal, F., D. Posada, R. Zardoya (2007) MtArt: new Model amino acid replacement Arthropoda. Molecular Biology Evolution, 24, 1–5 Kosiol, C, Goldman, N (2005) Different versions Dayhoff rate matrix - Molecular Biology Evolution, 22, 193–199 L.-T. Nguyen, H.. Schmidt, . von Haeseler, B.Q. Minh (2015) IQ-TREE: fast effective stochastic algorithm estimating maximum likelihood phylogenies. Molecular Biology Evolution, 32, 268–274. Vos, R. . (2003) Accelerated Likelihood Surface Exploration: Likelihood Ratchet. Systematic Biology, 52(3), 368–373 Yang, Z., R. Nielsen (1998) Synonymous nonsynonymous rate variation nuclear genes mammals. Journal Molecular Evolution, 46, 409-418. Lewis, P.O. (2001) likelihood approach estimating phylogeny discrete morphological character data. Systematic Biology 50, 913–925.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood of a tree. — as.pml","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood of a tree. — as.pml","text":"","code":"example(NJ) #>  #> NJ> data(Laurasiatherian) #>  #> NJ> dm <- dist.ml(Laurasiatherian) #>  #> NJ> tree <- NJ(dm) #>  #> NJ> plot(tree)  # Jukes-Cantor (starting tree from NJ)   fitJC <- pml(tree, Laurasiatherian) # optimize edge length parameter   fitJC <- optim.pml(fitJC) #> optimize edge weights:  -54808.83 --> -54230.41  #> optimize edge weights:  -54230.41 --> -54230.41  #> optimize edge weights:  -54230.41 --> -54230.41    fitJC #> model: JC  #> loglikelihood: -54230.41  #> unconstrained loglikelihood: -17300.92  #>  #> Rate matrix: #>   a c g t #> a 0 1 1 1 #> c 1 0 1 1 #> g 1 1 0 1 #> t 1 1 1 0 #>  #> Base frequencies:   #>    a    c    g    t  #> 0.25 0.25 0.25 0.25   if (FALSE) { # \\dontrun{ # search for a better tree using NNI rearrangements   fitJC <- optim.pml(fitJC, optNni=TRUE)   fitJC   plot(fitJC$tree)  # JC + Gamma + I - model   fitJC_GI <- update(fitJC, k=4, inv=.2) # optimize shape parameter + proportion of invariant sites   fitJC_GI <- optim.pml(fitJC_GI, optGamma=TRUE, optInv=TRUE) # GTR + Gamma + I - model   fitGTR <- optim.pml(fitJC_GI, rearrangement = \"stochastic\",       optGamma=TRUE, optInv=TRUE, model=\"GTR\") } # }   # 2-state data (RY-coded)   dat <- acgt2ry(Laurasiatherian)   fit2ST <- pml(tree, dat)   fit2ST <- optim.pml(fit2ST,optNni=TRUE) #> optimize edge weights:  -19749.4 --> -17092.17  #> optimize edge weights:  -17092.17 --> -17092.17  #> optimize topology:  -17092.17 --> -17024.81  NNI moves:  10  #> optimize edge weights:  -17024.81 --> -17024.81  #> optimize topology:  -17024.81 --> -17024.81  NNI moves:  0    fit2ST #> model: Mk  #> loglikelihood: -17024.81  #> unconstrained loglikelihood: -8702.769  #>  #> Rate matrix: #>   r y #> r 0 1 #> y 1 0 #>  #> Base frequencies:   #>   r   y  #> 0.5 0.5  # show some of the methods available for class pml   methods(class=\"pml\") #>  [1] AICc   BIC    anova  glance logLik plot   print  simSeq update vcov   #> see '?methods' for accessing help and source code"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Partitioning — pmlCluster","title":"Stochastic Partitioning — pmlCluster","text":"Stochastic Partitioning genes p cluster.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Partitioning — pmlCluster","text":"","code":"pmlCluster(formula, fit, weight, p = 1:5, part = NULL, nrep = 10,   control = pml.control(epsilon = 1e-08, maxit = 10, trace = 1), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Partitioning — pmlCluster","text":"formula formula object (see details). fit object class pml. weight weight matrix frequency site patterns genes. p number clusters. part starting partition, otherwise random partition generated. nrep number replicates p. control list parameters controlling fitting process. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stochastic Partitioning — pmlCluster","text":"pmlCluster returns list elements logLik log-likelihood fit trees list trees optimization. fits fits final partitions","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Stochastic Partitioning — pmlCluster","text":"formula object allows specify parameter get optimized. formula generally form edge + bf + Q ~ rate + shape + ...{}, left side parameters get optimized cluster, right parameter optimized specific cluster. parameters available \"nni\", \"bf\", \"Q\", \"inv\", \"shape\", \"edge\", \"rate\".  parameter can used formula.  also restriction combinations parameters can get used. \"rate\" available right side.  \"rate\" specified left hand side \"edge\" specified (either side), \"rate\" specified right hand side follows directly edge .","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stochastic Partitioning — pmlCluster","text":"K. P. Schliep (2009). Applications statistical phylogenetics (PhD Thesis) Lanfear, R., Calcott, B., Ho, S.Y.W. Guindon, S. (2012) PartitionFinder: Combined Selection Partitioning Schemes Substitution Models Phylogenetic Analyses. Molecular Biology Evolution, 29(6), 1695-1701","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Stochastic Partitioning — pmlCluster","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlCluster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stochastic Partitioning — pmlCluster","text":"","code":"if (FALSE) { # \\dontrun{ data(yeast) dm <- dist.logDet(yeast) tree <- NJ(dm) fit <- pml(tree,yeast) fit <- optim.pml(fit)  weight <- xtabs(~ index+genes,attr(yeast, \"index\")) set.seed(1)  sp <- pmlCluster(edge~rate, fit, weight, p=1:4) sp SH.test(sp) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":null,"dir":"Reference","previous_headings":"","what":"Phylogenetic mixture model — pmlMix","title":"Phylogenetic mixture model — pmlMix","text":"Phylogenetic mixture model.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Phylogenetic mixture model — pmlMix","text":"","code":"pmlMix(formula, fit, m = 2, omega = rep(1/m, m),   control = pml.control(epsilon = 1e-08, maxit = 20, trace = 1), ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Phylogenetic mixture model — pmlMix","text":"formula formula object (see details). fit object class pml. m number mixtures. omega mixing weights. control list parameters controlling fitting process. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Phylogenetic mixture model — pmlMix","text":"pmlMix returns list elements logLik log-likelihood fit omega mixing weights. fits fits final mixtures.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Phylogenetic mixture model — pmlMix","text":"formula object allows specify parameter get optimized. formula generally form edge + bf + Q ~ rate + shape + ...{}, left side parameters get optimized mixtures, right parameter optimized specific mixture. parameters available \"nni\", \"bf\", \"Q\", \"inv\", \"shape\", \"edge\", \"rate\".  parameters can used formula.  \"rate\" \"nni\" available right side formula. hand parameters invariable sites allowed left-hand side.  convergence algorithm slow likely algorithm can get stuck local optima.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Phylogenetic mixture model — pmlMix","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlMix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Phylogenetic mixture model — pmlMix","text":"","code":"if (FALSE) { # \\dontrun{ X <- allSitePattern(5) tree <- read.tree(text = \"((t1:0.3,t2:0.3):0.1,(t3:0.3,t4:0.3):0.1,t5:0.5);\") fit <- pml(tree,X, k=4) weights <- 1000*exp(fit$siteLik) attr(X, \"weight\") <- weights fit1 <- update(fit, data=X, k=1) fit2 <- update(fit, data=X)  (fitMixture <- pmlMix(edge~rate, fit1 , m=4)) (fit2 <- optim.pml(fit2, optGamma=TRUE))   data(Laurasiatherian) dm <- dist.logDet(Laurasiatherian) tree <- NJ(dm) fit <- pml(tree, Laurasiatherian) fit <- optim.pml(fit)  fit2 <- update(fit, k=4) fit2 <- optim.pml(fit2, optGamma=TRUE)  fitMix <- pmlMix(edge ~ rate, fit, m=4) fitMix   # # simulation of mixture models # X <- allSitePattern(5) tree1 <- read.tree(text = \"((t1:0.1,t2:0.5):0.1,(t3:0.1,t4:0.5):0.1,t5:0.5);\") tree2 <- read.tree(text = \"((t1:0.5,t2:0.1):0.1,(t3:0.5,t4:0.1):0.1,t5:0.5);\") tree1 <- unroot(tree1) tree2 <- unroot(tree2) fit1 <- pml(tree1,X) fit2 <- pml(tree2,X)  weights <- 2000*exp(fit1$siteLik) + 1000*exp(fit2$siteLik) attr(X, \"weight\") <- weights  fit1 <- pml(tree1, X) fit2 <- optim.pml(fit1) logLik(fit2) AIC(fit2, k=log(3000))  fitMixEdge <- pmlMix( ~ edge, fit1, m=2) logLik(fitMixEdge) AIC(fitMixEdge, k=log(3000))  fit.p <- pmlPen(fitMixEdge, .25) logLik(fit.p) AIC(fit.p, k=log(3000)) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition model. — multiphyDat2pmlPart","title":"Partition model. — multiphyDat2pmlPart","text":"Model estimate phylogenies partitioned data.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition model. — multiphyDat2pmlPart","text":"","code":"multiphyDat2pmlPart(x, method = \"unrooted\", tip.dates = NULL, ...)  pmlPart2multiPhylo(x)  pmlPart(formula, object, control = pml.control(epsilon = 1e-08, maxit = 10,   trace = 1), model = NULL, method = \"unrooted\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition model. — multiphyDat2pmlPart","text":"x object class pmlPart method One \"unrooted\", \"ultrametric\" \"tiplabeled\". unrooted properly supported right now. tip.dates named vector sampling times associated tips/sequences. Leave empty estimating tip dated phylogenies. ... arguments passed methods. formula formula object (see details). object object class pml list objects class pml . control list parameters controlling fitting process. model vector containing models containing model partition.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition model. — multiphyDat2pmlPart","text":"kcluster returns list elements logLik log-likelihood fit trees list trees optimization. object object class \"pml\" \"pmlPart\"","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Partition model. — multiphyDat2pmlPart","text":"formula object allows specify parameter get optimized. formula generally form edge + bf + Q ~ rate + shape + ...{}, left side parameters get optimized partitions, right parameter optimized specific partition. parameters available \"nni\", \"bf\", \"Q\", \"inv\", \"shape\", \"edge\", \"rate\".  parameters can used formula.  \"rate\" available right side formula. partitions different edge weights, topology, pmlPen can try find parsimonious models (see example). pmlPart2multiPhylo convenience function extract trees pmlPart object.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Partition model. — multiphyDat2pmlPart","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pmlPart.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partition model. — multiphyDat2pmlPart","text":"","code":"data(yeast) dm <- dist.logDet(yeast) tree <- NJ(dm) fit <- pml(tree,yeast) fits <- optim.pml(fit) #> optimize edge weights:  -737063 --> -734615.7  #> optimize edge weights:  -734615.7 --> -734615.7  #> optimize edge weights:  -734615.7 --> -734615.7   weight=xtabs(~ index+genes,attr(yeast, \"index\"))[,1:10]  sp <- pmlPart(edge ~ rate + inv, fits, weight=weight) #> loglik: -61530.38 --> -59834.29  #> loglik: -59834.29 --> -59833.25  #> loglik: -59833.25 --> -59833.25  #> loglik: -59833.25 --> -59833.25  sp #>  #> loglikelihood: -59833.25  #>  #> loglikelihood of partitions: #>   -9827.497 -8159.024 -8056.932 -5237.677 -3809.733 -5503.277 -2752.2 -7200.052 -4632.422 -4654.434  #> AIC:  119730.5  BIC:  119963.5  #>  #> Proportion of invariant sites: 0.400014 0.3179422 0.4746719 0.44901 0.412222 0.2912371 0.2419212 0.3097902 0.4794213 0.3884183  #>  #> Rates: #> 1.108054 0.9656349 0.8692647 0.8928479 0.8097379 1.266643 1.296063 1.212791 0.842597 0.8275076  #>  #> Base frequencies:   #>      [,1] [,2] [,3] [,4] #> [1,] 0.25 0.25 0.25 0.25 #>  #> Rate matrix: #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    1    1    1    1    1  if (FALSE) { # \\dontrun{ sp2 <- pmlPart(~ edge + inv, fits, weight=weight) sp2 AIC(sp2)  sp3 <- pmlPen(sp2, lambda = 2) AIC(sp3) } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood of a tree. — pml_bb","title":"Likelihood of a tree. — pml_bb","text":"pml_bb pml black box infers phylogenetic tree infers tree using maximum likelihood (ML).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood of a tree. — pml_bb","text":"","code":"pml_bb(x, model = NULL, rearrangement = \"stochastic\",   method = \"unrooted\", start = NULL, tip.dates = NULL, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood of a tree. — pml_bb","text":"x alignment class (either class phyDat, DNAbin AAbin) object class modelTest. model string providing model (e.g. \"GTR+G(4)+\"). necessary modelTest object supplied. rearrangement Type tree tree rearrangements perform, one \"none\", \"NNI\", \"stochastic\" \"ratchet\" method One \"unrooted\", \"ultrametric\" \"tiplabeled\". start starting tree can supplied. tip.dates named vector sampling times associated tips / sequences. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood of a tree. — pml_bb","text":"pml_bb returns object class pml.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood of a tree. — pml_bb","text":"pml_bb convenience function combining pml optim.pml. tree supplied, function generate starting tree. modelTest object supplied model chosen according BIC. tip.dates named vector sampling times, time unit, time increasing toward present. example, may units “days since study start” “years since 10,000 BCE”, “millions years ago”. model takes string tries extract model. modelTest object best BIC model chosen default. string contain substitution model (e.g. JC, GTR, WAG) can additional  term \"+\" invariant sites, \"+G(4)\" discrete gamma model, \"+R(4)\" free rate model. case amino acid models term \"+F\" estimating amino acid frequencies. Whether nucleotide frequencies estimated defined pml.control. Currently experimental likely change.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood of a tree. — pml_bb","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/pml_bb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood of a tree. — pml_bb","text":"","code":"data(woodmouse) tmp <- pml_bb(woodmouse, model=\"HKY+I\", rearrangement=\"NNI\") #> optimize edge weights:  -1812.646 --> -1810.473  #> optimize rate matrix:  -1810.473 --> -1758.757  #> optimize invariant sites:  -1758.757 --> -1744.355  #> optimize edge weights:  -1744.355 --> -1744.199  #> optimize topology:  -1744.199 --> -1744.199  NNI moves:  0  #> optimize rate matrix:  -1744.199 --> -1744.186  #> optimize invariant sites:  -1744.186 --> -1744.186  #> optimize edge weights:  -1744.186 --> -1744.186  #> optimize rate matrix:  -1744.186 --> -1744.186  #> optimize invariant sites:  -1744.186 --> -1744.186  #> optimize edge weights:  -1744.186 --> -1744.186   if (FALSE) { # \\dontrun{ data(Laurasiatherian) mt <- modelTest(Laurasiatherian) fit <- pml_bb(mt)  # estimate free rate model with 2 rate categories fit_HKY_R2 <- pml_bb(woodmouse, model=\"HKY+R(2)\") } # }"},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.partitions.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to import partitioned data from nexus files — read.nexus.partitions","title":"Function to import partitioned data from nexus files — read.nexus.partitions","text":"read.nexus.partitions reads sequences NEXUS format splits data according charsets given SETS block.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.partitions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to import partitioned data from nexus files — read.nexus.partitions","text":"","code":"read.nexus.partitions(file, return = \"list\", ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.partitions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to import partitioned data from nexus files — read.nexus.partitions","text":"file file name. return either returns list element 'phyDat' object object class 'multiphyDat' ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.partitions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to import partitioned data from nexus files — read.nexus.partitions","text":"list element 'phyDat' object object class 'multiphyDat'.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.partitions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to import partitioned data from nexus files — read.nexus.partitions","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.partitions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to import partitioned data from nexus files — read.nexus.partitions","text":"","code":"tree <- rtree(10) dat <- simSeq(tree, l=24) fcat <- function(..., file = zz) cat(..., file=file, sep=\"\", append=TRUE) zz <- tempfile(pattern=\"file\", tmpdir=tempdir(), fileext=\".nex\") write.phyDat(dat, file=zz, format=\"nexus\") fcat(\"BEGIN SETS;\\n\") fcat(\"  Charset codon1 = 1-12/3;\\n\") fcat(\"  Charset codon2 = 2-12/3;\\n\") fcat(\"  Charset codon3 = 3-12/3;\\n\") fcat(\"  Charset range = 16-18;\\n\") fcat(\"  Charset range2 = 13-15 19-21;\\n\") fcat(\"  Charset singles = 22 23 24;\\n\") fcat(\"END;\\n\")  tmp <- read.nexus.partitions(zz) tmp #> $codon1 #> 10 sequences with 4 character and 4 different site patterns. #> The states are a c g t  #>  #> $codon2 #> 10 sequences with 4 character and 4 different site patterns. #> The states are a c g t  #>  #> $codon3 #> 10 sequences with 4 character and 4 different site patterns. #> The states are a c g t  #>  #> $range #> 10 sequences with 3 character and 3 different site patterns. #> The states are a c g t  #>  #> $range2 #> 10 sequences with 6 character and 6 different site patterns. #> The states are a c g t  #>  #> $singles #> 10 sequences with 3 character and 3 different site patterns. #> The states are a c g t  #>  unlink(zz)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to import and export splits and networks — read.nexus.splits","title":"Function to import and export splits and networks — read.nexus.splits","text":"read.nexus.splits, write.nexus.splits, read.nexus.networx, write.nexus.networx can used import export splits networks nexus format allow exchange object software like SplitsTree. write.splits returns human readable output.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to import and export splits and networks — read.nexus.splits","text":"","code":"read.nexus.splits(file)  write.nexus.splits(obj, file = \"\", weights = NULL, taxa = TRUE,   append = FALSE)  write.nexus.networx(obj, file = \"\", taxa = TRUE, splits = TRUE,   append = FALSE)  read.nexus.networx(file, splits = TRUE)  write.splits(x, file = \"\", zero.print = \".\", one.print = \"|\",   print.labels = TRUE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to import and export splits and networks — read.nexus.splits","text":"file file name. obj object class splits. weights Edge weights. taxa logical. TRUE taxa block added append logical. TRUE nexus blocks added file. splits logical. TRUE nexus blocks added file. x object class splits. zero.print character printed zeros. one.print character printed ones. print.labels logical. TRUE labels printed. ... arguments passed methods. labels names taxa.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to import and export splits and networks — read.nexus.splits","text":"write.nexus.splits write.nexus.networx write splits networx object read software like SplitsTree. read.nexus.splits read.nexus.networx return splits networx object.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Function to import and export splits and networks — read.nexus.splits","text":"read.nexus.splits reads splits block nexus file. assumes different co-variables tab delimited bipartition separated white-space. Comments square brackets ignored.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to import and export splits and networks — read.nexus.splits","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.nexus.splits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to import and export splits and networks — read.nexus.splits","text":"","code":"(sp <- as.splits(rtree(5))) #>       t4 t1 t2 t3 t5 #>  [1,]  |  .  .  .  . #>  [2,]  .  |  .  .  . #>  [3,]  .  .  |  .  . #>  [4,]  .  .  .  |  . #>  [5,]  .  .  .  .  | #>  [6,]  |  |  |  |  | #>  [7,]  .  |  |  |  | #>  [8,]  .  .  |  |  | #>  [9,]  .  .  |  |  . write.nexus.splits(sp) #> #NEXUS #>  #> [Splits block for Spectronet or SplitsTree] #> [generated by phangorn 2.12.1.3 ] #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=5; #> \tTAXLABELS t4 t1 t2 t3 t5 ; #> END; #>  #> BEGIN SPLITS; #> \tDIMENSIONS ntax=5 nsplits=8; #> \tFORMAT labels=left weights=yes confidences=no intervals=no; #> \tMATRIX #> \t\t1\t0.234915791545063 \t1, #> \t\t2\t0.264620627742261 \t1 3 4 5, #> \t\t3\t0.0627861295361072 \t1 2 4 5, #> \t\t4\t0.397706091869622 \t1 2 3 5, #> \t\t5\t0.490028424886987 \t1 2 3 4, #> \t\t6\t0.021011842880398 \t1, #> \t\t7\t0.691801619483158 \t1 2, #> \t\t8\t0.0346693911124021 \t1 2 5, #> \t; #> END; spl <- allCircularSplits(5) plot(as.networx(spl))  write.splits(spl, print.labels = FALSE) #>  #>  #>  |....  #>  #>  .|...  #>  #>  ..|..  #>  #>  ...|.  #>  #>  ....|  #>  #>  ||...  #>  #>  .||..  #>  #>  ..||.  #>  #>  ...||  #>  #>  |...|"},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":null,"dir":"Reference","previous_headings":"","what":"Import and export sequence alignments — read.phyDat","title":"Import and export sequence alignments — read.phyDat","text":"functions read write sequence alignments.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Import and export sequence alignments — read.phyDat","text":"","code":"read.phyDat(file, format = \"phylip\", type = \"DNA\", ...)  write.phyDat(x, file, format = \"phylip\", colsep = \"\", nbcol = -1, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Import and export sequence alignments — read.phyDat","text":"file file name specified either variable mode character, double-quoted string. format File format sequence alignment (see details).  Several popular formats supported: \"phylip\", \"interleaved\", \"sequential\", \"clustal\", \"fasta\" \"nexus\", unambiguous abbreviation . type Type sequences (\"DNA\", \"AA\", \"CODON\" \"USER\"). ... arguments passed methods. x object class phyDat. colsep character used separate columns (single space default). nbcol numeric specifying number columns per row (-1 default); may negative implying nucleotides printed single line.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Import and export sequence alignments — read.phyDat","text":"read.phyDat returns object class phyDat, write.phyDat write alignment file.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Import and export sequence alignments — read.phyDat","text":"write.phyDat calls function write.dna write.nexus.data read.phyDat calls function read.dna read.nexus.data, see details . may import data directly read.dna read.nexus.data convert data class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Import and export sequence alignments — read.phyDat","text":"Anonymous. FASTA format description. https://www.ncbi.nlm.nih.gov/blast/fasta.shtml Felsenstein, J. (1993) Phylip (Phylogeny Inference Package) version 3.5c. Department Genetics, University Washington. https://phylipweb.github.io/phylip/","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Import and export sequence alignments — read.phyDat","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/read.phyDat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Import and export sequence alignments — read.phyDat","text":"","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") primates <- read.phyDat(file.path(fdir, \"primates.dna\"),                         format = \"interleaved\")"},{"path":"https://klausvigo.github.io/phangorn/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics glance","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate sequences. — simSeq","title":"Simulate sequences. — simSeq","text":"Simulate sequences given evolutionary tree pml object.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate sequences. — simSeq","text":"","code":"simSeq(x, ...)  # S3 method for class 'phylo' simSeq(x, l = 1000, Q = NULL, bf = NULL,   rootseq = NULL, type = \"DNA\", model = NULL, levels = NULL,   rate = 1, ancestral = FALSE, code = 1, ...)  # S3 method for class 'pml' simSeq(x, ancestral = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate sequences. — simSeq","text":"x phylogenetic tree tree edge lengths, .e. object class phylo object class pml. ... arguments passed methods. l length sequence simulate. Q Either numeric matrix size Nstates × Nstates, giving transition rates states vector representing lower triangular matrix (see details). bf Base frequencies. rootseq vector length l containing root sequence. provided, root sequence randomly generated. type Type sequences (\"DNA\", \"AA\", \"CODON\" \"USER\"). model Amino acid model evolution employ, example \"WAG\", \"JTT\", \"Dayhoff\" \"LG\". full list supported models, type phangorn:::.aamodels. Ignored type equal \"AA\". levels character vector different character tokens. Ignored unless type = \"USER\". rate numerical value greater zero giving mutation rate scaler edge lengths. ancestral Logical specifying whether return ancestral sequences. code ncbi genetic code number translation (see details). default standard genetic code used.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate sequences. — simSeq","text":"simSeq returns object class phyDat.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate sequences. — simSeq","text":"simSeq generic function simulate sequence alignments along phylogeny. quite flexible can generate DNA, RNA, amino acids, codon, morphological binary sequences. simSeq can take input phylogenetic tree class phylo, pml object; return object class phyDat. also low level version, lacks rate variation, one can combine different alignments rates (see example). rate parameter acts like scaler edge lengths. codon models type=\"CODON\", two additional arguments dnds dN/dS ratio tstv transition transversion ratio can supplied. far simSeq limited time reversible models. simSeq normalize rate matrix composed Q bf every row sums zero expected rate one, see formulas 13.14 13.15 page 205 Felsenstein (2004). edge lengths represent expected number mutations per site. Defaults: x tree class phylo, sequences generated default Jukes-Cantor DNA model (\"JC\"). bf specified, states treated equally probable. Q specified, uniform rate matrix employed.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate sequences. — simSeq","text":"Felsenstein, J. (2004). Inferring Phylogenies. Sinauer Associates, Sunderland.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Simulate sequences. — simSeq","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/simSeq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate sequences. — simSeq","text":"","code":"if (FALSE) { # \\dontrun{ data(Laurasiatherian) tree <- nj(dist.ml(Laurasiatherian)) fit <- pml(tree, Laurasiatherian, k=4) fit <- optim.pml(fit, optNni=TRUE, model=\"GTR\", optGamma=TRUE) data <- simSeq(fit) } # }   tree <- rtree(5) plot(tree) nodelabels()   # Example for simple DNA alignment data <- simSeq(tree, l = 10, type=\"DNA\", bf=c(.1,.2,.3,.4), Q=1:6,                ancestral=TRUE) as.character(data) #>    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #> t1 \"t\"  \"c\"  \"a\"  \"g\"  \"t\"  \"c\"  \"c\"  \"g\"  \"t\"  \"a\"   #> t4 \"t\"  \"g\"  \"t\"  \"t\"  \"t\"  \"g\"  \"g\"  \"c\"  \"t\"  \"c\"   #> t5 \"t\"  \"g\"  \"g\"  \"t\"  \"t\"  \"t\"  \"t\"  \"g\"  \"c\"  \"g\"   #> t3 \"t\"  \"g\"  \"t\"  \"g\"  \"c\"  \"g\"  \"t\"  \"c\"  \"t\"  \"c\"   #> t2 \"a\"  \"a\"  \"t\"  \"g\"  \"t\"  \"g\"  \"t\"  \"a\"  \"t\"  \"g\"   #> 6  \"g\"  \"t\"  \"t\"  \"t\"  \"t\"  \"t\"  \"t\"  \"t\"  \"g\"  \"t\"   #> 7  \"g\"  \"g\"  \"g\"  \"t\"  \"t\"  \"t\"  \"t\"  \"t\"  \"g\"  \"t\"   #> 8  \"g\"  \"g\"  \"t\"  \"g\"  \"t\"  \"t\"  \"t\"  \"t\"  \"t\"  \"g\"   #> 9  \"c\"  \"t\"  \"t\"  \"g\"  \"c\"  \"g\"  \"t\"  \"c\"  \"t\"  \"t\"     # Example to simulate discrete Gamma rate variation rates <- discrete.gamma(1,4) data1 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[1]) data2 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[2]) data3 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[3]) data4 <- simSeq(tree, l = 100, type=\"AA\", model=\"WAG\", rate=rates[4]) data <- c(data1,data2, data3, data4)  write.phyDat(data, file=\"temp.dat\", format=\"sequential\", nbcol = -1,   colsep = \"\") unlink(\"temp.dat\")"},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Phylogenetic Network — splitsNetwork","title":"Phylogenetic Network — splitsNetwork","text":"splitsNetwork estimates weights splits graph distance matrix.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Phylogenetic Network — splitsNetwork","text":"","code":"splitsNetwork(dm, splits = NULL, gamma = 0.1, lambda = 1e-06,   weight = NULL)"},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Phylogenetic Network — splitsNetwork","text":"dm distance matrix. splits splits object, containing splits consider, otherwise possible splits used gamma penalty value L1 constraint. lambda penalty value L2 constraint. weight vector weights.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Phylogenetic Network — splitsNetwork","text":"splitsNetwork returns splits object matrix added. first column contains indices splits, second column unconstrained fit without penalty terms third column constrained fit.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Phylogenetic Network — splitsNetwork","text":"splitsNetwork fits non-negative least-squares phylogenetic networks using L1 (LASSO), L2(ridge regression) constraints.  function minimizes penalized least squares $$\\beta = min \\sum(dm - X\\beta)^2 + \\lambda \\|\\beta \\|^2_2 $$ respect $$\\|\\beta \\|_1 <= \\gamma, \\beta >= 0$$ \\(X\\) design matrix constructed designSplits. External edges fitted without L1 L2 constraints.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Phylogenetic Network — splitsNetwork","text":"Efron, Hastie, Johnstone Tibshirani (2004) Least Angle Regression (discussion) Annals Statistics 32(2), 407–499 K. P. Schliep (2009). Applications statistical phylogenetics (PhD Thesis)","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Phylogenetic Network — splitsNetwork","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/splitsNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Phylogenetic Network — splitsNetwork","text":"","code":"data(yeast) dm <- dist.ml(yeast) fit <- splitsNetwork(dm) net <- as.networx(fit) plot(net)  write.nexus.splits(fit) #> #NEXUS #>  #> [Splits block for Spectronet or SplitsTree] #> [generated by phangorn 2.12.1.3 ] #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=8; #> \tTAXLABELS Scer Spar Smik Skud Sbay Scas Sklu Calb ; #> END; #>  #> BEGIN SPLITS; #> \tDIMENSIONS ntax=8 nsplits=11; #> \tFORMAT labels=left weights=yes confidences=no intervals=no; #> \tMATRIX #> \t\t1\t0.0651863191393167 \t1, #> \t\t2\t0.0587181503590668 \t1 3 4 5 6 7 8, #> \t\t3\t0.0696966322251354 \t1 2 4 5 6 7 8, #> \t\t4\t0.00922627016465058 \t1 2 3, #> \t\t5\t0.0814873490413281 \t1 2 3 5 6 7 8, #> \t\t6\t0.00406554599095658 \t1 2 3 4, #> \t\t7\t0.0886778824161061 \t1 2 3 4 6 7 8, #> \t\t8\t0.0867081880409384 \t1 2 3 4 5, #> \t\t9\t0.176465211301922 \t1 2 3 4 5 7 8, #> \t\t10\t0.208305976530992 \t1 2 3 4 5 6 8, #> \t\t11\t0.36479757741116 \t1 2 3 4 5 6 7, #> \t; #> END;"},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":null,"dir":"Reference","previous_headings":"","what":"Super Tree methods — superTree","title":"Super Tree methods — superTree","text":"function superTree allows estimation supertree set trees using either Matrix representation parsimony, Robinson-Foulds SPR criterion.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Super Tree methods — superTree","text":"","code":"superTree(tree, method = \"MRP\", rooted = FALSE, trace = 0,   start = NULL, multicore = FALSE, mc.cores = NULL, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Super Tree methods — superTree","text":"tree object class multiPhylo method argument defining algorithm used optimize tree.  Possible \"MRP\", \"RF\", \"SPR\". rooted resulting supertrees rooted. trace defines much information printed optimization. start starting tree can supplied. multicore logical, whether models estimated parallel. mc.cores number cores use, .e. many child processes run simultaneously. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Super Tree methods — superTree","text":"function returns object class phylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Super Tree methods — superTree","text":"function superTree extends function mrp.supertree Liam Revells, artificial adding outgroup root trees.  allows root supertree afterwards. functions internally used DensiTree. implementation RF- SPR-supertree basic far assume trees share set taxa.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Super Tree methods — superTree","text":"Baum, B. R., (1992) Combining trees way combining data sets phylogenetic inference, desirability combining gene trees. Taxon, 41, 3-10. Ragan, M. . (1992) Phylogenetic inference based matrix representation trees. Molecular Phylogenetics Evolution, 1, 53-58.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Super Tree methods — superTree","text":"Klaus Schliep klaus.schliep@gmail.com Liam Revell","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/superTree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Super Tree methods — superTree","text":"","code":"data(Laurasiatherian) set.seed(1) bs <- bootstrap.phyDat(Laurasiatherian,                        FUN = function(x) upgma(dist.hamming(x)), bs=50)  mrp_st <- superTree(bs, minit = 25, maxit=50) plot(mrp_st)  # \\donttest{ rf_st <- superTree(bs, method = \"RF\") spr_st <- superTree(bs, method = \"SPR\") # }"},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Transfer Bootstrap — transferBootstrap","title":"Transfer Bootstrap — transferBootstrap","text":"transferBootstrap assigns transfer bootstrap (Lemoine et al. 2018) values (internal) edges.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transfer Bootstrap — transferBootstrap","text":"","code":"transferBootstrap(tree, trees, phylo = TRUE, scale = TRUE)"},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transfer Bootstrap — transferBootstrap","text":"tree tree edges bootstrap values plotted. trees list trees (object class \"multiPhylo\"). phylo Logical, return phylogentic tree support value vector bootstrap values. scale scale values.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transfer Bootstrap — transferBootstrap","text":"phylogentic tree (phylo object) bootstrap values assigned node labels.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Transfer Bootstrap — transferBootstrap","text":"Lemoine, F., Entfellner, J. B. D., Wilkinson, E., Correia, D., Felipe, M. D., De Oliveira, T., & Gascuel, O. (2018). Renewing Felsenstein’s phylogenetic bootstrap era big data. Nature, 556(7702), 452–456.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Transfer Bootstrap — transferBootstrap","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/transferBootstrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transfer Bootstrap — transferBootstrap","text":"","code":"fdir <- system.file(\"extdata/trees\", package = \"phangorn\") # RAxML best-known tree with bipartition support (from previous analysis) raxml.tree <- read.tree(file.path(fdir,\"RAxML_bipartitions.woodmouse\")) # RAxML bootstrap trees (from previous analysis) raxml.bootstrap <- read.tree(file.path(fdir,\"RAxML_bootstrap.woodmouse\"))  tree_tbe <- transferBootstrap(raxml.tree,  raxml.bootstrap) par(mfrow=c(1,2)) plotBS(tree_tbe) # same as plotBS(raxml.tree,  raxml.bootstrap, \"p\", \"TBE\")"},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":null,"dir":"Reference","previous_headings":"","what":"Distances between trees — treedist","title":"Distances between trees — treedist","text":"treedist computes different tree distance methods RF.dist Robinson-Foulds symmetric distance. Robinson-Foulds distance depends topology trees. edge weights considered wRF.dist calculates weighted RF distance (Robinson & Foulds 1981). KF.dist calculates branch score distance (Kuhner & Felsenstein 1994).  path.dist computes path difference metric described Steel Penny 1993). sprdist computes approximate SPR distance (Oliveira Martins et al. 2008, de Oliveira Martins 2016).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distances between trees — treedist","text":"","code":"treedist(tree1, tree2, check.labels = TRUE)  sprdist(tree1, tree2)  SPR.dist(tree1, tree2 = NULL)  RF.dist(tree1, tree2 = NULL, normalize = FALSE, check.labels = TRUE,   rooted = FALSE)  wRF.dist(tree1, tree2 = NULL, normalize = FALSE, check.labels = TRUE,   rooted = FALSE)  KF.dist(tree1, tree2 = NULL, check.labels = TRUE, rooted = FALSE)  path.dist(tree1, tree2 = NULL, check.labels = TRUE, use.weight = FALSE)"},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distances between trees — treedist","text":"tree1 phylogenetic tree (class phylo) vector trees (object class multiPhylo). See details tree2 phylogenetic tree. check.labels compares labels trees. normalize compute normalized RF-distance, see details. rooted take bipartitions rooted trees account, default unrooting trees. use.weight use edge.length argument just count number edges path (default)","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distances between trees — treedist","text":"treedist returns vector containing following tree distance methods symmetric.difference symmetric.difference Robinson-Foulds distance branch.score.difference branch.score.difference path.difference path.difference weighted.path.difference weighted.path.difference","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distances between trees — treedist","text":"Robinson-Foulds distance two trees \\(T_1\\) \\(T_2\\) \\(n\\) tips defined (following notation Steel Penny 1993): $$d(T_1, T_2) = (T_1) + (T_2) - 2v_s(T_1, T_2)$$ \\((T_1)\\) denotes number internal edges \\(v_s(T_1, T_2)\\) denotes number internal splits shared two trees. normalized Robinson-Foulds distance derived dividing \\(d(T_1, T_2)\\) maximal possible distance \\((T_1) + (T_2)\\). trees unrooted binary value \\(2n-6\\). Functions like RF.dist returns Robinson-Foulds distance (Robinson Foulds 1981) either 2 trees computes matrix pairwise distances multiPhylo object given. large number trees distance functions can use lot memory!","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distances between trees — treedist","text":"de Oliveira Martins L., Leal E., Kishino H. (2008) Phylogenetic Detection Recombination Bayesian Prior Distance Trees. PLoS ONE 3(7). e2651. doi: 10.1371/journal.pone.0002651 de Oliveira Martins L., Mallo D., Posada D. (2016) Bayesian Supertree Model Genome-Wide Species Tree Reconstruction. Syst. Biol. 65(3): 397-416, doi:10.1093/sysbio/syu082 Steel M. . Penny P. (1993) Distributions tree comparison metrics - new results, Syst. Biol., 42(2), 126–141 Kuhner, M. K. Felsenstein, J. (1994) simulation comparison phylogeny algorithms equal unequal evolutionary rates, Molecular Biology Evolution, 11(3), 459–468 D.F. Robinson L.R. Foulds (1981) Comparison phylogenetic trees, Mathematical Biosciences, 53(1), 131–147 D.F. Robinson L.R. Foulds (1979) Comparison weighted labelled trees. Horadam, . F. Wallis, W. D. (Eds.), Combinatorial Mathematics VI: Proceedings Sixth Australian Conference Combinatorial Mathematics, Armidale, Australia, 119–126","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distances between trees — treedist","text":"Klaus P. Schliep klaus.schliep@gmail.com, Leonardo de Oliveira Martins","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/treedist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distances between trees — treedist","text":"","code":"tree1 <- rtree(100, rooted=FALSE) tree2 <- rSPR(tree1, 3) RF.dist(tree1, tree2) #> [1] 36 treedist(tree1, tree2) #>      symmetric.difference   branch.score.difference           path.difference  #>                 36.000000                  3.103532                213.072758  #> quadratic.path.difference  #>                117.670374  sprdist(tree1, tree2) #>       spr spr_extra        rf     hdist  #>         3         0        36        39  trees <- rSPR(tree1, 1:5) SPR.dist(tree1, trees) #> [1] 1 2 3 4 4"},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":null,"dir":"Reference","previous_headings":"","what":"UPGMA, WPGMA and sUPGMA — upgma","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"UPGMA WPGMA clustering. UPGMA (Sokal Michener 1958) WPGMA (McQuitty 1966) wrapper function around hclust returning phylo object. supgma perform serial sampled UPGMA similar Drummond Rodrigo (2000).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"","code":"upgma(D, method = \"average\", ...)  wpgma(D, method = \"mcquitty\", ...)  supgma(D, tip.dates, trace = 0, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"D distance matrix, .e. object class dist. matrix supplied tried covert dist object. method agglomeration method used. (unambiguous abbreviation ) one \"ward\", \"single\", \"complete\", \"average\", \"mcquitty\", \"median\" \"centroid\". default \"average\" UPGMA \"mcquitty\" WPGMA. ... arguments passed methods. tip.dates named vector sampling times associated tips. trace Show output optimization (see details).","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"phylogenetic tree class phylo.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"UPGMA WPGMA return ultrametric trees, implicitly assumed distances supplied close ultrametric, e.g. hold molecular clock assumption. Neighbor Joining (NJ) nj fastME fastme relax assumption additive distances. sUPGMA assumes tip dated data. tip.dates vector sampling times, time unit, time increasing toward present. example, may units \"days since study start\" \"years since 10.000 BCE\", \"millions years ago\".","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"Sneath, P. H., & Sokal, R. R. (1973). Numerical taxonomy. principles practice numerical classification. Sokal, R. R., & Michener, C. D. (1958). statistical method evaluating systematic relationships. University Kansas Scientific Bulletin, v. 38. Drummond, ., & Rodrigo, . G. (2000). Reconstructing genealogies serial samples assumption molecular clock using serial-sample UPGMA. Molecular Biology Evolution, 17(12), 1807-1815. McQuitty, L.L. (1966). Similarity Analysis Reciprocal Pairs Discrete Continuous Data. Educational Psychological Measurement, 26, 825–831.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/upgma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"UPGMA, WPGMA and sUPGMA — upgma","text":"","code":"data(Laurasiatherian) dm <- dist.ml(Laurasiatherian) tree <- upgma(dm) plot(tree)"},{"path":"https://klausvigo.github.io/phangorn/reference/write.ancestral.html","id":null,"dir":"Reference","previous_headings":"","what":"Export and convenience functions for ancestral reconstructions — write.ancestral","title":"Export and convenience functions for ancestral reconstructions — write.ancestral","text":"write.ancestral allows export ancestral reconstructions. writes tree, tab delimited text file probabilities alignment. ancestral generates object class ancestral.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/write.ancestral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export and convenience functions for ancestral reconstructions — write.ancestral","text":"","code":"write.ancestral(x, file = \"ancestral\")  as.ancestral(tree, prob, align = NULL)  # S3 method for class 'ancestral' print(x, ...)  # S3 method for class 'ancestral' as.phyDat(x, ...)  # S3 method for class 'ancestral' as.data.frame(x, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/write.ancestral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export and convenience functions for ancestral reconstructions — write.ancestral","text":"x object class ancestral file file name. File endings added. tree object class phylo. prob data.frame containing matrix posterior probabilities state site. align object class phyDat. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/write.ancestral.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export and convenience functions for ancestral reconstructions — write.ancestral","text":"write.ancestral  returns input x invisibly.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/write.ancestral.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export and convenience functions for ancestral reconstructions — write.ancestral","text":"allows also read reconstruction  made iqtree use plotting capabilities R.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/write.ancestral.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export and convenience functions for ancestral reconstructions — write.ancestral","text":"","code":"data(Laurasiatherian) fit <- pml_bb(Laurasiatherian[,1:100], \"JC\", rearrangement = \"none\") #> optimize edge weights:  -2153.509 --> -2143.08  #> optimize edge weights:  -2143.08 --> -2143.08  #> optimize edge weights:  -2143.08 --> -2143.08  anc_ml <- anc_pml(fit) write.ancestral(anc_ml) # Can be also results from iqtree align <- read.phyDat(\"ancestral_align.fasta\", format=\"fasta\") tree <- read.tree(\"ancestral_tree.nwk\") df <- read.table(\"ancestral_state.tsv\", header=TRUE) anc_ml_disc <- as.ancestral(tree, df, align) plotAnc(anc_ml_disc, 20)  unlink(c(\"ancestral_align.fasta\", \"ancestral_tree.nwk\",          \"ancestral_state.tsv\"))"},{"path":"https://klausvigo.github.io/phangorn/reference/write.pml.html","id":null,"dir":"Reference","previous_headings":"","what":"Export pml objects — write.pml","title":"Export pml objects — write.pml","text":"write.pml writes ML tree model parameters.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/write.pml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export pml objects — write.pml","text":"","code":"write.pml(x, file = \"pml\", save_rds = FALSE, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/write.pml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export pml objects — write.pml","text":"x object class ancestral. file file name. File endings added. save_rds logical, TRUE saves pml object rds file, otherwise alignment saved fasta file. ... arguments passed methods.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/write.pml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export pml objects — write.pml","text":"write.pml  returns input x invisibly.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/write.pml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export pml objects — write.pml","text":"","code":"data(woodmouse) fit <- pml_bb(woodmouse, \"JC\", rearrangement = \"none\") #> optimize edge weights:  -1860.499 --> -1856.056  #> optimize edge weights:  -1856.056 --> -1856.056  #> optimize edge weights:  -1856.056 --> -1856.056  write.pml(fit, \"woodmouse\") unlink(c(\"woodmouse.txt\", \"woodmouse_tree.nwk\", \"woodmouse_align.fasta\"))"},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Writing and reading distances in phylip and nexus format — writeDist","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"readDist, writeDist write.nexus.dist useful exchange distance matrices phylogenetic programs.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"","code":"writeDist(x, file = \"\", format = \"phylip\", ...)  write.nexus.dist(x, file = \"\", append = FALSE, upper = FALSE,   diag = TRUE, digits = getOption(\"digits\"), taxa = !append)  readDist(file, format = \"phylip\")  read.nexus.dist(file)  # S3 method for class 'dist' unique(x, incomparables, ...)"},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"x dist object. file file name. format file format, default \"phylip\", option far \"nexus\". ... arguments passed methods. append logical. TRUE nexus blocks added file. upper logical value indicating whether upper triangle distance matrix printed. diag logical value indicating whether diagonal distance matrix printed. digits passed format inside write.nexus.dist. taxa logical. TRUE taxa block added. incomparables used far.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"object class dist","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"Maddison, D. R., Swofford, D. L. Maddison, W. P. (1997) NEXUS: extensible file format systematic information. Systematic Biology, 46, 590–621.","code":""},{"path":[]},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"Klaus Schliep klaus.schliep@gmail.com","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/writeDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Writing and reading distances in phylip and nexus format — writeDist","text":"","code":"data(yeast) dm <- dist.ml(yeast) writeDist(dm) #> 8  #> Scer 0 0.0867845773228219 0.137636794490986 0.161087155171287 0.177174556271658 0.345373797843901 0.381679949757669 0.537234265198945 #> Spar 0.0867845773228219 0 0.123600617669834 0.149284159950583 0.166375240744154 0.343965239042025 0.380724585630441 0.537427661847541 #> Smik 0.137636794490986 0.123600617669834 0 0.155370638334037 0.173395434179653 0.345111830071115 0.381038543686742 0.5378791145715 #> Skud 0.161087155171287 0.149284159950583 0.155370638334037 0 0.156795687803861 0.351411419602885 0.383976534826637 0.548399135029346 #> Sbay 0.177174556271658 0.166375240744154 0.173395434179653 0.156795687803861 0 0.34592156486885 0.3809600418506 0.548845409688793 #> Scas 0.345373797843901 0.343965239042025 0.345111830071115 0.351411419602885 0.34592156486885 0 0.390140463219943 0.52768391927111 #> Sklu 0.381679949757669 0.380724585630441 0.381038543686742 0.383976534826637 0.3809600418506 0.390140463219943 0 0.542132862145574 #> Calb 0.537234265198945 0.537427661847541 0.5378791145715 0.548399135029346 0.548845409688793 0.52768391927111 0.542132862145574 0 write.nexus.dist(dm) #> #NEXUS #>  #> BEGIN TAXA; #> \tDIMENSIONS ntax=8; #> \tTAXLABELS Scer Spar Smik Skud Sbay Scas Sklu Calb ; #> END; #>  #> BEGIN DISTANCES;  #> \tFORMAT TRIANGLE = LOWER; #> \tMatrix  #> \tScer 0.00000000 #> \tSpar 0.08678458 0.00000000 #> \tSmik 0.13763679 0.12360062 0.00000000 #> \tSkud 0.16108716 0.14928416 0.15537064 0.00000000 #> \tSbay 0.17717456 0.16637524 0.17339543 0.15679569 0.00000000 #> \tScas 0.34537380 0.34396524 0.34511183 0.35141142 0.34592156 0.00000000 #> \tSklu 0.38167995 0.38072459 0.38103854 0.38397653 0.38096004 0.39014046 0.00000000 #> \tCalb 0.53723427 0.53742766 0.53787911 0.54839914 0.54884541 0.52768392 0.54213286 0.00000000 #> \t; #> END;"},{"path":"https://klausvigo.github.io/phangorn/reference/yeast.html","id":null,"dir":"Reference","previous_headings":"","what":"Yeast alignment (Rokas et al.) — yeast","title":"Yeast alignment (Rokas et al.) — yeast","text":"Alignment 106 genes 8 different species yeast.","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/yeast.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Yeast alignment (Rokas et al.) — yeast","text":"Rokas, ., Williams, B. L., King, N., Carroll, S. B. (2003) Genome-scale approaches resolving incongruence molecular phylogenies. Nature, 425(6960): 798–804","code":""},{"path":"https://klausvigo.github.io/phangorn/reference/yeast.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Yeast alignment (Rokas et al.) — yeast","text":"","code":"data(yeast) str(yeast) #> List of 8 #>  $ Scer: int [1:8899] 4 2 4 4 1 4 3 1 3 3 ... #>  $ Spar: int [1:8899] 4 2 4 4 3 4 1 1 3 3 ... #>  $ Smik: int [1:8899] 4 2 2 4 3 2 1 1 1 3 ... #>  $ Skud: int [1:8899] 4 2 4 4 3 2 1 1 3 3 ... #>  $ Sbay: int [1:8899] 4 2 4 4 1 2 1 1 3 3 ... #>  $ Scas: int [1:8899] 4 2 1 2 1 4 1 1 1 3 ... #>  $ Sklu: int [1:8899] 4 2 4 2 4 2 1 1 3 3 ... #>  $ Calb: int [1:8899] 4 2 4 2 4 4 3 1 1 3 ... #>  - attr(*, \"class\")= chr \"phyDat\" #>  - attr(*, \"weight\")= int [1:8899] 16974 7986 25 132 1 78 29 17646 42 12618 ... #>  - attr(*, \"nr\")= int 8899 #>  - attr(*, \"nc\")= num 4 #>  - attr(*, \"index\")='data.frame':\t127026 obs. of  2 variables: #>   ..$ index: int [1:127026] 1 2 3 4 1 5 6 1 7 8 ... #>   ..$ genes: Factor w/ 106 levels \"YAL053W\",\"YAR007C\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \"levels\")= chr [1:4] \"a\" \"c\" \"g\" \"t\" #>  - attr(*, \"allLevels\")= chr [1:18] \"a\" \"c\" \"g\" \"t\" ... #>  - attr(*, \"type\")= chr \"DNA\" #>  - attr(*, \"contrast\")= num [1:18, 1:4] 1 0 0 0 0 1 1 1 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:4] \"a\" \"c\" \"g\" \"t\""}]

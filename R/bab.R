# branch and bound
getOrder <- function(x) {
  label <- names(x)
  dm <- as.matrix(dist.hamming(x, FALSE))
  ind <- as.vector(which(dm == max(dm), arr.ind = TRUE)[1, ])
  nTips <- as.integer(length(label))
  added <- ind
  remaining <- c(1:nTips)[-ind]

  tree <- structure(list(edge = structure(c(rep(nTips + 1L, 3), c(ind, 0L)),
        .Dim = c(3L, 2L)), tip.label = label, Nnode = 1L), .Names = c("edge",
        "tip.label", "Nnode"), class = "phylo", order = "postorder")

  l <- length(remaining)
  res <- numeric(l)

  nr <- attr(x, "nr")
  storage.mode(nr) <- "integer"

  weight <- attr(x, "weight")
  storage.mode(weight) <- "double"

  f <- init_fitch(x, FALSE, FALSE, m = 4L)

  edge <- tree$edge
  for (i in seq_along(remaining)) {
    edge[3, 2] <- remaining[i]
    res[i] <- f$pscore(edge)
  }
  tmp <- which.max(res)
  added <- c(added, remaining[tmp])
  remaining <- remaining[-tmp]
  tree$edge[, 2] <- added

  while (length(remaining) > 0) {
#    edge <- tree$edge[, 2] + 2 * nTips
    f$prep_spr(tree$edge)
    l <- length(remaining)
    res <- numeric(l)
    nt <- numeric(l)
    for (j in 1:l) {
      score <- f$pscore_vec(tree$edge, remaining[j])
      res[j] <- min(score)
      nt[j] <- which.min(score)
    }
    tmp <- which.max(res)
    added <- c(added, remaining[tmp])
    tree <- addOne(tree, remaining[tmp], nt[tmp])
    remaining <- remaining[-tmp]
  }
  added <- c(added, remaining)
  added
}


seq_stats <- function(x) {
  nr <- attr(x, "nr")
  contrast <- attr(x, "contrast")
  lev <- attr(x, "allLevels")
  a <- seq_len(nr)
  STATE <- POS <- matrix(0L, nrow(contrast), nr, dimnames = list(lev, NULL))
  for(i in seq_along(x)){
    IND <- cbind(x[[i]], a)
    STATE[IND] <- STATE[IND] + 1L
    POS[IND] <- i
  }
  list(state = STATE, position = POS)
}


extract_cherries <- function(x){
  x <- removeParsimonyUninfomativeSites(x)
  x <- compressSites(x)
  nr <- attr(x, "nr")
  lb <- lowerBound(x)
  ub <- upperBound(x)
  ii <- which(ub==2)

  w <- attr(x, "weight")
  z <- x
  attr(z, "weight") <- rep(1, nr)
  attr(z, "index") <- NULL

  y <- as.character(z)
  singles <- attr(z, "levels")
  fun2 <- function(x, singles) all(x %in% singles)
  single_pos <- apply(y, 2, fun2, singles)

  ii <- which(ub==2 & lb==1 & single_pos)

  w <- attr(x, "weight")
  X <- seq_stats(x)[[1]]
  Y <- matrix(unlist(x), ncol=length(x))
  edge <- matrix(NA_integer_, length(ii), 2)
  for(i in seq_along(ii)){
    pos <- which(X[,ii[i]]==2)
    edge[i,] <- which(Y[ii[i],]==pos)
  }
  list(edge = edge, g = igraph::graph_from_edgelist(edge, directed =FALSE),
       weight = w[ii], pos = ii, nTip = length(x))
}


cherries <- function(obj, LB, UB){
  weight <- obj$weight
  edge <- obj$edge
  tt <- tabulate(obj$edge)
  eps <- 1e-6
  edge_2 <- edge
  res <- numeric(obj$nTip)

  LB <- subset(LB, select=obj$pos)
  UB <- subset(UB, select=obj$pos)

  while(any(tt >= (2-eps))){
    max_pos <- which(tt > (max(tt)-eps))
    max_pos <- max_pos[length(max_pos)]

    lb_tt <- as.integer(2L * max(tt) - 1L)
    ind_max <- which(edge==max_pos, arr.ind = TRUE)[,1] |> sort()
    ind_max <- intersect(ind_max, which(weight>1e-6))
    e1 <- edge[ind_max, ]

    #    cs <- cumsum(tabulate(e1, obj$nTip))
    #    cs1 <- pmin(cs, lb_tt)
    #    cs1 <- lb_tt - cs1
    #    cs <- pmax(lb_tt - cs, 0)

    w0 <- min(weight[ind_max])

    old_lb <- rowSums(LB[, ind_max, drop=FALSE])
    old_lb <- old_lb[obj$nTip] - old_lb

    old_ub <- rowSums(UB[, ind_max, drop=FALSE])
    old_ub <- pmax(lb_tt - old_ub, 0)

    weight[ind_max] <- weight[ind_max] - w0
    edge_2 <- edge[weight>1e-6, ]
    tt <- tabulate(edge_2)
    res <- res + w0 * (old_ub - old_lb)
  }
  list(res=res, weight=weight)
}


# Incompatibility lower Bound
ilb <- function(x, LB) {
  nr <- attr(x, "nr")
  contrast <- attr(x, "contrast")
  rownames(contrast) <- attr(x, "allLevels")
  colnames(contrast) <- attr(x, "levels")
  weight0 <- attr(x, "weight")
  attr(x, "weight") <- rep(1, nr)
  attr(x, "index") <- NULL

  y <- as.character(x)
  singles <- attr(x, "levels")
  fun2 <- function(x, singles) all(x %in% singles)
  fun1 <- function(x) cumsum(!duplicated(x)) - 1L
  fun3 <- function(x) sum(!duplicated(x)) - 1L

  tmp <- apply(y, 2, fun2, singles)
  ind <- which(tmp & (weight0 > 1e-6))
  if (length(ind) < 2) return(0)

  y <- y[, ind, drop = FALSE]
  weight0 <- weight0[ind]
  single_dis <- LB[, ind]
  nTips <- nrow(y)
  l <- length(weight0)
  res <- numeric(nTips)
  for (i in 1:(l - 1)) {
    for (j in (i + 1):l) {
      if ((weight0[i] > 1e-6) && (weight0[j] > 1e-6)) {
        z <- paste(y[, i], y[, j], sep = "_")
        dis2 <- single_dis[, i] + single_dis[, j]
        dis <- fun1(z)
        if (dis[nTips] > dis2[nTips]) {
##browser()
          dis <- pmax(dis, dis2)
##if(any(diff(dis)<0))browser()
          dis <- dis - dis2

          if (sum(dis[4:nTips]) > 0) {
            wmin <- min(weight0[i], weight0[j])
            weight0[i] <- weight0[i] - wmin
            weight0[j] <- weight0[j] - wmin
            res <- res + dis * wmin
          }
        }
      }
      if(weight0[i] < 1e-6) break()
    }
  }
  res
}


#' Branch and bound for finding all most parsimonious trees
#'
#' \code{bab} finds all most parsimonious trees.
#'
#' This implementation is very slow and depending on the data may take very
#' long time. In the worst case all \eqn{(2n-5)!! = 1 \times 3 \times 5
#' \times \ldots \times (2n-5)}{(2n-5)!! = 1 * 3 * 5 * ... * (2n-5)} possible
#' trees have to be examined, where n is the number of species / tips. For ten
#' species there are already 2027025 tip-labelled unrooted trees. It only uses
#' some basic strategies to find a lower and upper bounds similar to penny from
#' phylip. \code{bab} uses a very basic heuristic approach of MinMax Squeeze
#' (Holland et al. 2005) to improve the lower bound. \cr
#' \code{bab} might return multifurcating trees. These multifurcations could be
#' resolved in all ways. \cr
#' On the positive side \code{bab} is not like many other implementations
#' restricted to binary or nucleotide data.
#'
#' @aliases bab BranchAndBound
#' @param data an object of class phyDat.
#' @param tree a phylogenetic tree an object of class phylo, otherwise a
#' pratchet search is performed.
#' @param trace defines how much information is printed during optimization.
## @param ILBound compute incompatibility lower bound (default TRUE) of
## Holland (2005).
#' @param \dots Further arguments passed to or from other methods
#' @return \code{bab} returns all most parsimonious trees in an object of class
#' \code{multiPhylo}.
#' @author Klaus Schliep \email{klaus.schliep@@gmail.com} based on work on Liam
#' Revell
#' @seealso \code{\link{pratchet}}, \code{\link{dfactorial}}
#' @references Hendy, M.D. and Penny D. (1982) Branch and bound algorithms to
#' determine minimal evolutionary trees.  \emph{Math. Biosc.} \bold{59},
#' 277-290
#'
#' Holland, B.R., Huber, K.T. Penny, D. and Moulton, V. (2005) The MinMax
#' Squeeze: Guaranteeing a Minimal Tree for Population Data, \emph{Molecular
#' Biology and Evolution}, \bold{22}, 235--242
#'
#' White, W.T. and Holland, B.R. (2011) Faster exact maximum parsimony search
#' with XMP. \emph{Bioinformatics}, \bold{27(10)},1359--1367
#' @keywords cluster
#' @importFrom utils txtProgressBar setTxtProgressBar
## @importFrom cli cli_progress_bar cli_progress_update cli_progress_done
#' @examples
#'
#' data(yeast)
#' dfactorial(11)
#' # choose only the first two genes
#' gene12 <- yeast[, 1:3158]
#' trees <- bab(gene12)
#'
#' @export
bab <- function(data, tree = NULL, trace = 1, ...) {
  #  if (hasArg(ILBound))
  #    ILBound <- list(...)$ILBound
  #  else
  ILBound <- FALSE
  if(inherits(data, "DNAbin") || inherits(data, "AAbin")) data <- as.phyDat(data)
  assert_phyDat(data)
  nTips <- length(data)
  if (nTips < 4) return(stree(nTips, tip.label = names(data)))
  data <- removeParsimonyUninfomativeSites(data, recursive = TRUE)
  star_tree <- attr(data, "nr") == 0
  add_taxa <- !is.null(attr(data, "duplicated"))
  p0 <- attr(data, "p0")

  nTips <- length(data)
  if (nTips < 4L  || star_tree) {
    nam <- names(data)
    if (star_tree) tree <- stree(length(nam), tip.label = nam)
    else tree <- stree(nTips, tip.label = names(data))
    if(add_taxa) tree <- addTaxa(tree, attr(data, "duplicated"))
    tree <- unroot(tree)
    return(tree)
  }

  # compress sequences (all transitions count equal)
  data <- compressSites(data)
  o <- order(attr(data, "weight"), decreasing = TRUE)
  data <- subset(data, select = o, site.pattern = TRUE)

  nr <- as.integer(attr(data, "nr"))
  inord <- getOrder(data)
  data <- data[inord, ]
  if(trace > 0) cat("Compute starting tree\n")
  tree <- pratchet(data, start = tree, trace = trace - 1, maxit = 10,
                   all = FALSE, ...)
  #  p_vec <- fitch(tree, data, "site")

  nTips <- m <- length(data)
  LB <- UB <- matrix(0, m, nr) # UB <-
  for (i in 2:m) {
    LB[i, ] <- lowerBound(data[1:i, ])
    UB[i, ] <- upperBound(data[1:i, ])
  }

  weight <- as.double(attr(data, "weight"))

  m <- nr * (2L * nTips - 2L)
  # Single column discrepancy
  mmsAmb <- LB %*% weight
  #  mmsAmb <- mmsAmb[nTips] - mmsAmb
  mms0 <- mms1 <- 0

  cherry <- TRUE
  if(cherry){
    ec <- extract_cherries(data)
    cherry_res  <- cherries(ec, LB, UB)
    weight_cherry <- weight
    weight_cherry[ec$pos] <- cherry_res$weight
    data2 <- data
    attr(data2, "weight") <- weight_cherry
  }

  if (ILBound){  # tests needed
    if(cherry) mms1 <- ilb(data2, LB)
    else mms1 <- ilb(data, LB)
  }
  mms0 <- mms1 + mmsAmb
  mms0 <- mms0[nTips] - mms0
  if(cherry)mms0 <- mms0 + cherry_res$res
  mms0 <- c(mms0, 0)

  f <- init_fitch(data, m = 4L)

  bound <- f$pscore(tree$edge)
  if (trace) {
    cat("lower bound:", p0 + mms0[1], "\n")
    cat("upper bound:", bound, "\n")
  }
  startTree <- structure(list(edge = structure(c(rep(nTips + 1L, 3),
                                                 as.integer(1:3)), .Dim = c(3L, 2L)), tip.label = names(data),
                              Nnode = 1L), .Names = c("edge", "tip.label", "Nnode"), class = "phylo",
                         order = "postorder")

  trees <- vector("list", nTips)
  trees[[3]] <- list(startTree$edge)
  for (i in 4:nTips) trees[[i]] <- vector("list", (2L * i) - 5L) # new

  # index M[i] is neues node fuer edge i+1
  # index L[i] is length(node) tree mit i+1
  L <- as.integer(2L * (1L:nTips) - 3L)
  M <- as.integer(1L:nTips + nTips - 1L)

  PSC <- matrix(0, sum(L), 3)
  PSC[1, ] <- c(3, 1, 0)
  PSC[1, 3] <- f$pscore(startTree$edge)
  Nnode <- 1L
  npsc <- 1L
  status <- 0
  visited <- numeric(nTips)
  if (trace > 0 && nTips > 6) {
    cat("Search Baumraum (tree space)\n")
    pb <- txtProgressBar(min = 0, max = 105, initial = 0, style = 3)
    #    cli_progress_bar("Search Baumraum (tree space)", total = 105, clear=TRUE)
  }
  result <- list()
  while (npsc > 0) {
    a <- PSC[npsc, 1] # in C++ a.back()
    b <- PSC[npsc, 2]  # in C++ b.back()
    blub <- PSC[npsc, 3]  # in C++ blub.back()
    npsc <- npsc - 1L
    tmpTree <- trees[[a]][[b]]
    score <- f$pscore_spr(tmpTree, as.integer(a + 1L))
    score <- score + blub + mms0[a + 1L]
    ms <- min(score)
    if (ms < bound + 0.1) {
      if ((a + 1L) < nTips) {
        ind <- (1:L[a])[score <= bound]   # sehr langsam
        trees[[a + 1]][seq_along(ind)] <- .Call("AddOnes", tmpTree,
                                                as.integer(a + 1L), as.integer(ind), as.integer(L[a]),
                                                as.integer(M[a]))
        l <- length(ind)
        os <- seq_len(l)
        PSC[npsc + os, ] <- c(rep(a + 1, l), os, score[ind] - mms0[a + 1L])
        npsc <- npsc + l
        visited[a + 1] <- visited[a + 1] + l
      } else {
        ind <- which(score == ms)
        tmp <- vector("list", length(ind))
        tmp[seq_along(ind)] <- .Call("AddOnes", tmpTree,
                                     as.integer(a + 1L), as.integer(ind),
                                     as.integer(L[a]), as.integer(M[a]))
        if (ms + 1e-6 < bound) {
          bound <- ms
          if (trace) cat("upper bound:", bound + p0, "\n")
          result <- tmp
          TMP <- PSC[seq_len(npsc), ]
          TMP <- TMP[TMP[, 3] < (bound + 1e-8), ]
          npsc <- nrow(TMP)
          PSC[seq_len(npsc), ] <- TMP
        } else result <- c(result, tmp)
      }
    }
    if(a == 6 && trace > 0 ) setTxtProgressBar(pb, status <- status + 1)
    #cli_progress_update()
  }
  for (i in seq_along(result)) {
    result[[i]] <- structure(list(edge = result[[i]], Nnode = nTips - 2L),
                             .Names = c("edge", "Nnode"), class = "phylo",
                             order = "postorder")
  }
  if(trace > 0  && nTips > 6) {
    setTxtProgressBar(pb, 105)
    close(pb)
    #    cli_progress_done()
  }
  attr(result, "TipLabel") <- tree$tip.label
  class(result) <- "multiPhylo"
  if(add_taxa) result <- addTaxa(result, attr(data, "duplicated"))
  attr(result, "visited") <- visited
  return(result)
}
